diff --git a/CMakeLists.txt b/CMakeLists.txt
index 50f5e3799..00866966e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -124,7 +124,7 @@ if(CMAKE_COMPILER_IS_GNUCXX OR CLANG)
     # clang-cl sets different default warnings than clang. It also treats -Wall
     # as -Weverything, to match MSVC. Instead -W3 is the alias for -Wall.
     # See http://llvm.org/viewvc/llvm-project?view=revision&revision=319116
-    set(C_CXX_FLAGS "${C_CXX_FLAGS} -W3 -Wno-unused-parameter -fmsc-version=1900")
+    set(C_CXX_FLAGS "${C_CXX_FLAGS} -W3 -Wno-unused-parameter -fmsc-version=1900 -Wno-deprecated")
   else()
     if(EMSCRIPTEN)
       # emscripten's emcc/clang does not accept the "-ggdb" flag.
@@ -505,7 +505,6 @@ target_include_directories(
 # themselves as dependencies next to the target definition.
 add_custom_target(all_tests)
 
-add_subdirectory(ssl/test)
 add_subdirectory(util/fipstools)
 add_subdirectory(util/fipstools/acvp/modulewrapper)
 
@@ -686,9 +685,6 @@ add_executable(crypto_test ${CRYPTO_TEST_SOURCES})
 target_link_libraries(crypto_test test_support_lib boringssl_gtest crypto)
 add_dependencies(all_tests crypto_test)
 
-add_executable(ssl_test ${SSL_TEST_SOURCES})
-target_link_libraries(ssl_test test_support_lib boringssl_gtest ssl crypto)
-add_dependencies(all_tests ssl_test)
 add_executable(decrepit_test ${DECREPIT_TEST_SOURCES})
 target_link_libraries(decrepit_test test_support_lib boringssl_gtest
                       decrepit crypto)
@@ -717,9 +713,8 @@ target_link_libraries(bssl ssl crypto)
 # existing tools, we, for now, copy the targets into the subdirectories. This
 # will be removed sometime in 2024.
 copy_post_build(crypto crypto crypto_test urandom_test)
-copy_post_build(ssl ssl ssl_test)
+copy_post_build(ssl ssl)
 copy_post_build(decrepit decrepit decrepit_test)
-copy_post_build(tool bssl)
 
 if(FUZZ)
   if(LIBFUZZER_FROM_DEPS)
@@ -777,30 +772,6 @@ file(STRINGS util/go_tests.txt GO_TESTS)
 set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS
              util/go_tests.txt)
 
-if(GO_EXECUTABLE)
-  add_custom_target(
-      run_tests
-      COMMAND ${CMAKE_COMMAND} -E echo "Running Go tests"
-      COMMAND ${GO_EXECUTABLE} test ${GO_TESTS}
-      COMMAND ${CMAKE_COMMAND} -E echo
-      COMMAND ${CMAKE_COMMAND} -E echo "Running unit tests"
-      COMMAND ${GO_EXECUTABLE} run util/all_tests.go -build-dir
-              ${CMAKE_CURRENT_BINARY_DIR}
-      COMMAND ${CMAKE_COMMAND} -E echo
-      COMMAND ${CMAKE_COMMAND} -E echo "Running SSL tests"
-      COMMAND cd ssl/test/runner &&
-              ${GO_EXECUTABLE} test -shim-path $<TARGET_FILE:bssl_shim>
-                ${HANDSHAKER_ARGS} ${RUNNER_ARGS}
-      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
-      DEPENDS all_tests bssl_shim handshaker fips_specific_tests_if_any
-      USES_TERMINAL)
-else()
-  add_custom_target(
-      run_tests
-      COMMAND ${CMAKE_COMMAND} -E echo "Running tests requires Go"
-      COMMAND ${CMAKE_COMMAND} -E false)
-endif()
-
 if(INSTALL_ENABLED)
   install(TARGETS crypto ssl EXPORT OpenSSLTargets)
   install(TARGETS bssl)
diff --git a/crypto/cipher/e_tls.cc b/crypto/cipher/e_tls.cc
index ccb677bad..55bba4e3f 100644
--- a/crypto/cipher/e_tls.cc
+++ b/crypto/cipher/e_tls.cc
@@ -422,6 +422,22 @@ static int aead_aes_256_cbc_sha1_tls_implicit_iv_init(
                        EVP_sha1(), 1);
 }
 
+static int aead_aes_256_cbc_sha256_tls_init(EVP_AEAD_CTX *ctx,
+                                            const uint8_t *key, size_t key_len,
+                                            size_t tag_len,
+                                            enum evp_aead_direction_t dir) {
+  return aead_tls_init(ctx, key, key_len, tag_len, dir, EVP_aes_256_cbc(),
+                       EVP_sha256(), 0);
+}
+
+static int aead_aes_256_cbc_sha384_tls_init(EVP_AEAD_CTX *ctx,
+                                            const uint8_t *key, size_t key_len,
+                                            size_t tag_len,
+                                            enum evp_aead_direction_t dir) {
+  return aead_tls_init(ctx, key, key_len, tag_len, dir, EVP_aes_256_cbc(),
+                       EVP_sha384(), 0);
+}
+
 static int aead_des_ede3_cbc_sha1_tls_init(EVP_AEAD_CTX *ctx,
                                            const uint8_t *key, size_t key_len,
                                            size_t tag_len,
@@ -536,6 +552,40 @@ static const EVP_AEAD aead_aes_256_cbc_sha1_tls_implicit_iv = {
     aead_tls_tag_len,
 };
 
+static const EVP_AEAD aead_aes_256_cbc_sha256_tls = {
+    SHA256_DIGEST_LENGTH + 32,  // key len (SHA256 + AES256)
+    16,                         // nonce len (IV)
+    16 + SHA256_DIGEST_LENGTH,  // overhead (padding + SHA256)
+    SHA256_DIGEST_LENGTH,       // max tag length
+    0,                          // seal_scatter_supports_extra_in
+
+    NULL,  // init
+    aead_aes_256_cbc_sha256_tls_init,
+    aead_tls_cleanup,
+    aead_tls_open,
+    aead_tls_seal_scatter,
+    NULL,  // open_gather
+    NULL,  // get_iv
+    aead_tls_tag_len,
+};
+
+static const EVP_AEAD aead_aes_256_cbc_sha384_tls = {
+    SHA384_DIGEST_LENGTH + 32,  // key len (SHA384 + AES256)
+    16,                         // nonce len (IV)
+    16 + SHA384_DIGEST_LENGTH,  // overhead (padding + SHA384)
+    SHA384_DIGEST_LENGTH,       // max tag length
+    0,                          // seal_scatter_supports_extra_in
+
+    NULL,  // init
+    aead_aes_256_cbc_sha384_tls_init,
+    aead_tls_cleanup,
+    aead_tls_open,
+    aead_tls_seal_scatter,
+    NULL,  // open_gather
+    NULL,  // get_iv
+    aead_tls_tag_len,
+};
+
 static const EVP_AEAD aead_des_ede3_cbc_sha1_tls = {
     SHA_DIGEST_LENGTH + 24,  // key len (SHA1 + 3DES)
     8,                       // nonce len (IV)
@@ -590,6 +640,14 @@ const EVP_AEAD *EVP_aead_aes_256_cbc_sha1_tls_implicit_iv(void) {
   return &aead_aes_256_cbc_sha1_tls_implicit_iv;
 }
 
+const EVP_AEAD *EVP_aead_aes_256_cbc_sha256_tls(void) {
+  return &aead_aes_256_cbc_sha256_tls;
+}
+
+const EVP_AEAD *EVP_aead_aes_256_cbc_sha384_tls(void) {
+  return &aead_aes_256_cbc_sha384_tls;
+}
+
 const EVP_AEAD *EVP_aead_des_ede3_cbc_sha1_tls(void) {
   return &aead_des_ede3_cbc_sha1_tls;
 }
diff --git a/crypto/fipsmodule/ec/p256_test.cc b/crypto/fipsmodule/ec/p256_test.cc
index 88dc81e22..20a932829 100644
--- a/crypto/fipsmodule/ec/p256_test.cc
+++ b/crypto/fipsmodule/ec/p256_test.cc
@@ -17,7 +17,7 @@
 #include "../../test/abi_test.h"
 
 #if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__) && \
-    defined(SUPPORTS_ABI_TEST)
+    defined(SUPPORTS_ABI_TEST) && !defined(OPENSSL_WINDOWS)
 extern "C" {
 #include "../../../third_party/fiat/p256_64.h"
 }
diff --git a/crypto/rand/windows.cc b/crypto/rand/windows.cc
index 884d7891e..92cd3a025 100644
--- a/crypto/rand/windows.cc
+++ b/crypto/rand/windows.cc
@@ -62,6 +62,9 @@ void CRYPTO_sysrand(uint8_t *out, size_t requested) {
 typedef BOOL (WINAPI *ProcessPrngFunction)(PBYTE pbData, SIZE_T cbData);
 static ProcessPrngFunction g_processprng_fn = NULL;
 
+typedef BOOL(WINAPI *RtlGenRandomFunction)(PVOID RandomBuffer, ULONG RandomBufferLength);
+static RtlGenRandomFunction g_rtlgenrandom_fn = NULL;
+
 static void init_processprng(void) {
   HMODULE hmod = LoadLibraryW(L"bcryptprimitives");
   if (hmod == NULL) {
@@ -69,7 +72,14 @@ static void init_processprng(void) {
   }
   g_processprng_fn = (ProcessPrngFunction)GetProcAddress(hmod, "ProcessPrng");
   if (g_processprng_fn == NULL) {
-    abort();
+    hmod = LoadLibraryW(L"advapi32");
+    if (hmod == NULL) {
+      abort();
+    }
+    g_rtlgenrandom_fn = (RtlGenRandomFunction)GetProcAddress(hmod, "SystemFunction036");
+    if (g_rtlgenrandom_fn == NULL) {
+      abort();
+    }
   }
 }
 
@@ -83,8 +93,22 @@ void CRYPTO_sysrand(uint8_t *out, size_t requested) {
   // On non-UWP configurations, use ProcessPrng instead of BCryptGenRandom
   // to avoid accessing resources that may be unavailable inside the
   // Chromium sandbox. See https://crbug.com/74242
-  if (!g_processprng_fn(out, requested)) {
-    abort();
+  if (g_processprng_fn != NULL) {
+    if (!g_processprng_fn(out, requested)) {
+      abort();
+    }
+  } else {
+    while (requested > 0) {
+      ULONG output_bytes_this_pass = ULONG_MAX;
+      if (requested < output_bytes_this_pass) {
+        output_bytes_this_pass = (ULONG)requested;
+      }
+      if (g_rtlgenrandom_fn(out, output_bytes_this_pass) == FALSE) {
+        abort();
+      }
+      requested -= output_bytes_this_pass;
+      out += output_bytes_this_pass;
+    }
   }
 }
 
diff --git a/export.sh b/export.sh
new file mode 100755
index 000000000..892803529
--- /dev/null
+++ b/export.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+# From here: https://chromium.googlesource.com/chromium/src.git/+/refs/tags/135.0.7049.41/DEPS
+
+BASE_COMMIT=673e61fc215b178a90c0e67858bbf162c8158993
+
+git diff $BASE_COMMIT > boringssl.patch
+mv boringssl.patch ../curl-impersonate/patches/boringssl.patch
diff --git a/include/openssl/aead.h b/include/openssl/aead.h
index 570dec6d2..3fc298590 100644
--- a/include/openssl/aead.h
+++ b/include/openssl/aead.h
@@ -404,6 +404,8 @@ OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_128_cbc_sha256_tls(void);
 
 OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_256_cbc_sha1_tls(void);
 OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_256_cbc_sha1_tls_implicit_iv(void);
+OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_256_cbc_sha256_tls(void);
+OPENSSL_EXPORT const EVP_AEAD *EVP_aead_aes_256_cbc_sha384_tls(void);
 
 OPENSSL_EXPORT const EVP_AEAD *EVP_aead_des_ede3_cbc_sha1_tls(void);
 OPENSSL_EXPORT const EVP_AEAD *EVP_aead_des_ede3_cbc_sha1_tls_implicit_iv(void);
diff --git a/include/openssl/nid.h b/include/openssl/nid.h
index bf5536dc4..990a20a80 100644
--- a/include/openssl/nid.h
+++ b/include/openssl/nid.h
@@ -4216,6 +4216,11 @@ extern "C" {
 #define SN_X25519MLKEM768 "X25519MLKEM768"
 #define NID_X25519MLKEM768 965
 
+#define SN_ffdhe2048 "ffdhe2048"
+#define NID_ffdhe2048 966
+
+#define SN_ffdhe3072 "ffdhe3072"
+#define NID_ffdhe3072 967
 
 #if defined(__cplusplus)
 } /* extern C */
diff --git a/include/openssl/ssl.h b/include/openssl/ssl.h
index 7c6804d65..a1fd43fcc 100644
--- a/include/openssl/ssl.h
+++ b/include/openssl/ssl.h
@@ -1653,6 +1653,12 @@ OPENSSL_EXPORT size_t SSL_get_all_standard_cipher_names(const char **out,
 OPENSSL_EXPORT int SSL_CTX_set_strict_cipher_list(SSL_CTX *ctx,
                                                   const char *str);
 
+// curl-impersonate: set the extension order by given string
+OPENSSL_EXPORT int SSL_CTX_set_extension_order(SSL_CTX *ctx, char *order);
+
+// curl-impersonate
+OPENSSL_EXPORT int SSL_CTX_set_key_usage_check_enabled(SSL_CTX *ctx, int enabled);
+
 // SSL_CTX_set_cipher_list configures the cipher list for |ctx|, evaluating
 // |str| as a cipher string. It returns one on success and zero on failure.
 //
@@ -2468,6 +2474,8 @@ OPENSSL_EXPORT size_t SSL_CTX_get_num_tickets(const SSL_CTX *ctx);
 #define SSL_GROUP_X25519 29
 #define SSL_GROUP_X25519_MLKEM768 0x11ec
 #define SSL_GROUP_X25519_KYBER768_DRAFT00 0x6399
+#define SSL_GROUP_FFDHE2048 0x0100
+#define SSL_GROUP_FFDHE3072 0x0101
 
 // SSL_CTX_set1_group_ids sets the preferred groups for |ctx| to |group_ids|.
 // Each element of |group_ids| should be one of the |SSL_GROUP_*| constants. It
@@ -4898,6 +4906,12 @@ OPENSSL_EXPORT void SSL_CTX_set_permute_extensions(SSL_CTX *ctx, int enabled);
 // permute extensions. For now, this is only implemented for the ClientHello.
 OPENSSL_EXPORT void SSL_set_permute_extensions(SSL *ssl, int enabled);
 
+// curl-impersonate
+OPENSSL_EXPORT int SSL_CTX_set_extension_order(SSL_CTX *ctx, char *order);
+
+// curl-impersonate
+OPENSSL_EXPORT int SSL_CTX_set_key_usage_check_enabled(SSL_CTX *ctx, int enabled);
+
 // SSL_max_seal_overhead returns the maximum overhead, in bytes, of sealing a
 // record with |ssl|.
 OPENSSL_EXPORT size_t SSL_max_seal_overhead(const SSL *ssl);
@@ -5215,6 +5229,33 @@ OPENSSL_EXPORT int SSL_CTX_set1_sigalgs_list(SSL_CTX *ctx, const char *str);
 // more convenient to codesearch for specific algorithm values.
 OPENSSL_EXPORT int SSL_set1_sigalgs_list(SSL *ssl, const char *str);
 
+// curl-impersoante:
+// SSL_CTX_set_delegated_credentials sets the set of signature algorithms supported
+// by the client.
+OPENSSL_EXPORT int SSL_CTX_set_delegated_credentials(SSL_CTX *ctx, const char *str);
+
+// curl-impersoante:
+// SSL_set_record_size_limit configures whether sockets on |ssl| should
+// send record size limit extension.
+OPENSSL_EXPORT void SSL_set_record_size_limit(SSL *ssl, uint16_t limit);
+
+// curl-impersoante:
+// SSL_CTX_set_record_size_limit configures whether sockets on |ctx| should
+// send record size limit extension.
+OPENSSL_EXPORT void SSL_CTX_set_record_size_limit(SSL_CTX *ctx, uint16_t limit);
+
+// curl-imperonsate:
+// SSL_set_key_shares_limit configures whether sockets on |ssl| should
+// send three key shares.
+OPENSSL_EXPORT void SSL_set_key_shares_limit(SSL *ssl, uint8_t limit);
+
+// curl-impersonate:
+// SSL_CTX_set_key_shares_limit configures whether sockets on |ctx| should
+// send three key shares.
+OPENSSL_EXPORT void SSL_CTX_set_key_shares_limit(SSL_CTX *ctx, uint8_t limit);
+
+
+
 #define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)(arg)))
 #define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))
 #define SSL_SESSION_set_app_data(s, a) \
@@ -5593,6 +5634,8 @@ OPENSSL_EXPORT int SSL_CTX_set_tlsext_status_arg(SSL_CTX *ctx, void *arg);
 #define SSL_CURVE_SECP384R1 SSL_GROUP_SECP384R1
 #define SSL_CURVE_SECP521R1 SSL_GROUP_SECP521R1
 #define SSL_CURVE_X25519 SSL_GROUP_X25519
+#define SSL_CURVE_FFDHE2048 SSL_GROUP_FFDHE2048
+#define SSL_CURVE_FFDHE3072 SSL_GROUP_FFDHE3072
 #define SSL_CURVE_X25519_KYBER768_DRAFT00 SSL_GROUP_X25519_KYBER768_DRAFT00
 
 // SSL_get_curve_id calls |SSL_get_group_id|.
diff --git a/include/openssl/tls1.h b/include/openssl/tls1.h
index 7705e9c0e..386a616ba 100644
--- a/include/openssl/tls1.h
+++ b/include/openssl/tls1.h
@@ -48,6 +48,9 @@ extern "C" {
 #define TLS1_AD_NO_APPLICATION_PROTOCOL 120
 #define TLS1_AD_ECH_REQUIRED 121  // draft-ietf-tls-esni-13
 
+// curl-impersonate
+#define TLSEXT_TYPE_record_size_limit 28
+
 // ExtensionType values from RFC 6066
 #define TLSEXT_TYPE_server_name 0
 #define TLSEXT_TYPE_status_request 5
@@ -158,6 +161,7 @@ extern "C" {
 // From https://www.rfc-editor.org/rfc/rfc8879.html#section-3
 #define TLSEXT_cert_compression_zlib 1
 #define TLSEXT_cert_compression_brotli 2
+#define TLSEXT_cert_compression_zstd 3
 
 #define TLSEXT_MAXLEN_host_name 255
 
diff --git a/ssl/extensions.cc b/ssl/extensions.cc
index 4bd5c5d69..1adae1322 100644
--- a/ssl/extensions.cc
+++ b/ssl/extensions.cc
@@ -2123,7 +2123,15 @@ bool ssl_setup_key_shares(SSL_HANDSHAKE *hs, uint16_t override_group_id) {
   SSL *const ssl = hs->ssl;
   hs->key_shares[0].reset();
   hs->key_shares[1].reset();
+  hs->key_shares[2].reset();
   hs->key_share_bytes.Reset();
+  // If key_shares_limit is set, use it. Otherwise, use the default of 2.
+  const uint8_t key_shares_limit = hs->ssl->config->key_shares_limit;
+  // The key_shares_limit is set by the user, so it is a custom value.
+  const bool is_custom = key_shares_limit != 0;
+  const uint8_t limit = (key_shares_limit >= 1 && key_shares_limit <= 3) ? key_shares_limit : 2;
+  const bool enable_second_key_share = (limit >= 2);
+  const bool enable_three_key_shares = (limit >= 3);
 
   // If offering a PAKE, do not set up key shares. We do not currently support
   // clients offering both PAKE and non-PAKE modes, including resumption.
@@ -2147,6 +2155,7 @@ bool ssl_setup_key_shares(SSL_HANDSHAKE *hs, uint16_t override_group_id) {
 
   uint16_t group_id = override_group_id;
   uint16_t second_group_id = 0;
+  uint16_t third_group_id = 0;
   if (override_group_id == 0) {
     // Predict the most preferred group.
     Span<const uint16_t> groups = tls1_get_grouplist(hs);
@@ -2156,13 +2165,14 @@ bool ssl_setup_key_shares(SSL_HANDSHAKE *hs, uint16_t override_group_id) {
     }
 
     group_id = groups[0];
-
-    // We'll try to include one post-quantum and one classical initial key
-    // share.
-    for (size_t i = 1; i < groups.size() && second_group_id == 0; i++) {
-      if (is_post_quantum_group(group_id) != is_post_quantum_group(groups[i])) {
+    // Include one post-quantum and one classical initial key share.
+    for (size_t i = 1; i < groups.size(); i++) {
+      if (enable_second_key_share && second_group_id == 0 && (is_custom || (is_post_quantum_group(group_id) != is_post_quantum_group(groups[i])))) {
         second_group_id = groups[i];
         assert(second_group_id != group_id);
+      } else if (enable_three_key_shares && third_group_id == 0 && 
+          (is_custom || is_post_quantum_group(group_id) != is_post_quantum_group(groups[i]))) {
+        third_group_id = groups[i];
       }
     }
   }
@@ -2186,6 +2196,16 @@ bool ssl_setup_key_shares(SSL_HANDSHAKE *hs, uint16_t override_group_id) {
     }
   }
 
+  if (third_group_id != 0) {
+    hs->key_shares[2] = SSLKeyShare::Create(third_group_id);
+    if (!hs->key_shares[2] ||  //
+        !CBB_add_u16(cbb.get(), third_group_id) ||
+        !CBB_add_u16_length_prefixed(cbb.get(), &key_exchange) ||
+        !hs->key_shares[2]->Generate(&key_exchange)) {
+      return false;
+    }
+  }
+
   return CBBFinishArray(cbb.get(), &hs->key_share_bytes);
 }
 
@@ -2234,13 +2254,21 @@ bool ssl_ext_key_share_parse_serverhello(SSL_HANDSHAKE *hs,
   }
 
   SSLKeyShare *key_share = hs->key_shares[0].get();
+  // group_id is the server chosen group_id, and if key_share[0] is not chosen
   if (key_share->GroupID() != group_id) {
+    // the server also did not choose the second one
     if (!hs->key_shares[1] || hs->key_shares[1]->GroupID() != group_id) {
-      *out_alert = SSL_AD_ILLEGAL_PARAMETER;
-      OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);
-      return false;
+      // the server also did not choose the third one, we are out of options
+      if (!hs->key_shares[2] || hs->key_shares[2]->GroupID() != group_id) {
+        *out_alert = SSL_AD_ILLEGAL_PARAMETER;
+        OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);
+        return false;
+      } else {
+        key_share = hs->key_shares[2].get();
+      }
+    } else {
+      key_share = hs->key_shares[1].get();
     }
-    key_share = hs->key_shares[1].get();
   }
 
   if (!key_share->Decap(out_secret, out_alert, ciphertext)) {
@@ -2248,9 +2276,11 @@ bool ssl_ext_key_share_parse_serverhello(SSL_HANDSHAKE *hs,
     return false;
   }
 
+  // choose the first one
   hs->new_session->group_id = group_id;
   hs->key_shares[0].reset();
   hs->key_shares[1].reset();
+  hs->key_shares[2].reset();
   return true;
 }
 
@@ -2736,6 +2766,27 @@ static bool ext_quic_transport_params_add_serverhello_legacy(SSL_HANDSHAKE *hs,
 static bool ext_delegated_credential_add_clienthello(
     const SSL_HANDSHAKE *hs, CBB *out, CBB *out_compressible,
     ssl_client_hello_type_t type) {
+  // curl-impersonate
+  if (hs->config->delegated_credentials.empty()) {
+    return true;
+  }
+
+  CBB contents, data;
+  const Array<uint16_t>& signature_hash_algorithms = hs->config->delegated_credentials;
+  if (!CBB_add_u16(out, TLSEXT_TYPE_delegated_credential) ||
+    !CBB_add_u16_length_prefixed(out, &contents) ||
+    !CBB_add_u16_length_prefixed(&contents, &data)) {
+    return false;
+  }
+
+  for (const uint16_t alg : signature_hash_algorithms) {
+    if (!CBB_add_u16(&data, alg)) {
+      return false;
+    }
+  }
+  if (!CBB_flush(out)) {
+    return false;
+  }
   return true;
 }
 
@@ -3293,6 +3344,40 @@ bool ssl_negotiate_alps(SSL_HANDSHAKE *hs, uint8_t *out_alert,
   return true;
 }
 
+// curl-impersonate
+static bool record_size_limit_add_clienthello(const SSL_HANDSHAKE* hs, CBB* out,
+                                              CBB* out_compressible,
+                                              ssl_client_hello_type_t type) {
+  if (hs->config->record_size_limit == 0) {
+    return true;
+  }
+
+  CBB data;
+  const uint16_t data_ = hs->config->record_size_limit;
+  if (!CBB_add_u16(out, TLSEXT_TYPE_record_size_limit) ||
+    !CBB_add_u16_length_prefixed(out, &data) || !CBB_add_u16(&data, data_) ||
+    !CBB_flush(out)) {
+    return false;
+  }
+  return true;
+}
+
+static bool record_size_limit_parse_serverhello(SSL_HANDSHAKE* hs,
+                                                uint8_t* out_alert,
+                                                CBS* contents) {
+  return true;
+}
+
+static bool record_size_limit_parse_clienthello(SSL_HANDSHAKE* hs,
+                                                uint8_t* out_alert,
+                                                CBS* contents) {
+  return true;
+}
+
+static bool record_size_limit_add_serverhello(SSL_HANDSHAKE* hs, CBB* out) {
+  return true;
+}
+
 // kExtensions contains all the supported extensions.
 static const struct tls_extension kExtensions[] = {
     {
@@ -3466,6 +3551,13 @@ static const struct tls_extension kExtensions[] = {
         ignore_parse_clienthello,
         ext_alps_add_serverhello,
     },
+    {
+        TLSEXT_TYPE_record_size_limit,
+        record_size_limit_add_clienthello,
+        record_size_limit_parse_serverhello,
+        record_size_limit_parse_clienthello,
+        record_size_limit_add_serverhello,
+    },
     {
         TLSEXT_TYPE_application_settings_old,
         ext_alps_add_clienthello_old,
@@ -3514,6 +3606,7 @@ bool ssl_setup_extension_permutation(SSL_HANDSHAKE *hs) {
       !permutation.InitForOverwrite(kNumExtensions)) {
     return false;
   }
+  // By default, nothing is permuted.
   for (size_t i = 0; i < kNumExtensions; i++) {
     permutation[i] = i;
   }
@@ -3538,6 +3631,43 @@ static const struct tls_extension *tls_extension_find(uint32_t *out_index,
   return NULL;
 }
 
+// curl-impersonate: set customized extension order
+//
+// Generate the extension_permutation array from a customized extension order string.
+//
+// The customized extension order string is a dash-separated list of extensions.
+//
+bool ssl_set_extension_order(SSL_HANDSHAKE *hs) {
+  if (hs->config->extension_order == nullptr) {
+    return true;
+  }
+  // fprintf(stderr, "order %s\n", hs->config->extension_order);
+  Array<uint8_t> order;
+  if (!order.Init(kNumExtensions)) {
+    return false;
+  }
+  // By default, nothing is reordered.
+  for (size_t i = 0; i < kNumExtensions; i++) {
+    order[i] = 255;
+  }
+  // split the order string, and put there order in the table
+  const char *delimiter = "-";
+  char *tmp = strdup(hs->config->extension_order);
+  char *ext = strtok(tmp, delimiter);
+  size_t idx = 0;
+  while (ext != nullptr) {
+    unsigned ext_index = 0;
+    tls_extension_find(&ext_index, atoi(ext));
+    order[idx] = ext_index;
+    ext = strtok(NULL, delimiter);
+    idx++;
+  }
+  free(tmp);
+
+  hs->extension_permutation = std::move(order);
+  return true;
+}
+
 static bool add_padding_extension(CBB *cbb, uint16_t ext, size_t len) {
   CBB child;
   if (!CBB_add_u16(cbb, ext) ||  //
@@ -3584,6 +3714,7 @@ static bool ssl_add_clienthello_tlsext_inner(SSL_HANDSHAKE *hs, CBB *out,
     size_t i = hs->extension_permutation.empty()
                    ? unpermuted
                    : hs->extension_permutation[unpermuted];
+    if (i == 255) { continue; } // curl-impersonate: skip non-exist extensions
     const size_t len_before = CBB_len(&extensions);
     const size_t len_compressed_before = CBB_len(compressed.get());
     if (!kExtensions[i].add_clienthello(hs, &extensions, compressed.get(),
@@ -3693,6 +3824,7 @@ bool ssl_add_clienthello_tlsext(SSL_HANDSHAKE *hs, CBB *out, CBB *out_encoded,
     size_t i = hs->extension_permutation.empty()
                    ? unpermuted
                    : hs->extension_permutation[unpermuted];
+    if (i == 255) { continue; } // curl-impersonate: skip non-exist extensions
     const size_t len_before = CBB_len(&extensions);
     if (!kExtensions[i].add_clienthello(hs, &extensions, &extensions, type)) {
       OPENSSL_PUT_ERROR(SSL, SSL_R_ERROR_ADDING_EXTENSION);
diff --git a/ssl/handshake_client.cc b/ssl/handshake_client.cc
index 4ce8d1802..94fa868d8 100644
--- a/ssl/handshake_client.cc
+++ b/ssl/handshake_client.cc
@@ -26,6 +26,8 @@
 #include <openssl/aead.h>
 #include <openssl/bn.h>
 #include <openssl/bytestring.h>
+#include <openssl/dh.h>
+#include <../crypto/fipsmodule/dh/internal.h>
 #include <openssl/ec_key.h>
 #include <openssl/ecdsa.h>
 #include <openssl/err.h>
@@ -125,15 +127,43 @@ static bool ssl_write_client_cipher_list(const SSL_HANDSHAKE *hs, CBB *out,
         TLS1_3_CK_AES_128_GCM_SHA256 & 0xffff,
         TLS1_3_CK_CHACHA20_POLY1305_SHA256 & 0xffff,
     };
+    static const uint16_t kCiphersFirefox[] = {
+        TLS1_3_CK_AES_128_GCM_SHA256 & 0xffff,
+        TLS1_3_CK_CHACHA20_POLY1305_SHA256 & 0xffff,
+        TLS1_3_CK_AES_256_GCM_SHA384 & 0xffff,
+    };
+    static const uint16_t kCiphersSafari26[] = {
+        TLS1_3_CK_AES_256_GCM_SHA384 & 0xffff,
+        TLS1_3_CK_CHACHA20_POLY1305_SHA256 & 0xffff,
+        TLS1_3_CK_AES_128_GCM_SHA256 & 0xffff,
+    };
+    static const uint16_t kCiphersOther[] = {
+        TLS1_3_CK_CHACHA20_POLY1305_SHA256 & 0xffff,
+        TLS1_3_CK_AES_256_GCM_SHA384 & 0xffff,
+        TLS1_3_CK_AES_128_GCM_SHA256 & 0xffff,
+    };
+
+#define TLS13_CIPHER_LEN 74
+
+    const char *order = hs->config->cipher_order;
+    // printf("CIPHER ORDER IS %s\n", order);
 
-    const bool has_aes_hw = ssl->config->aes_hw_override
-                                ? ssl->config->aes_hw_override_value
-                                : EVP_has_aes_hardware();
     const bssl::Span<const uint16_t> ciphers =
-        ssl->config->compliance_policy == ssl_compliance_policy_cnsa_202407
-            ? bssl::Span<const uint16_t>(kCiphersCNSA)
-            : (has_aes_hw ? bssl::Span<const uint16_t>(kCiphersAESHardware)
-                          : bssl::Span<const uint16_t>(kCiphersNoAESHardware));
+      order == nullptr ?
+        kCiphersAESHardware :
+        strncmp(order, "TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256", TLS13_CIPHER_LEN) == 0 ?
+          kCiphersAESHardware :
+        strncmp(order, "TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384", TLS13_CIPHER_LEN) == 0 ?
+          kCiphersFirefox :
+        strncmp(order, "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256", TLS13_CIPHER_LEN) == 0 ?
+          kCiphersSafari26 :
+        strncmp(order, "TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256", TLS13_CIPHER_LEN) == 0 ?
+          kCiphersCNSA :
+        strncmp(order, "TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384", TLS13_CIPHER_LEN) == 0 ?
+          kCiphersNoAESHardware :
+        strncmp(order, "TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256", TLS13_CIPHER_LEN) == 0 ?
+          kCiphersOther :
+          kCiphersAESHardware;  // default one
 
     for (auto cipher : ciphers) {
       if (!ssl_add_tls13_cipher(&child, cipher,
@@ -431,8 +461,10 @@ static enum ssl_hs_wait_t do_start_connect(SSL_HANDSHAKE *hs) {
     hs->early_data_offered = true;
   }
 
+  // curl-impersonate: set extension orders
   if (!ssl_setup_key_shares(hs, /*override_group_id=*/0) ||
       !ssl_setup_extension_permutation(hs) ||
+      !ssl_set_extension_order(hs) ||
       !ssl_encrypt_client_hello(hs, Span(ech_enc, ech_enc_len)) ||
       !ssl_add_client_hello(hs)) {
     return ssl_hs_error;
@@ -1026,7 +1058,28 @@ static enum ssl_hs_wait_t do_read_server_key_exchange(SSL_HANDSHAKE *hs) {
     hs->peer_psk_identity_hint.reset(raw);
   }
 
-  if (alg_k & SSL_kECDHE) {
+  if (alg_k & SSL_kDHE) {
+    CBS dh_p, dh_g, dh_Ys;
+    if (!CBS_get_u16_length_prefixed(&server_key_exchange, &dh_p) ||
+        CBS_len(&dh_p) == 0 ||
+        !CBS_get_u16_length_prefixed(&server_key_exchange, &dh_g) ||
+        CBS_len(&dh_g) == 0 ||
+        !CBS_get_u16_length_prefixed(&server_key_exchange, &dh_Ys) ||
+        CBS_len(&dh_Ys) == 0) {
+      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);
+      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);
+      return ssl_hs_error;
+    }
+
+    if (!hs->dh_p.CopyFrom(dh_p) || !hs->dh_g.CopyFrom(dh_g)) {
+      return ssl_hs_error;
+    }
+
+    /* Save the peer public key for later. */
+    if (!hs->peer_key.CopyFrom(dh_Ys)) {
+      return ssl_hs_error;
+    }
+  } else if (alg_k & SSL_kECDHE) {
     // Parse the server parameters.
     uint8_t group_type;
     uint16_t group_id;
@@ -1366,7 +1419,9 @@ static enum ssl_hs_wait_t do_send_client_key_exchange(SSL_HANDSHAKE *hs) {
     ssl_key_usage_t intended_use = (alg_k & SSL_kRSA)
                                        ? key_usage_encipherment
                                        : key_usage_digital_signature;
-    if (!ssl_cert_check_key_usage(&leaf_cbs, intended_use)) {
+    // curl-impersonate: optionally disable ssl key usage check
+    if (hs->config->key_usage_check_enabled &&
+        !ssl_cert_check_key_usage(&leaf_cbs, intended_use)) {
       if (hs->config->enforce_rsa_key_usage ||
           EVP_PKEY_id(hs->peer_pubkey.get()) != EVP_PKEY_RSA) {
         return ssl_hs_error;
@@ -1440,6 +1495,64 @@ static enum ssl_hs_wait_t do_send_client_key_exchange(SSL_HANDSHAKE *hs) {
         !CBB_flush(&body)) {
       return ssl_hs_error;
     }
+  } else if (alg_k & SSL_kDHE) {
+    DH *dh = DH_new();
+    if (dh == nullptr) {
+      return ssl_hs_error;
+    }
+
+    dh->p = BN_bin2bn(hs->dh_p.data(), hs->dh_p.size(), nullptr);
+    dh->g = BN_bin2bn(hs->dh_g.data(), hs->dh_g.size(), nullptr);
+    if (dh->p == nullptr || dh->g == nullptr) {
+      DH_free(dh);
+      return ssl_hs_error;
+    }
+
+    unsigned bits = DH_num_bits(dh);
+    if (bits < 1024) {
+      OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_DH_P_LENGTH);
+      DH_free(dh);
+      return ssl_hs_error;
+    } else if (bits > 4096) {
+      /* Overly large DHE groups are prohibitively expensive, so enforce a limit
+       * to prevent a server from causing us to perform too expensive of a
+       * computation. */
+      OPENSSL_PUT_ERROR(SSL, SSL_R_DH_P_TOO_LONG);
+      DH_free(dh);
+      return ssl_hs_error;
+    }
+
+    CBB child;
+    if (!CBB_add_u16_length_prefixed(&body, &child)) {
+      DH_free(dh);
+      return ssl_hs_error;
+    }
+
+    if (!DH_generate_key(dh) || 
+        !BN_bn2cbb_padded(&child, BN_num_bytes(dh->p), dh->pub_key)) {
+      DH_free(dh);
+      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
+      return ssl_hs_error;
+    }
+
+    int secret_len = 0;
+    BIGNUM *peer_point = BN_bin2bn(hs->peer_key.data(), hs->peer_key.size(), nullptr);
+    if (peer_point == nullptr || 
+        !pms.InitForOverwrite(DH_size(dh)) || 
+        (secret_len = DH_compute_key(pms.data(), peer_point, dh)) <= 0) {
+      BN_free(peer_point);
+      DH_free(dh);
+      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
+      return ssl_hs_error;
+    }
+
+    pms.Shrink(secret_len);
+    BN_free(peer_point);
+    DH_free(dh);
+
+    hs->dh_p.Reset();
+    hs->dh_g.Reset();
+    hs->peer_key.Reset();
   } else if (alg_k & SSL_kECDHE) {
     CBB child;
     if (!CBB_add_u8_length_prefixed(&body, &child)) {
diff --git a/ssl/internal.h b/ssl/internal.h
index 05af44f7b..138d6a5e4 100644
--- a/ssl/internal.h
+++ b/ssl/internal.h
@@ -697,10 +697,11 @@ BSSL_NAMESPACE_BEGIN
 
 // Bits for |algorithm_mkey| (key exchange algorithm).
 #define SSL_kRSA 0x00000001u
-#define SSL_kECDHE 0x00000002u
+#define SSL_kDHE 0x00000002u
+#define SSL_kECDHE 0x00000004u
 // SSL_kPSK is only set for plain PSK, not ECDHE_PSK.
-#define SSL_kPSK 0x00000004u
-#define SSL_kGENERIC 0x00000008u
+#define SSL_kPSK 0x00000008u
+#define SSL_kGENERIC 0x00000010u
 
 // Bits for |algorithm_auth| (server authentication).
 #define SSL_aRSA_SIGN 0x00000001u
@@ -725,8 +726,9 @@ BSSL_NAMESPACE_BEGIN
 // Bits for |algorithm_mac| (symmetric authentication).
 #define SSL_SHA1 0x00000001u
 #define SSL_SHA256 0x00000002u
+#define SSL_SHA384 0x00000004u
 // SSL_AEAD is set for all AEADs.
-#define SSL_AEAD 0x00000004u
+#define SSL_AEAD 0x00000008u
 
 // Bits for |algorithm_prf| (handshake digest).
 #define SSL_HANDSHAKE_MAC_DEFAULT 0x1
@@ -2177,7 +2179,7 @@ struct SSL_HANDSHAKE {
   // key_shares are the current key exchange instances. The second is only used
   // as a client if we believe that we should offer two key shares in a
   // ClientHello.
-  UniquePtr<SSLKeyShare> key_shares[2];
+  UniquePtr<SSLKeyShare> key_shares[3];
 
   // transcript is the current handshake transcript.
   SSLTranscript transcript;
@@ -2235,6 +2237,9 @@ struct SSL_HANDSHAKE {
   // delegated credentials.
   Array<uint16_t> peer_delegated_credential_sigalgs;
 
+  Array<uint8_t> dh_p;
+  Array<uint8_t> dh_g;
+
   // peer_key is the peer's ECDH key for a TLS 1.2 client.
   Array<uint8_t> peer_key;
 
@@ -2515,6 +2520,12 @@ bssl::UniquePtr<SSL_SESSION> tls13_create_session_with_ticket(SSL *ssl,
 // for |hs|, if applicable. It returns true on success and false on error.
 bool ssl_setup_extension_permutation(SSL_HANDSHAKE *hs);
 
+// curl-impersonate
+bool ssl_set_extension_order(SSL_HANDSHAKE *hs);
+
+// curl-impersonate
+bool ssl_set_key_usage_check_enabled(SSL_HANDSHAKE *hs);
+
 // ssl_setup_key_shares computes client key shares and saves them in |hs|. It
 // returns true on success and false on failure. If |override_group_id| is zero,
 // it offers the default groups, including GREASE. If it is non-zero, it offers
@@ -3581,6 +3592,15 @@ struct SSL_CONFIG {
   // crypto
   UniquePtr<SSLCipherPreferenceList> cipher_list;
 
+  // curl-impersonate
+  char *extension_order = nullptr;
+
+  // curl-impersonate
+  const char *cipher_order = nullptr;
+
+  // curl-impersonate
+  int key_usage_check_enabled = 1;
+
   // This is used to hold the local certificate used (i.e. the server
   // certificate for a server or the client certificate for a client).
   UniquePtr<CERT> cert;
@@ -3639,6 +3659,10 @@ struct SSL_CONFIG {
   // accepted from the peer in decreasing order of preference.
   Array<uint16_t> verify_sigalgs;
 
+  // delegated_credentials, if not empty, is the set of signature algorithms
+  // supported by the client.
+  Array<uint16_t> delegated_credentials;
+
   // srtp_profiles is the list of configured SRTP protection profiles for
   // DTLS-SRTP.
   UniquePtr<STACK_OF(SRTP_PROTECTION_PROFILE)> srtp_profiles;
@@ -3704,6 +3728,14 @@ struct SSL_CONFIG {
   // hardware support, and use the value in aes_hw_override_value instead.
   bool aes_hw_override : 1;
 
+  // curl-impersonate: record_size_limit is whether to send record size limit
+  // extension.
+  uint16_t record_size_limit = 0;
+
+  // curl-impersonate: key_shares_limit is the maximum number of key shares to
+  // send.
+  uint8_t key_shares_limit = 0;
+
   // aes_hw_override_value is used for testing to indicate the support or lack
   // of support for AES hw. The value is only considered if |aes_hw_override| is
   // true.
@@ -4076,6 +4108,15 @@ struct ssl_ctx_st : public bssl::RefCounted<ssl_ctx_st> {
 
   bssl::UniquePtr<bssl::SSLCipherPreferenceList> cipher_list;
 
+  // curl-impersonate
+  char *extension_order = nullptr;
+
+  // curl-impersonate
+  const char *cipher_order = nullptr;
+
+  // curl-impersonate
+  int key_usage_check_enabled = 1;
+
   X509_STORE *cert_store = nullptr;
   LHASH_OF(SSL_SESSION) *sessions = nullptr;
   // Most session-ids that will be cached, default is
@@ -4300,6 +4341,10 @@ struct ssl_ctx_st : public bssl::RefCounted<ssl_ctx_st> {
   // accepted from the peer in decreasing order of preference.
   bssl::Array<uint16_t> verify_sigalgs;
 
+  // delegated_credentials, if not empty, is the set of signature algorithms
+  // supported by the client.
+  bssl::Array<uint16_t> delegated_credentials;
+
   // retain_only_sha256_of_client_certs is true if we should compute the SHA256
   // hash of the peer's certificate and then discard it to save memory and
   // session space. Only effective on the server side.
@@ -4352,6 +4397,14 @@ struct ssl_ctx_st : public bssl::RefCounted<ssl_ctx_st> {
   // |aes_hw_override| is true.
   bool aes_hw_override_value : 1;
 
+  // curl-impersonate: record_size_limit is whether to send record size limit
+  // extension.
+  uint16_t record_size_limit = 0;
+
+  // curl-impersonate: key_shares limit is the maximum number of key shares to
+  // send.
+  uint8_t key_shares_limit = 0;
+
  private:
   friend RefCounted;
   ~ssl_ctx_st();
diff --git a/ssl/ssl_cipher.cc b/ssl/ssl_cipher.cc
index 724a0f272..41dd140d1 100644
--- a/ssl/ssl_cipher.cc
+++ b/ssl/ssl_cipher.cc
@@ -61,6 +61,18 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_DEFAULT,
     },
 
+    // Cipher 33
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_128_SHA,
+        "TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
+        TLS1_CK_DHE_RSA_WITH_AES_128_SHA,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES128,
+        SSL_SHA1,
+        SSL_HANDSHAKE_MAC_DEFAULT,
+    },
+
     // Cipher 35
     {
         TLS1_TXT_RSA_WITH_AES_256_SHA,
@@ -73,6 +85,68 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_DEFAULT,
     },
 
+    // Cipher 39
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_256_SHA,
+        "TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
+        TLS1_CK_DHE_RSA_WITH_AES_256_SHA,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES256,
+        SSL_SHA1,
+        SSL_HANDSHAKE_MAC_DEFAULT,
+    },
+
+    // TLS v1.2 ciphersuites
+
+    // Cipher 3C
+    {
+        TLS1_TXT_RSA_WITH_AES_128_SHA256,
+        "TLS_RSA_WITH_AES_128_CBC_SHA256",
+        TLS1_CK_RSA_WITH_AES_128_SHA256,
+        SSL_kRSA,
+        SSL_aRSA_DECRYPT,
+        SSL_AES128,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+    // Cipher 3D
+    {
+        TLS1_TXT_RSA_WITH_AES_256_SHA256,
+        "TLS_RSA_WITH_AES_256_CBC_SHA256",
+        TLS1_CK_RSA_WITH_AES_256_SHA256,
+        SSL_kRSA,
+        SSL_aRSA_DECRYPT,
+        SSL_AES256,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+    // Cipher 67
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_128_SHA256,
+        "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
+        TLS1_CK_DHE_RSA_WITH_AES_128_SHA256,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES128,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+    // Cipher 6B
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_256_SHA256,
+        "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
+        TLS1_CK_DHE_RSA_WITH_AES_256_SHA256,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES256,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
     // PSK cipher suites.
 
     // Cipher 8C
@@ -125,6 +199,30 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_SHA384,
     },
 
+    // Cipher 9E
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256,
+        "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256",
+        TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES128GCM,
+        SSL_AEAD,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+    // Cipher 9F
+    {
+        TLS1_TXT_DHE_RSA_WITH_AES_256_GCM_SHA384,
+        "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384",
+        TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384,
+        SSL_kDHE,
+        SSL_aRSA_DECRYPT,
+        SSL_AES256GCM,
+        SSL_AEAD,
+        SSL_HANDSHAKE_MAC_SHA384,
+    },
+
     // TLS 1.3 suites.
 
     // Cipher 1301
@@ -163,6 +261,18 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_SHA256,
     },
 
+    // Cipher C008
+    {
+        TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA,
+        "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
+        TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA,
+        SSL_kECDHE,
+        SSL_aECDSA,
+        SSL_3DES,
+        SSL_SHA1,
+        SSL_HANDSHAKE_MAC_DEFAULT,
+    },
+
     // Cipher C009
     {
         TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
@@ -187,6 +297,18 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_DEFAULT,
     },
 
+    // Cipher C012
+    {
+        TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA,
+        "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
+        TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA,
+        SSL_kECDHE,
+        SSL_aRSA_SIGN,
+        SSL_3DES,
+        SSL_SHA1,
+        SSL_HANDSHAKE_MAC_DEFAULT,
+    },
+
     // Cipher C013
     {
         TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA,
@@ -211,6 +333,32 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_DEFAULT,
     },
 
+    // HMAC based TLS v1.2 ciphersuites from RFC5289
+
+    // Cipher C023
+    {
+        TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_SHA256,
+        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
+        TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256,
+        SSL_kECDHE,
+        SSL_aECDSA,
+        SSL_AES128,
+        SSL_SHA256,
+        SSL_HANDSHAKE_MAC_SHA256,
+    },
+
+    // Cipher C024
+    {
+        TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_SHA384,
+        "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
+        TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384,
+        SSL_kECDHE,
+        SSL_aECDSA,
+        SSL_AES256,
+        SSL_SHA384,
+        SSL_HANDSHAKE_MAC_SHA384,
+    },
+
     // Cipher C027
     {
         TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
@@ -223,6 +371,18 @@ static constexpr SSL_CIPHER kCiphers[] = {
         SSL_HANDSHAKE_MAC_SHA256,
     },
 
+    // Cipher C028
+    {
+        TLS1_TXT_ECDHE_RSA_WITH_AES_256_SHA384,
+        "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
+        TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384,
+        SSL_kECDHE,
+        SSL_aRSA_SIGN,
+        SSL_AES256,
+        SSL_SHA384,
+        SSL_HANDSHAKE_MAC_SHA384,
+    },
+
     // GCM based TLS v1.2 ciphersuites from RFC 5289
 
     // Cipher C02B
@@ -428,6 +588,8 @@ static const CIPHER_ALIAS kCipherAliases[] = {
     // MAC aliases
     {"SHA1", ~0u, ~0u, ~0u, SSL_SHA1, 0},
     {"SHA", ~0u, ~0u, ~0u, SSL_SHA1, 0},
+    {"SHA256", ~0u, ~0u, ~0u, SSL_SHA256, 0},
+    {"SHA384", ~0u, ~0u, ~0u, SSL_SHA384, 0},
 
     // Legacy protocol minimum version aliases. "TLSv1" is intentionally the
     // same as "SSLv3".
@@ -512,11 +674,20 @@ bool ssl_cipher_get_evp_aead(const EVP_AEAD **out_aead,
   } else if (cipher->algorithm_mac == SSL_SHA256) {
     if (cipher->algorithm_enc == SSL_AES128) {
       *out_aead = EVP_aead_aes_128_cbc_sha256_tls();
+    } else if (cipher->algorithm_enc == SSL_AES256) {
+      *out_aead = EVP_aead_aes_256_cbc_sha256_tls();
     } else {
       return false;
     }
 
     *out_mac_secret_len = SHA256_DIGEST_LENGTH;
+  } else if (cipher->algorithm_mac == SSL_SHA384) {
+    if (cipher->algorithm_enc != SSL_AES256) {
+      return false;
+    }
+
+    *out_aead = EVP_aead_aes_256_cbc_sha384_tls();
+    *out_mac_secret_len = SHA384_DIGEST_LENGTH;
   } else {
     return false;
   }
@@ -1020,13 +1191,20 @@ bool ssl_create_cipher_list(UniquePtr<SSLCipherPreferenceList> *out_cipher_list,
       TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 & 0xffff,
   };
   static const uint16_t kLegacyCiphers[] = {
+      TLS1_CK_RSA_WITH_AES_128_SHA256 & 0xffff,
+      TLS1_CK_RSA_WITH_AES_256_SHA256 & 0xffff,
+      TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA & 0xffff,
+      TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA & 0xffff,
       TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA & 0xffff,
       TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA & 0xffff,
       TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA & 0xffff,
       TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA & 0xffff,
       TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA & 0xffff,
       TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA & 0xffff,
+      TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256 & 0xffff,
+      TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384 & 0xffff,
       TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA256 & 0xffff,
+      TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384 & 0xffff,
       TLS1_CK_RSA_WITH_AES_128_GCM_SHA256 & 0xffff,
       TLS1_CK_RSA_WITH_AES_256_GCM_SHA384 & 0xffff,
       TLS1_CK_RSA_WITH_AES_128_SHA & 0xffff,
@@ -1034,12 +1212,19 @@ bool ssl_create_cipher_list(UniquePtr<SSLCipherPreferenceList> *out_cipher_list,
       TLS1_CK_RSA_WITH_AES_256_SHA & 0xffff,
       TLS1_CK_PSK_WITH_AES_256_CBC_SHA & 0xffff,
       SSL3_CK_RSA_DES_192_CBC3_SHA & 0xffff,
+      TLS1_CK_DHE_RSA_WITH_AES_128_SHA & 0xffff,
+      TLS1_CK_DHE_RSA_WITH_AES_256_SHA & 0xffff,
+      TLS1_CK_DHE_RSA_WITH_AES_128_SHA256 & 0xffff,
+      TLS1_CK_DHE_RSA_WITH_AES_256_SHA256 & 0xffff,
+      TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256 & 0xffff,
+      TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384 & 0xffff,
   };
 
   // Set up a linked list of ciphers.
   CIPHER_ORDER co_list[OPENSSL_ARRAY_SIZE(kAESCiphers) +
                        OPENSSL_ARRAY_SIZE(kChaChaCiphers) +
                        OPENSSL_ARRAY_SIZE(kLegacyCiphers)];
+
   for (size_t i = 0; i < OPENSSL_ARRAY_SIZE(co_list); i++) {
     co_list[i].next =
         i + 1 < OPENSSL_ARRAY_SIZE(co_list) ? &co_list[i + 1] : nullptr;
@@ -1265,6 +1450,8 @@ int SSL_CIPHER_get_digest_nid(const SSL_CIPHER *cipher) {
       return NID_sha1;
     case SSL_SHA256:
       return NID_sha256;
+    case SSL_SHA384:
+      return NID_sha384;
   }
   assert(0);
   return NID_undef;
@@ -1529,6 +1716,10 @@ const char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf,
       mac = "SHA256";
       break;
 
+    case SSL_SHA384:
+      mac = "SHA384";
+      break;
+
     case SSL_AEAD:
       mac = "AEAD";
       break;
diff --git a/ssl/ssl_key_share.cc b/ssl/ssl_key_share.cc
index e60016c82..476dc3915 100644
--- a/ssl/ssl_key_share.cc
+++ b/ssl/ssl_key_share.cc
@@ -384,6 +384,8 @@ constexpr NamedGroup kNamedGroups[] = {
     {NID_X25519Kyber768Draft00, SSL_GROUP_X25519_KYBER768_DRAFT00,
      "X25519Kyber768Draft00", ""},
     {NID_X25519MLKEM768, SSL_GROUP_X25519_MLKEM768, "X25519MLKEM768", ""},
+    {NID_ffdhe2048, SSL_CURVE_FFDHE2048, "dhe2048", "ffdhe2048"},
+    {NID_ffdhe3072, SSL_CURVE_FFDHE3072, "dhe3072", "ffdhe3072"},
 };
 
 }  // namespace
diff --git a/ssl/ssl_lib.cc b/ssl/ssl_lib.cc
index c859ea612..79c653219 100644
--- a/ssl/ssl_lib.cc
+++ b/ssl/ssl_lib.cc
@@ -401,7 +401,8 @@ ssl_ctx_st::ssl_ctx_st(const SSL_METHOD *ssl_method)
       handoff(false),
       enable_early_data(false),
       aes_hw_override(false),
-      aes_hw_override_value(false) {
+      aes_hw_override_value(false),
+      key_shares_limit(0) {
   CRYPTO_MUTEX_init(&lock);
   CRYPTO_new_ex_data(&ex_data);
 }
@@ -520,14 +521,19 @@ SSL *SSL_new(SSL_CTX *ctx) {
   ssl->config->retain_only_sha256_of_client_certs =
       ctx->retain_only_sha256_of_client_certs;
   ssl->config->permute_extensions = ctx->permute_extensions;
+  ssl->config->extension_order = ctx->extension_order;  // curl-impersonate
+  ssl->config->cipher_order = ctx->cipher_order;  // curl-impersonate
+  ssl->config->key_usage_check_enabled = ctx->key_usage_check_enabled;  // curl-impersonate
   ssl->config->aes_hw_override = ctx->aes_hw_override;
   ssl->config->aes_hw_override_value = ctx->aes_hw_override_value;
   ssl->config->compliance_policy = ctx->compliance_policy;
+  ssl->config->key_shares_limit = ctx->key_shares_limit;
 
   if (!ssl->config->supported_group_list.CopyFrom(ctx->supported_group_list) ||
       !ssl->config->alpn_client_proto_list.CopyFrom(
           ctx->alpn_client_proto_list) ||
-      !ssl->config->verify_sigalgs.CopyFrom(ctx->verify_sigalgs)) {
+      !ssl->config->verify_sigalgs.CopyFrom(ctx->verify_sigalgs) ||
+      !ssl->config->delegated_credentials.CopyFrom(ctx->delegated_credentials)) {
     return nullptr;
   }
 
@@ -547,6 +553,7 @@ SSL *SSL_new(SSL_CTX *ctx) {
   ssl->config->signed_cert_timestamps_enabled =
       ctx->signed_cert_timestamps_enabled;
   ssl->config->ocsp_stapling_enabled = ctx->ocsp_stapling_enabled;
+  ssl->config->record_size_limit = ctx->record_size_limit;
   ssl->config->handoff = ctx->handoff;
   ssl->quic_method = ctx->quic_method;
 
@@ -571,6 +578,7 @@ SSL_CONFIG::SSL_CONFIG(SSL *ssl_arg)
       jdk11_workaround(false),
       quic_use_legacy_codepoint(false),
       permute_extensions(false),
+      key_shares_limit(0),
       alps_use_new_codepoint(false) {
   assert(ssl);
 }
@@ -1975,6 +1983,7 @@ const char *SSL_get_cipher_list(const SSL *ssl, int n) {
 int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str) {
   const bool has_aes_hw = ctx->aes_hw_override ? ctx->aes_hw_override_value
                                                : EVP_has_aes_hardware();
+  ctx->cipher_order = str;
   return ssl_create_cipher_list(&ctx->cipher_list, has_aes_hw, str,
                                 false /* not strict */);
 }
@@ -2068,6 +2077,28 @@ void SSL_enable_ocsp_stapling(SSL *ssl) {
   ssl->config->ocsp_stapling_enabled = true;
 }
 
+void SSL_set_record_size_limit(SSL *ssl, uint16_t limit) {
+  if (!ssl->config) {
+    return;
+  }
+  ssl->config->record_size_limit = limit;
+}
+
+void SSL_CTX_set_record_size_limit(SSL_CTX *ctx, uint16_t limit) {
+  ctx->record_size_limit = limit;
+}
+
+void SSL_set_key_shares_limit(SSL *ssl, uint8_t limit) {
+  if (!ssl->config) {
+    return;
+  }
+  ssl->config->key_shares_limit = limit;
+}
+
+void SSL_CTX_set_key_shares_limit(SSL_CTX *ctx, uint8_t limit) {
+  ctx->key_shares_limit = limit;
+}
+
 void SSL_get0_signed_cert_timestamp_list(const SSL *ssl, const uint8_t **out,
                                          size_t *out_len) {
   SSL_SESSION *session = SSL_get_session(ssl);
@@ -2889,6 +2920,17 @@ void SSL_CTX_set_permute_extensions(SSL_CTX *ctx, int enabled) {
   ctx->permute_extensions = !!enabled;
 }
 
+// curl-impersonate: set extensions order
+int SSL_CTX_set_extension_order(SSL_CTX *ctx, char *order) {
+  ctx->extension_order = order;
+  return 0;
+}
+
+int SSL_CTX_set_key_usage_check_enabled(SSL_CTX *ctx, int enabled) {
+  ctx->key_usage_check_enabled = enabled;
+  return 0;
+}
+
 void SSL_set_permute_extensions(SSL *ssl, int enabled) {
   if (!ssl->config) {
     return;
diff --git a/ssl/ssl_privkey.cc b/ssl/ssl_privkey.cc
index 6d46f886b..0524eae8e 100644
--- a/ssl/ssl_privkey.cc
+++ b/ssl/ssl_privkey.cc
@@ -519,44 +519,12 @@ int SSL_is_signature_algorithm_rsa_pss(uint16_t sigalg) {
   return alg != nullptr && alg->is_rsa_pss;
 }
 
-static int compare_uint16_t(const void *p1, const void *p2) {
-  uint16_t u1 = *((const uint16_t *)p1);
-  uint16_t u2 = *((const uint16_t *)p2);
-  if (u1 < u2) {
-    return -1;
-  } else if (u1 > u2) {
-    return 1;
-  } else {
-    return 0;
-  }
-}
-
-static bool sigalgs_unique(Span<const uint16_t> in_sigalgs) {
-  if (in_sigalgs.size() < 2) {
-    return true;
-  }
-
-  Array<uint16_t> sigalgs;
-  if (!sigalgs.CopyFrom(in_sigalgs)) {
-    return false;
-  }
-
-  qsort(sigalgs.data(), sigalgs.size(), sizeof(uint16_t), compare_uint16_t);
-
-  for (size_t i = 1; i < sigalgs.size(); i++) {
-    if (sigalgs[i - 1] == sigalgs[i]) {
-      OPENSSL_PUT_ERROR(SSL, SSL_R_DUPLICATE_SIGNATURE_ALGORITHM);
-      return false;
-    }
-  }
-
-  return true;
-}
+// curl-impersonate: Remove the uniqueness check. Older Safari versions (15)
+// send out duplicated algorithm prefs.
 
 static bool set_sigalg_prefs(Array<uint16_t> *out, Span<const uint16_t> prefs) {
-  if (!sigalgs_unique(prefs)) {
-    return false;
-  }
+  // curl-impersonate: Remove the uniqueness check. Older Safari versions (15)
+  // send out duplicated algorithm prefs.
 
   // Check for invalid algorithms, and filter out |SSL_SIGN_RSA_PKCS1_MD5_SHA1|.
   Array<uint16_t> filtered;
@@ -916,3 +884,13 @@ int SSL_set_verify_algorithm_prefs(SSL *ssl, const uint16_t *prefs,
 
   return set_sigalg_prefs(&ssl->config->verify_sigalgs, Span(prefs, num_prefs));
 }
+
+int SSL_CTX_set_delegated_credentials(SSL_CTX *ctx, const char *str) {
+  Array<uint16_t> sigalgs;
+  if (!parse_sigalgs_list(&sigalgs, str)) {
+    return 0;
+  }
+
+  return set_sigalg_prefs(&ctx->delegated_credentials,
+                          MakeConstSpan(sigalgs.data(), sigalgs.size()));
+}
diff --git a/third_party/fiat/p256_64.h b/third_party/fiat/p256_64.h
index 48a156091..23721f9c7 100644
--- a/third_party/fiat/p256_64.h
+++ b/third_party/fiat/p256_64.h
@@ -1,7 +1,7 @@
 #include <openssl/base.h>
 #include "../../crypto/internal.h"
 
-#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
+#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__) && !defined(OPENSSL_WINDOWS)
 extern "C" {
 void fiat_p256_adx_mul(uint64_t*, const uint64_t*, const uint64_t*);
 void fiat_p256_adx_sqr(uint64_t*, const uint64_t*);
@@ -175,7 +175,7 @@ static FIAT_P256_FIAT_INLINE void fiat_p256_cmovznz_u64(uint64_t* out1, fiat_p25
  *
  */
 static FIAT_P256_FIAT_INLINE void fiat_p256_mul(fiat_p256_montgomery_domain_field_element out1, const fiat_p256_montgomery_domain_field_element arg1, const fiat_p256_montgomery_domain_field_element arg2) {
-#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
+#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__) && !defined(OPENSSL_WINDOWS)
   if (CRYPTO_is_BMI1_capable() && CRYPTO_is_BMI2_capable() &&
     CRYPTO_is_ADX_capable()) {
       fiat_p256_adx_mul(out1, arg1, arg2);
@@ -489,7 +489,7 @@ static FIAT_P256_FIAT_INLINE void fiat_p256_mul(fiat_p256_montgomery_domain_fiel
  *
  */
 static FIAT_P256_FIAT_INLINE void fiat_p256_square(fiat_p256_montgomery_domain_field_element out1, const fiat_p256_montgomery_domain_field_element arg1) {
-#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
+#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__) && !defined(OPENSSL_WINDOWS)
   if (CRYPTO_is_BMI1_capable() && CRYPTO_is_BMI2_capable() &&
     CRYPTO_is_ADX_capable()) {
       fiat_p256_adx_sqr(out1, arg1);
