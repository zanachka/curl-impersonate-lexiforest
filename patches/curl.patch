diff --git a/Makefile.am b/Makefile.am
index 08d59e807..dbe5a0c89 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -85,13 +85,13 @@ EXTRA_DIST = CHANGES.md COPYING RELEASE-NOTES Dockerfile \
 
 DISTCLEANFILES = buildinfo.txt
 
-bin_SCRIPTS = curl-config
+bin_SCRIPTS = curl-impersonate-config
 
 SUBDIRS = lib docs src scripts
 DIST_SUBDIRS = $(SUBDIRS) tests packages include docs
 
 pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = libcurl.pc
+pkgconfig_DATA = libcurl-impersonate.pc
 
 dist-hook:
 	rm -rf $(top_builddir)/tests/log
diff --git a/configure.ac b/configure.ac
index bce4bf69e..cf7b1500b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1476,7 +1476,11 @@ if test X"$OPT_BROTLI" != Xno; then
   CPPFLAGS="$CPPFLAGS $CPP_BROTLI"
   LIBS="$LIB_BROTLI $LIBS"
 
-  AC_CHECK_LIB(brotlidec, BrotliDecoderDecompress)
+  AC_CHECK_LIB(brotlidec, BrotliDecoderDecompress,
+    # curl-impersonate: Define 'action-if-found' explicitly to prevent
+    # -lbrotlidec from being added to LIBS (already added before)
+    AC_DEFINE(HAVE_LIBBROTLI, 1, [Define to 1 if libbrotli exists])
+  )
 
   AC_CHECK_HEADERS(brotli/decode.h,
     curl_brotli_msg="enabled (libbrotlidec)"
@@ -5472,6 +5476,8 @@ SUPPORT_PROTOCOLS=`echo $SUPPORT_PROTOCOLS | tr ' ' '\012' | sort | tr '\012' '
 
 AC_SUBST(SUPPORT_PROTOCOLS)
 
+AC_CHECK_FUNCS([SSL_set_alps_use_new_codepoint])
+
 dnl squeeze whitespace out of some variables
 
 squeeze CFLAGS
@@ -5526,8 +5532,8 @@ AC_CONFIG_FILES([\
   tests/http/Makefile \
   packages/Makefile \
   packages/vms/Makefile \
-  curl-config \
-  libcurl.pc
+  curl-impersonate-config:curl-config.in \
+  libcurl-impersonate.pc:libcurl.pc.in
 ])
 AC_OUTPUT
 
diff --git a/curl-config.in b/curl-config.in
index 31ea30b24..6534c1166 100644
--- a/curl-config.in
+++ b/curl-config.in
@@ -155,9 +155,9 @@ while test "$#" -gt 0; do
       curllibdir=''
     fi
     if test 'X@ENABLE_SHARED@' = 'Xno'; then
-      echo "${curllibdir}-lcurl @LIBCURL_PC_LIBS_PRIVATE@"
+      echo "${curllibdir}-lcurl-impersonate @LIBCURL_PC_LIBS_PRIVATE@"
     else
-      echo "${curllibdir}-lcurl"
+      echo "${curllibdir}-lcurl-impersonate"
     fi
     ;;
 
@@ -167,7 +167,7 @@ while test "$#" -gt 0; do
 
   --static-libs)
     if test 'X@ENABLE_STATIC@' != 'Xno'; then
-      echo "@libdir@/libcurl.@libext@ @LIBCURL_PC_LDFLAGS_PRIVATE@ @LIBCURL_PC_LIBS_PRIVATE@"
+      echo "@libdir@/libcurl-impersonate.@libext@ @LIBCURL_PC_LDFLAGS_PRIVATE@ @LIBCURL_PC_LIBS_PRIVATE@"
     else
       echo 'curl was built with static libraries disabled' >&2
       exit 1
diff --git a/export.sh b/export.sh
new file mode 100755
index 000000000..0b981b811
--- /dev/null
+++ b/export.sh
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+# TODO: use cmake to generate mingw makefile, see:
+#
+# 1. https://github.com/curl/curl/pull/13244/files
+# 2. https://everything.curl.dev/build/windows.html
+
+git df curl-8_15_0 > chrome.patch
+mv chrome.patch ../curl-impersonate/patches/curl.patch
diff --git a/include/curl/curl.h b/include/curl/curl.h
index 7ef5b9934..e640ab9ba 100644
--- a/include/curl/curl.h
+++ b/include/curl/curl.h
@@ -2249,6 +2249,93 @@ typedef enum {
   /* set TLS supported signature algorithms */
   CURLOPT(CURLOPT_SSL_SIGNATURE_ALGORITHMS, CURLOPTTYPE_STRINGPOINT, 328),
 
+  /* curl-impersonate: The master option for setting an impersonate target */
+  CURLOPT(CURLOPT_IMPERSONATE, CURLOPTTYPE_STRINGPOINT, 999),
+
+  /* curl-impersonate: A list of headers used by the impersonated browser.
+   * If given, merged with CURLOPT_HTTPHEADER. */
+  CURLOPT(CURLOPT_HTTPBASEHEADER, CURLOPTTYPE_SLISTPOINT, 1000),
+
+  /* curl-impersonate: A list of TLS signature hash algorithms.
+   * This has been implemented by curl as option 328, but we will keep it for compatibility.
+   * See https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.1.4.1 */
+  CURLOPT(CURLOPT_SSL_SIG_HASH_ALGS, CURLOPTTYPE_STRINGPOINT, 1001),
+
+  /* curl-impersonate: Whether to enable ALPS in TLS or not.
+   * See https://datatracker.ietf.org/doc/html/draft-vvv-tls-alps.
+   * Support for ALPS is minimal and is intended only for the TLS client
+   * hello to match. */
+  CURLOPT(CURLOPT_SSL_ENABLE_ALPS, CURLOPTTYPE_LONG, 1002),
+
+  /* curl-impersonate: Comma-separated list of certificate compression
+   * algorithms to use. These are published in the client hello.
+   * Supported algorithms are "zlib" and "brotli".
+   * See https://datatracker.ietf.org/doc/html/rfc8879 */
+  CURLOPT(CURLOPT_SSL_CERT_COMPRESSION, CURLOPTTYPE_STRINGPOINT, 1003),
+
+  /* Enable/disable TLS session ticket extension (RFC5077) */
+  CURLOPT(CURLOPT_SSL_ENABLE_TICKET, CURLOPTTYPE_LONG, 1004),
+
+  /*
+   * curl-impersonate:
+   * Set the order of the HTTP/2 pseudo headers. The value must contain
+   * the letters 'm', 'a', 's', 'p' representing the pseudo-headers
+   * ":method", ":authority", ":scheme", ":path" in the desired order of
+   * appearance in the HTTP/2 HEADERS frame.
+   */
+  CURLOPT(CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER, CURLOPTTYPE_STRINGPOINT, 1005),
+
+  /* curl-impersonate: HTTP2 settings frame keys and values, format: 1:v;2:v;3:v */
+  CURLOPT(CURLOPT_HTTP2_SETTINGS, CURLOPTTYPE_STRINGPOINT, 1006),
+
+  /*
+   * curl-impersonate: Whether to enable Boringssl permute extensions
+   * See https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#SSL_set_permute_extensions.
+   */
+  CURLOPT(CURLOPT_SSL_PERMUTE_EXTENSIONS, CURLOPTTYPE_LONG, 1007),
+
+  /* curl-impersonate: HTTP2 initial window update */
+  CURLOPT(CURLOPT_HTTP2_WINDOW_UPDATE, CURLOPTTYPE_LONG, 1008),
+
+  /* curl-impersonate: Set the initial streams settings for http2. */
+  CURLOPT(CURLOPT_HTTP2_STREAMS, CURLOPTTYPE_STRINGPOINT, 1010),
+
+  /* curl-impersonate: enable tls grease */
+  CURLOPT(CURLOPT_TLS_GREASE, CURLOPTTYPE_LONG, 1011),
+
+  /* curl-impersonate: set tls extension order */
+  CURLOPT(CURLOPT_TLS_EXTENSION_ORDER, CURLOPTTYPE_STRINGPOINT, 1012),
+
+  /* curl-impersonate: Set stream exclusiveness, 0 or 1 */
+  CURLOPT(CURLOPT_STREAM_EXCLUSIVE, CURLOPTTYPE_LONG, 1013),
+
+  /* curl-impersonate: enable tls key usage check, defaults: on */
+  CURLOPT(CURLOPT_TLS_KEY_USAGE_NO_CHECK, CURLOPTTYPE_LONG, 1014),
+
+  /* curl-impersonate: enable tls signed cert stamps */
+  CURLOPT(CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS, CURLOPTTYPE_LONG, 1015),
+
+  /* curl-impersonate: enable tls status request */
+  CURLOPT(CURLOPT_TLS_STATUS_REQUEST, CURLOPTTYPE_LONG, 1016),
+
+  /* curl-impersonate: firefox delegated credentials */
+  CURLOPT(CURLOPT_TLS_DELEGATED_CREDENTIALS, CURLOPTTYPE_STRINGPOINT, 1017),
+
+  /* curl-impersonate: firefox record size limit */
+  CURLOPT(CURLOPT_TLS_RECORD_SIZE_LIMIT, CURLOPTTYPE_LONG, 1018),
+
+  /* curl-impersonate: firefox key_shares_limit */
+  CURLOPT(CURLOPT_TLS_KEY_SHARES_LIMIT, CURLOPTTYPE_LONG, 1019),
+
+  /* curl-impersonate: Use the new ALPS code point */
+  CURLOPT(CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT, CURLOPTTYPE_LONG, 1020),
+
+  /* curl-impersonate: Do not set the priority bit in http2 header frame */
+  CURLOPT(CURLOPT_HTTP2_NO_PRIORITY, CURLOPTTYPE_LONG, 1021),
+
+  /* curl-impersonate: Do not reuse TLS sessions or connections from different proxy credentials */
+  CURLOPT(CURLOPT_PROXY_CREDENTIAL_NO_REUSE, CURLOPTTYPE_LONG, 1022),
+
   CURLOPT_LASTENTRY /* the last unused */
 } CURLoption;
 
diff --git a/include/curl/curlver.h b/include/curl/curlver.h
index b3fc29b91..0edf9b98f 100644
--- a/include/curl/curlver.h
+++ b/include/curl/curlver.h
@@ -32,7 +32,7 @@
 
 /* This is the version number of the libcurl package from which this header
    file origins: */
-#define LIBCURL_VERSION "8.15.0-DEV"
+#define LIBCURL_VERSION "8.15.0-IMPERSONATE"
 
 /* The numeric version number is also available "in parts" by using these
    defines: */
diff --git a/include/curl/easy.h b/include/curl/easy.h
index 56f8060e0..1a348c502 100644
--- a/include/curl/easy.h
+++ b/include/curl/easy.h
@@ -43,6 +43,17 @@ CURL_EXTERN CURLcode curl_easy_setopt(CURL *curl, CURLoption option, ...);
 CURL_EXTERN CURLcode curl_easy_perform(CURL *curl);
 CURL_EXTERN void curl_easy_cleanup(CURL *curl);
 
+/*
+ * curl-impersonate: Tell libcurl to impersonate a browser.
+ * This is a wrapper function that calls curl_easy_setopt()
+ * multiple times with all the parameters required. That's also why it was
+ * created as a separate API function and not just as another option to
+ * curl_easy_setopt().
+ */
+CURL_EXTERN CURLcode curl_easy_impersonate(CURL *curl, const char *target,
+                                           int default_headers);
+
+
 /*
  * NAME curl_easy_getinfo()
  *
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 75fbbdf4b..2d57e3367 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -35,7 +35,7 @@ EXTRA_DIST = config-mac.h config-os400.h config-plan9.h config-riscos.h \
   config-win32.h curl_config.h.in $(LIB_RCFILES) libcurl.def            \
   $(CMAKE_DIST) Makefile.soname optiontable.pl $(CHECKSRC_DIST)
 
-lib_LTLIBRARIES = libcurl.la
+lib_LTLIBRARIES = libcurl-impersonate.la
 
 if BUILD_UNITTESTS
 noinst_LTLIBRARIES = libcurlu.la
@@ -84,63 +84,63 @@ if USE_UNITY
 libcurl_unity.c: $(top_srcdir)/scripts/mk-unity.pl $(CSOURCES)
 	@PERL@ $(top_srcdir)/scripts/mk-unity.pl --include $(CSOURCES) > libcurl_unity.c
 
-nodist_libcurl_la_SOURCES = libcurl_unity.c
-libcurl_la_SOURCES =
+nodist_libcurl_impersonate_la_SOURCES = libcurl_unity.c
+libcurl_impersonate_la_SOURCES =
 nodist_libcurlu_la_SOURCES = libcurl_unity.c
 libcurlu_la_SOURCES =
 CLEANFILES = libcurl_unity.c
 else
-libcurl_la_SOURCES = $(CSOURCES) $(HHEADERS)
+libcurl_impersonate_la_SOURCES = $(CSOURCES) $(HHEADERS)
 libcurlu_la_SOURCES = $(CSOURCES) $(HHEADERS)
 CLEANFILES =
 endif
 
 CLEANFILES += $(UNITPROTOS)
 
-libcurl_la_CPPFLAGS_EXTRA =
-libcurl_la_LDFLAGS_EXTRA =
-libcurl_la_CFLAGS_EXTRA =
+libcurl_impersonate_la_CPPFLAGS_EXTRA =
+libcurl_impersonate_la_LDFLAGS_EXTRA =
+libcurl_impersonate_la_CFLAGS_EXTRA =
 
 if CURL_LT_SHLIB_USE_VERSION_INFO
 # Get VERSIONCHANGE, VERSIONADD, VERSIONDEL, VERSIONINFO variables
 include Makefile.soname
-libcurl_la_LDFLAGS_EXTRA += $(VERSIONINFO)
+libcurl_impersonate_la_LDFLAGS_EXTRA += $(VERSIONINFO)
 endif
 
 if CURL_LT_SHLIB_USE_NO_UNDEFINED
-libcurl_la_LDFLAGS_EXTRA += -no-undefined
+libcurl_impersonate_la_LDFLAGS_EXTRA += -no-undefined
 endif
 
 if CURL_LT_SHLIB_USE_MIMPURE_TEXT
-libcurl_la_LDFLAGS_EXTRA += -mimpure-text
+libcurl_impersonate_la_LDFLAGS_EXTRA += -mimpure-text
 endif
 
 if CURL_LT_SHLIB_USE_VERSIONED_SYMBOLS
-libcurl_la_LDFLAGS_EXTRA += -Wl,--version-script=libcurl.vers
+libcurl_impersonate_la_LDFLAGS_EXTRA += -Wl,--version-script=libcurl.vers
 else
 # if symbol-hiding is enabled, hide them!
 if DOING_CURL_SYMBOL_HIDING
-libcurl_la_LDFLAGS_EXTRA += -export-symbols-regex '^curl_.*'
+libcurl_impersonate_la_LDFLAGS_EXTRA += -export-symbols-regex '^curl_.*'
 endif
 endif
 
 if USE_CPPFLAG_CURL_STATICLIB
-libcurl_la_CPPFLAGS_EXTRA += -DCURL_STATICLIB
+libcurl_impersonate_la_CPPFLAGS_EXTRA += -DCURL_STATICLIB
 else
 if HAVE_WINDRES
-libcurl_la_SOURCES += $(LIB_RCFILES)
+libcurl_impersonate_la_SOURCES += $(LIB_RCFILES)
 $(LIB_RCFILES): $(top_srcdir)/include/curl/curlver.h
 endif
 endif
 
 if DOING_CURL_SYMBOL_HIDING
-libcurl_la_CPPFLAGS_EXTRA += -DCURL_HIDDEN_SYMBOLS
-libcurl_la_CFLAGS_EXTRA += $(CFLAG_CURL_SYMBOL_HIDING)
+libcurl_impersonate_la_CPPFLAGS_EXTRA += -DCURL_HIDDEN_SYMBOLS
+libcurl_impersonate_la_CFLAGS_EXTRA += $(CFLAG_CURL_SYMBOL_HIDING)
 endif
 
-libcurl_la_CPPFLAGS = $(AM_CPPFLAGS) $(libcurl_la_CPPFLAGS_EXTRA)
-libcurl_la_LDFLAGS = $(AM_LDFLAGS) $(libcurl_la_LDFLAGS_EXTRA) $(CURL_LDFLAGS_LIB) $(LIBCURL_PC_LIBS_PRIVATE)
-libcurl_la_CFLAGS = $(AM_CFLAGS) $(libcurl_la_CFLAGS_EXTRA)
+libcurl_impersonate_la_CPPFLAGS = $(AM_CPPFLAGS) $(libcurl_impersonate_la_CPPFLAGS_EXTRA)
+libcurl_impersonate_la_LDFLAGS = $(AM_LDFLAGS) $(libcurl_impersonate_la_LDFLAGS_EXTRA) $(CURL_LDFLAGS_LIB) $(LIBCURL_PC_LIBS_PRIVATE)
+libcurl_impersonate_la_CFLAGS = $(AM_CFLAGS) $(libcurl_impersonate_la_CFLAGS_EXTRA)
 
 libcurlu_la_CPPFLAGS = $(AM_CPPFLAGS) -DCURL_STATICLIB -DUNITTESTS
 libcurlu_la_LDFLAGS = $(AM_LDFLAGS) -static $(LIBCURL_PC_LIBS_PRIVATE)
diff --git a/lib/Makefile.inc b/lib/Makefile.inc
index 257e104de..ccd06bae0 100644
--- a/lib/Makefile.inc
+++ b/lib/Makefile.inc
@@ -210,6 +210,7 @@ LIB_CFILES =         \
   idn.c              \
   if2ip.c            \
   imap.c             \
+  impersonate.c      \
   krb5.c             \
   ldap.c             \
   llist.c            \
diff --git a/lib/connect.c b/lib/connect.c
index ac16c3399..4f84781cd 100644
--- a/lib/connect.c
+++ b/lib/connect.c
@@ -1292,12 +1292,18 @@ connect_sub_chain:
   /* sub-chain connected, do we need to add more? */
 #ifndef CURL_DISABLE_PROXY
   if(ctx->state < CF_SETUP_CNNCT_SOCKS && cf->conn->bits.socksproxy) {
-    result = Curl_cf_socks_proxy_insert_after(cf, data);
-    if(result)
-      return result;
-    ctx->state = CF_SETUP_CNNCT_SOCKS;
-    if(!cf->next || !cf->next->connected)
-      goto connect_sub_chain;
+    /* curl-impersonate: for QUIC transport, update the state here. */
+    if(ctx->transport == TRNSPRT_QUIC) {
+      ctx->state = CF_SETUP_CNNCT_SOCKS;
+    }
+    else {
+      result = Curl_cf_socks_proxy_insert_after(cf, data);
+      if(result)
+        return result;
+      ctx->state = CF_SETUP_CNNCT_SOCKS;
+      if(!cf->next || !cf->next->connected)
+        goto connect_sub_chain;
+    }
   }
 
   if(ctx->state < CF_SETUP_CNNCT_HTTP_PROXY && cf->conn->bits.httpproxy) {
diff --git a/lib/dynhds.c b/lib/dynhds.c
index dcb9193a8..30be16064 100644
--- a/lib/dynhds.c
+++ b/lib/dynhds.c
@@ -56,6 +56,9 @@ entry_new(const char *name, size_t namelen,
   e->valuelen = valuelen;
   if(opts & DYNHDS_OPT_LOWERCASE)
     Curl_strntolower(e->name, e->name, e->namelen);
+  // curl-impersonate: Make header value also lower case
+  if(opts & DYNHDS_OPT_LOWERCASE_VAL)
+    Curl_strntolower(e->value, e->value, e->valuelen);
   return e;
 }
 
@@ -138,6 +141,19 @@ void Curl_dynhds_set_opts(struct dynhds *dynhds, int opts)
   dynhds->opts = opts;
 }
 
+// curl-impersonate
+void Curl_dynhds_set_opt(struct dynhds *dynhds, int opt)
+{
+  dynhds->opts |= opt;
+}
+
+// curl-impersonate
+void Curl_dynhds_del_opt(struct dynhds *dynhds, int opt)
+{
+  dynhds->opts &= ~opt;
+}
+
+
 struct dynhds_entry *Curl_dynhds_getn(struct dynhds *dynhds, size_t n)
 {
   DEBUGASSERT(dynhds);
@@ -175,7 +191,7 @@ CURLcode Curl_dynhds_add(struct dynhds *dynhds,
   if(dynhds->strs_len + namelen + valuelen > dynhds->max_strs_size)
     return CURLE_OUT_OF_MEMORY;
 
-entry = entry_new(name, namelen, value, valuelen, dynhds->opts);
+  entry = entry_new(name, namelen, value, valuelen, dynhds->opts);
   if(!entry)
     goto out;
 
diff --git a/lib/dynhds.h b/lib/dynhds.h
index e533dcc36..84d8c5d70 100644
--- a/lib/dynhds.h
+++ b/lib/dynhds.h
@@ -53,6 +53,7 @@ struct dynhds {
 
 #define DYNHDS_OPT_NONE          (0)
 #define DYNHDS_OPT_LOWERCASE     (1 << 0)
+#define DYNHDS_OPT_LOWERCASE_VAL (1 << 1)
 
 /**
  * Init for use on first time or after a reset.
@@ -82,6 +83,9 @@ size_t Curl_dynhds_count(struct dynhds *dynhds);
  * This will not have an effect on already existing headers.
  */
 void Curl_dynhds_set_opts(struct dynhds *dynhds, int opts);
+// curl-impersonate
+void Curl_dynhds_set_opt(struct dynhds *dynhds, int opt);
+void Curl_dynhds_del_opt(struct dynhds *dynhds, int opt);
 
 /**
  * Return the n-th header entry or NULL if it does not exist.
@@ -99,7 +103,7 @@ struct dynhds_entry *Curl_dynhds_cget(struct dynhds *dynhds, const char *name);
 /* used by unit2602.c */
 
 /**
- * Return TRUE iff one or more headers with the given name exist.
+ * Return TRUE if one or more headers with the given name exist.
  */
 bool Curl_dynhds_contains(struct dynhds *dynhds,
                           const char *name, size_t namelen);
diff --git a/lib/easy.c b/lib/easy.c
index 9c1f1c696..bdba88894 100644
--- a/lib/easy.c
+++ b/lib/easy.c
@@ -77,6 +77,8 @@
 #include "curlx/dynbuf.h"
 #include "altsvc.h"
 #include "hsts.h"
+#include "strcase.h"
+#include "impersonate.h"
 
 #include "easy_lock.h"
 
@@ -345,6 +347,288 @@ CURLsslset curl_global_sslset(curl_sslbackend id, const char *name,
   return rc;
 }
 
+
+
+/*
+ * curl-impersonate:
+ * Actually call curl_easy_setopt() with all the needed options
+ * */
+static CURLcode _do_impersonate(struct Curl_easy *data,
+                        const struct impersonate_opts *opts,
+                        int default_headers)
+{
+  int i;
+  int ret;
+  struct curl_slist *headers = NULL;
+
+  if(opts->target == NULL) {
+    DEBUGF(fprintf(stderr, "Error: unknown impersonation target '%s'\n",
+                   opts->target));
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+  }
+
+  if(opts->httpversion != CURL_HTTP_VERSION_NONE) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP_VERSION, opts->httpversion);
+    if(ret)
+      return ret;
+  }
+
+  if (opts->ssl_version != CURL_SSLVERSION_DEFAULT) {
+    ret = curl_easy_setopt(data, CURLOPT_SSLVERSION, opts->ssl_version);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->ciphers) {
+    ret = curl_easy_setopt(data, CURLOPT_SSL_CIPHER_LIST, opts->ciphers);
+    if (ret)
+      return ret;
+  }
+
+  if(opts->curves) {
+    ret = curl_easy_setopt(data, CURLOPT_SSL_EC_CURVES, opts->curves);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->sig_hash_algs) {
+    ret = curl_easy_setopt(data, CURLOPT_SSL_SIG_HASH_ALGS,
+                           opts->sig_hash_algs);
+    if(ret)
+      return ret;
+  }
+
+  // TODO: remove npn, which has been deprecated by curl
+  ret = curl_easy_setopt(data, CURLOPT_SSL_ENABLE_NPN, opts->npn ? 1 : 0);
+  if(ret)
+    return ret;
+
+  ret = curl_easy_setopt(data, CURLOPT_SSL_ENABLE_ALPN, opts->alpn ? 1 : 0);
+  if(ret)
+    return ret;
+
+  ret = curl_easy_setopt(data, CURLOPT_SSL_ENABLE_ALPS, opts->alps ? 1 : 0);
+  if(ret)
+    return ret;
+
+  ret = curl_easy_setopt(data, CURLOPT_SSL_ENABLE_TICKET,
+                         opts->tls_session_ticket ? 1 : 0);
+  if(ret)
+    return ret;
+
+  // always enable this for browsers
+  ret = curl_easy_setopt(data, CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS, 1);
+  if(ret)
+    return ret;
+
+  // always enable this for browsers
+  ret = curl_easy_setopt(data, CURLOPT_TLS_STATUS_REQUEST, 1);
+  if(ret)
+    return ret;
+
+  if(opts->tls_permute_extensions) {
+    ret = curl_easy_setopt(data, CURLOPT_SSL_PERMUTE_EXTENSIONS, 1);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->cert_compression) {
+    ret = curl_easy_setopt(data,
+                           CURLOPT_SSL_CERT_COMPRESSION,
+                           opts->cert_compression);
+    if(ret)
+      return ret;
+  }
+
+  if(default_headers) {
+    /* Build a linked list out of the static array of headers. */
+    for(i = 0; i < IMPERSONATE_MAX_HEADERS; i++) {
+      if(opts->http_headers[i]) {
+        headers = curl_slist_append(headers, opts->http_headers[i]);
+        if(!headers) {
+          return CURLE_OUT_OF_MEMORY;
+        }
+      }
+    }
+
+    if(headers) {
+      ret = curl_easy_setopt(data, CURLOPT_HTTPBASEHEADER, headers);
+      curl_slist_free_all(headers);
+      if(ret)
+        return ret;
+    }
+  }
+
+  if(opts->http2_pseudo_headers_order) {
+    ret = curl_easy_setopt(data,
+                           CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER,
+                           opts->http2_pseudo_headers_order);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_settings) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP2_SETTINGS, opts->http2_settings);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_window_update) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP2_WINDOW_UPDATE, opts->http2_window_update);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_streams) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP2_STREAMS, opts->http2_streams);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_no_priority) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP2_NO_PRIORITY, opts->http2_no_priority);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->ech) {
+    ret = curl_easy_setopt(data, CURLOPT_ECH, opts->ech);
+    if(ret)
+      return ret;
+  }
+
+  ret = curl_easy_setopt(data, CURLOPT_TLS_GREASE, opts->tls_grease);
+  if(ret)
+    return ret;
+
+  if(opts->tls_extension_order) {
+    ret = curl_easy_setopt(data, CURLOPT_TLS_EXTENSION_ORDER, opts->tls_extension_order);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->tls_delegated_credentials) {
+    ret = curl_easy_setopt(data, CURLOPT_TLS_DELEGATED_CREDENTIALS, opts->tls_delegated_credentials);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->tls_record_size_limit) {
+    ret = curl_easy_setopt(data, CURLOPT_TLS_RECORD_SIZE_LIMIT, opts->tls_record_size_limit);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->tls_key_shares_limit) {
+    ret = curl_easy_setopt(data, CURLOPT_TLS_KEY_SHARES_LIMIT, opts->tls_key_shares_limit);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->tls_use_new_alps_codepoint) {
+    ret = curl_easy_setopt(data, CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT, opts->tls_use_new_alps_codepoint);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_stream_weight) {
+    ret = curl_easy_setopt(data, CURLOPT_STREAM_WEIGHT, opts->http2_stream_weight);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_stream_exclusive) {
+    ret = curl_easy_setopt(data, CURLOPT_STREAM_EXCLUSIVE, opts->http2_stream_exclusive);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->proxy_credential_no_reuse) {
+    ret = curl_easy_setopt(data, CURLOPT_PROXY_CREDENTIAL_NO_REUSE, opts->proxy_credential_no_reuse);
+    if(ret)
+      return ret;
+  }
+
+  return CURLE_OK;
+}
+
+
+/*
+ * curl-impersonate:
+ * Call curl_easy_setopt() with all the needed options as defined by the target
+ * */
+CURLcode curl_easy_impersonate_customized(struct Curl_easy *data,
+                                          const struct impersonate_opts *opts,
+                                          int default_headers)
+{
+  int ret;
+
+  ret = _do_impersonate(data, opts, default_headers);
+  if(ret)
+    return ret;
+
+  return CURLE_OK;
+}
+
+
+static const struct impersonate_opts *binary_search(size_t size, const char *key)
+{
+  int low = 0;
+  int high = size - 1;
+
+  while(low <= high) {
+    int mid = low + (high - low) / 2;
+    int cmp = strcmp(impersonations[mid].target, key);
+
+    if(cmp == 0) {
+      return &impersonations[mid];
+    } else if(cmp < 0) {
+      low = mid + 1;
+    } else {
+      high = mid - 1;
+    }
+  }
+
+  return NULL;
+}
+
+/*
+ * curl-impersonate:
+ * Call curl_easy_setopt() with all the needed options as defined in the
+ * 'impersonations' array.
+ * */
+CURLcode curl_easy_impersonate(CURL *data, const char *target,
+                               int default_headers)
+{
+  int ret;
+  const struct impersonate_opts *opts = NULL;
+  struct Curl_easy *_data = (struct Curl_easy *)data;
+
+  opts = binary_search(num_impersonations, target);
+
+  // If not found, fallback and search by alias again
+  if(opts == NULL) {
+    for(int i = 0; i < num_impersonations; ++i) {
+      if (curl_strequal(target, impersonations[i].alias)) {
+        opts = impersonations + i;
+        break;
+      }
+    }
+  }
+
+  if(opts == NULL) {
+    DEBUGF(fprintf(stderr, "Error: unknown impersonation target '%s'\n", target));
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+  }
+
+  ret = _do_impersonate(_data, opts, default_headers);
+  if(ret)
+    return ret;
+
+  return CURLE_OK;
+}
+
+
 /*
  * curl_easy_init() is the external interface to alloc, setup and init an
  * easy handle that is returned. If anything goes wrong, NULL is returned.
@@ -353,6 +637,8 @@ CURL *curl_easy_init(void)
 {
   CURLcode result;
   struct Curl_easy *data;
+  char *env_target = NULL;
+  char *env_headers = NULL;
 
   /* Make sure we inited the global SSL stuff */
   global_init_lock();
@@ -375,6 +661,29 @@ CURL *curl_easy_init(void)
     return NULL;
   }
 
+  /*
+   * curl-impersonate: Hook into curl_easy_init() to set the required options
+   * from an environment variable.
+   * This is a bit hacky but allows seamless integration of libcurl-impersonate
+   * without code modifications to the app.
+   */
+  env_target = curl_getenv("CURL_IMPERSONATE");
+  if(env_target) {
+    env_headers = curl_getenv("CURL_IMPERSONATE_HEADERS");
+    if(env_headers) {
+      result = curl_easy_impersonate(data, env_target,
+                                     !curl_strequal(env_headers, "no"));
+      free(env_headers);
+    } else {
+      result = curl_easy_impersonate(data, env_target, true);
+    }
+    free(env_target);
+    if(result) {
+      Curl_close(&data);
+      return NULL;
+    }
+  }
+
   return data;
 }
 
@@ -1017,6 +1326,13 @@ CURL *curl_easy_duphandle(CURL *d)
     outcurl->state.referer_alloc = TRUE;
   }
 
+  if(data->state.base_headers) {
+    outcurl->state.base_headers =
+      Curl_slist_duplicate(data->state.base_headers);
+    if(!outcurl->state.base_headers)
+      goto fail;
+  }
+
   /* Reinitialize an SSL engine for the new handle
    * note: the engine name has already been copied by dupset */
   if(outcurl->set.str[STRING_SSL_ENGINE]) {
@@ -1073,6 +1389,9 @@ fail:
  */
 void curl_easy_reset(CURL *d)
 {
+  char *env_target;
+  char *env_headers;
+
   struct Curl_easy *data = d;
   Curl_req_hard_reset(&data->req, data);
   Curl_hash_clean(&data->meta_hash);
@@ -1106,6 +1425,22 @@ void curl_easy_reset(CURL *d)
   Curl_http_auth_cleanup_digest(data);
 #endif
   data->master_mid = UINT_MAX;
+  /*
+   * curl-impersonate: Hook into curl_easy_reset() to set the required options
+   * from an environment variable, just like in curl_easy_init().
+   */
+  env_target = curl_getenv("CURL_IMPERSONATE");
+  if(env_target) {
+    env_headers = curl_getenv("CURL_IMPERSONATE_HEADERS");
+    if(env_headers) {
+      curl_easy_impersonate(data, env_target,
+                            !curl_strequal(env_headers, "no"));
+      free(env_headers);
+    } else {
+      curl_easy_impersonate(data, env_target, true);
+    }
+    free(env_target);
+  }
 }
 
 /*
diff --git a/lib/easyoptions.c b/lib/easyoptions.c
index 03d676df0..57aee3994 100644
--- a/lib/easyoptions.c
+++ b/lib/easyoptions.c
@@ -134,7 +134,13 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"HSTS_CTRL", CURLOPT_HSTS_CTRL, CURLOT_LONG, 0},
   {"HTTP09_ALLOWED", CURLOPT_HTTP09_ALLOWED, CURLOT_LONG, 0},
   {"HTTP200ALIASES", CURLOPT_HTTP200ALIASES, CURLOT_SLIST, 0},
+  {"HTTP2_NO_PRIORITY", CURLOPT_HTTP2_NO_PRIORITY, CURLOT_LONG, 0},
+  {"HTTP2_PSEUDO_HEADERS_ORDER", CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER, CURLOT_STRING, 0},
+  {"HTTP2_SETTINGS", CURLOPT_HTTP2_SETTINGS, CURLOT_STRING, 0},
+  {"HTTP2_STREAMS", CURLOPT_HTTP2_STREAMS, CURLOT_STRING, 0},
+  {"HTTP2_WINDOW_UPDATE", CURLOPT_HTTP2_WINDOW_UPDATE, CURLOT_LONG, 0},
   {"HTTPAUTH", CURLOPT_HTTPAUTH, CURLOT_VALUES, 0},
+  {"HTTPBASEHEADER", CURLOPT_HTTPBASEHEADER, CURLOT_SLIST, 0},
   {"HTTPGET", CURLOPT_HTTPGET, CURLOT_LONG, 0},
   {"HTTPHEADER", CURLOPT_HTTPHEADER, CURLOT_SLIST, 0},
   {"HTTPPOST", CURLOPT_HTTPPOST, CURLOT_OBJECT, 0},
@@ -146,6 +152,7 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"INFILE", CURLOPT_READDATA, CURLOT_CBPTR, CURLOT_FLAG_ALIAS},
   {"INFILESIZE", CURLOPT_INFILESIZE, CURLOT_LONG, 0},
   {"INFILESIZE_LARGE", CURLOPT_INFILESIZE_LARGE, CURLOT_OFF_T, 0},
+  {"IMPERSONATE", CURLOPT_IMPERSONATE, CURLOT_STRING, 0},
   {"INTERFACE", CURLOPT_INTERFACE, CURLOT_STRING, 0},
   {"INTERLEAVEDATA", CURLOPT_INTERLEAVEDATA, CURLOT_CBPTR, 0},
   {"INTERLEAVEFUNCTION", CURLOPT_INTERLEAVEFUNCTION, CURLOT_FUNCTION, 0},
@@ -221,6 +228,7 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"PROXY_CAINFO", CURLOPT_PROXY_CAINFO, CURLOT_STRING, 0},
   {"PROXY_CAINFO_BLOB", CURLOPT_PROXY_CAINFO_BLOB, CURLOT_BLOB, 0},
   {"PROXY_CAPATH", CURLOPT_PROXY_CAPATH, CURLOT_STRING, 0},
+  {"PROXY_CREDENTIAL_NO_REUSE", CURLOPT_PROXY_CREDENTIAL_NO_REUSE, CURLOT_LONG, 0},
   {"PROXY_CRLFILE", CURLOPT_PROXY_CRLFILE, CURLOT_STRING, 0},
   {"PROXY_ISSUERCERT", CURLOPT_PROXY_ISSUERCERT, CURLOT_STRING, 0},
   {"PROXY_ISSUERCERT_BLOB", CURLOPT_PROXY_ISSUERCERT_BLOB, CURLOT_BLOB, 0},
@@ -308,23 +316,29 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"SSLKEYTYPE", CURLOPT_SSLKEYTYPE, CURLOT_STRING, 0},
   {"SSLKEY_BLOB", CURLOPT_SSLKEY_BLOB, CURLOT_BLOB, 0},
   {"SSLVERSION", CURLOPT_SSLVERSION, CURLOT_VALUES, 0},
+  {"SSL_CERT_COMPRESSION", CURLOPT_SSL_CERT_COMPRESSION, CURLOT_STRING, 0},
   {"SSL_CIPHER_LIST", CURLOPT_SSL_CIPHER_LIST, CURLOT_STRING, 0},
   {"SSL_CTX_DATA", CURLOPT_SSL_CTX_DATA, CURLOT_CBPTR, 0},
   {"SSL_CTX_FUNCTION", CURLOPT_SSL_CTX_FUNCTION, CURLOT_FUNCTION, 0},
   {"SSL_EC_CURVES", CURLOPT_SSL_EC_CURVES, CURLOT_STRING, 0},
   {"SSL_ENABLE_ALPN", CURLOPT_SSL_ENABLE_ALPN, CURLOT_LONG, 0},
+  {"SSL_ENABLE_ALPS", CURLOPT_SSL_ENABLE_ALPS, CURLOT_LONG, 0},
   {"SSL_ENABLE_NPN", CURLOPT_SSL_ENABLE_NPN, CURLOT_LONG, 0},
+  {"SSL_ENABLE_TICKET", CURLOPT_SSL_ENABLE_TICKET, CURLOT_LONG, 0},
   {"SSL_FALSESTART", CURLOPT_SSL_FALSESTART, CURLOT_LONG, 0},
   {"SSL_OPTIONS", CURLOPT_SSL_OPTIONS, CURLOT_VALUES, 0},
+  {"SSL_PERMUTE_EXTENSIONS", CURLOPT_SSL_PERMUTE_EXTENSIONS, CURLOT_LONG, 0},
   {"SSL_SESSIONID_CACHE", CURLOPT_SSL_SESSIONID_CACHE, CURLOT_LONG, 0},
   {"SSL_SIGNATURE_ALGORITHMS", CURLOPT_SSL_SIGNATURE_ALGORITHMS,
    CURLOT_STRING, 0},
+  {"SSL_SIG_HASH_ALGS", CURLOPT_SSL_SIG_HASH_ALGS, CURLOT_STRING, 0},
   {"SSL_VERIFYHOST", CURLOPT_SSL_VERIFYHOST, CURLOT_LONG, 0},
   {"SSL_VERIFYPEER", CURLOPT_SSL_VERIFYPEER, CURLOT_LONG, 0},
   {"SSL_VERIFYSTATUS", CURLOPT_SSL_VERIFYSTATUS, CURLOT_LONG, 0},
   {"STDERR", CURLOPT_STDERR, CURLOT_OBJECT, 0},
   {"STREAM_DEPENDS", CURLOPT_STREAM_DEPENDS, CURLOT_OBJECT, 0},
   {"STREAM_DEPENDS_E", CURLOPT_STREAM_DEPENDS_E, CURLOT_OBJECT, 0},
+  {"STREAM_EXCLUSIVE", CURLOPT_STREAM_EXCLUSIVE, CURLOT_LONG, 0},
   {"STREAM_WEIGHT", CURLOPT_STREAM_WEIGHT, CURLOT_LONG, 0},
   {"SUPPRESS_CONNECT_HEADERS", CURLOPT_SUPPRESS_CONNECT_HEADERS,
    CURLOT_LONG, 0},
@@ -346,6 +360,15 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"TLSAUTH_PASSWORD", CURLOPT_TLSAUTH_PASSWORD, CURLOT_STRING, 0},
   {"TLSAUTH_TYPE", CURLOPT_TLSAUTH_TYPE, CURLOT_STRING, 0},
   {"TLSAUTH_USERNAME", CURLOPT_TLSAUTH_USERNAME, CURLOT_STRING, 0},
+  {"TLS_DELEGATED_CREDENTIALS", CURLOPT_TLS_DELEGATED_CREDENTIALS, CURLOT_STRING, 0},
+  {"TLS_EXTENSION_ORDER", CURLOPT_TLS_EXTENSION_ORDER, CURLOT_STRING, 0},
+  {"TLS_GREASE", CURLOPT_TLS_GREASE, CURLOT_LONG, 0},
+  {"TLS_KEY_SHARES_LIMIT", CURLOPT_TLS_KEY_SHARES_LIMIT, CURLOT_LONG, 0},
+  {"TLS_KEY_USAGE_NO_CHECK", CURLOPT_TLS_KEY_USAGE_NO_CHECK, CURLOT_LONG, 0},
+  {"TLS_RECORD_SIZE_LIMIT", CURLOPT_TLS_RECORD_SIZE_LIMIT, CURLOT_LONG, 0},
+  {"TLS_SIGNED_CERT_TIMESTAMPS", CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS, CURLOT_LONG, 0},
+  {"TLS_STATUS_REQUEST", CURLOPT_TLS_STATUS_REQUEST, CURLOT_LONG, 0},
+  {"TLS_USE_NEW_ALPS_CODEPOINT", CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT, CURLOT_LONG, 0},
   {"TRAILERDATA", CURLOPT_TRAILERDATA, CURLOT_CBPTR, 0},
   {"TRAILERFUNCTION", CURLOPT_TRAILERFUNCTION, CURLOT_FUNCTION, 0},
   {"TRANSFERTEXT", CURLOPT_TRANSFERTEXT, CURLOT_LONG, 0},
@@ -380,6 +403,6 @@ const struct curl_easyoption Curl_easyopts[] = {
  */
 int Curl_easyopts_check(void)
 {
-  return (CURLOPT_LASTENTRY % 10000) != (328 + 1);
+  return ((CURLOPT_LASTENTRY%10000) != (1023 + 1));
 }
 #endif
diff --git a/lib/http.c b/lib/http.c
index e5a069627..771efd30a 100644
--- a/lib/http.c
+++ b/lib/http.c
@@ -85,6 +85,7 @@
 #include "hsts.h"
 #include "ws.h"
 #include "curl_ctype.h"
+#include "slist.h"
 #include "curlx/strparse.h"
 
 /* The last 3 #include files should be in this order */
@@ -1624,6 +1625,15 @@ CURLcode Curl_add_custom_headers(struct Curl_easy *data,
   int numlists = 1; /* by default */
   int i;
 
+  /*
+   * curl-impersonate: Use the merged list of headers if it exists (i.e. when
+   * the CURLOPT_HTTPBASEHEADER option was set.
+   */
+  struct curl_slist *noproxyheaders =
+    (data->state.merged_headers ?
+     data->state.merged_headers :
+     data->set.headers);
+
 #ifndef CURL_DISABLE_PROXY
   enum Curl_proxy_use proxy;
 
@@ -1635,10 +1645,11 @@ CURLcode Curl_add_custom_headers(struct Curl_easy *data,
 
   switch(proxy) {
   case HEADER_SERVER:
-    h[0] = data->set.headers;
+    h[0] = noproxyheaders;
+
     break;
   case HEADER_PROXY:
-    h[0] = data->set.headers;
+    h[0] = noproxyheaders;
     if(data->set.sep_headers) {
       h[1] = data->set.proxyheaders;
       numlists++;
@@ -1648,12 +1659,12 @@ CURLcode Curl_add_custom_headers(struct Curl_easy *data,
     if(data->set.sep_headers)
       h[0] = data->set.proxyheaders;
     else
-      h[0] = data->set.headers;
+      h[0] = noproxyheaders;
     break;
   }
 #else
   (void)is_connect;
-  h[0] = data->set.headers;
+  h[0] = noproxyheaders;
 #endif
 
   /* loop through one or two lists */
@@ -1860,6 +1871,109 @@ void Curl_http_method(struct Curl_easy *data, struct connectdata *conn,
   *reqp = httpreq;
 }
 
+/*
+ * curl-impersonate:
+ * Create a new linked list of headers.
+ * The new list is a merge between the "base" headers and the application given
+ * headers. The "base" headers contain curl-impersonate's list of headers
+ * used by default by the impersonated browser.
+ *
+ * The application given headers will override the "base" headers if supplied.
+ */
+CURLcode Curl_http_merge_headers(struct Curl_easy *data)
+{
+  int i;
+  int ret;
+  struct curl_slist *head;
+  struct curl_slist *dup = NULL;
+  struct curl_slist *new_list = NULL;
+  char *uagent;
+
+  if (!data->state.base_headers)
+    return CURLE_OK;
+
+  /* Duplicate the list for temporary use. */
+  if (data->set.headers) {
+    dup = Curl_slist_duplicate(data->set.headers);
+    if(!dup)
+      return CURLE_OUT_OF_MEMORY;
+  }
+
+  for(head = data->state.base_headers; head; head = head->next) {
+    char *sep;
+    size_t prefix_len;
+    bool found = FALSE;
+    struct curl_slist *head2;
+
+    sep = strchr(head->data, ':');
+    if(!sep)
+      continue;
+
+    prefix_len = sep - head->data;
+
+    /* Check if this header was added by the application. */
+    for(head2 = dup; head2; head2 = head2->next) {
+      if(head2->data &&
+         curl_strnequal(head2->data, head->data, prefix_len) &&
+         Curl_headersep(head2->data[prefix_len]) ) {
+        new_list = curl_slist_append(new_list, head2->data);
+        /* Free and set to NULL to mark that it's been added. */
+        Curl_safefree(head2->data);
+        found = TRUE;
+        break;
+      }
+    }
+
+    /* If the user agent was set with CURLOPT_USERAGENT, but not with
+     * CURLOPT_HTTPHEADER, take it from there instead. */
+    if(!found &&
+       curl_strnequal(head->data, "User-Agent", prefix_len) &&
+       data->set.str[STRING_USERAGENT] &&
+       *data->set.str[STRING_USERAGENT]) {
+      uagent = aprintf("User-Agent: %s", data->set.str[STRING_USERAGENT]);
+      if(!uagent) {
+        ret = CURLE_OUT_OF_MEMORY;
+        goto fail;
+      }
+      new_list = Curl_slist_append_nodup(new_list, uagent);
+      found = TRUE;
+    }
+
+    if (!found) {
+      new_list = curl_slist_append(new_list, head->data);
+    }
+
+    if (!new_list) {
+      ret = CURLE_OUT_OF_MEMORY;
+      goto fail;
+    }
+  }
+
+  /* Now go over any additional application-supplied headers. */
+  for(head = dup; head; head = head->next) {
+    if(head->data) {
+      new_list = curl_slist_append(new_list, head->data);
+      if(!new_list) {
+        ret = CURLE_OUT_OF_MEMORY;
+        goto fail;
+      }
+    }
+  }
+
+  curl_slist_free_all(dup);
+  /* Save the new, merged list separately, so it can be freed later. */
+  curl_slist_free_all(data->state.merged_headers);
+  data->state.merged_headers = new_list;
+
+  return CURLE_OK;
+
+fail:
+  Curl_safefree(dup);
+  curl_slist_free_all(new_list);
+  return ret;
+}
+
+
 static CURLcode http_useragent(struct Curl_easy *data)
 {
   /* The User-Agent string might have been allocated in url.c already, because
@@ -2669,7 +2783,6 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
   const char *httpstring;
   struct dynbuf req;
   char *altused = NULL;
-  const char *p_accept;      /* Accept: string */
   unsigned char httpversion;
 
   /* Always consider the DO phase done after this function call, even if there
@@ -2715,6 +2828,11 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
   if(result)
     goto fail;
 
+  /* curl-impersonate: Add HTTP headers to impersonate real browsers. */
+  result = Curl_http_merge_headers(data);
+  if(result)
+    goto fail;
+
   result = http_host(data, conn);
   if(result)
     goto fail;
@@ -2772,9 +2890,6 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
   if(result)
     goto fail;
 
-  p_accept = Curl_checkheaders(data,
-                               STRCONST("Accept")) ? NULL : "Accept: */*\r\n";
-
   result = http_range(data, httpreq);
   if(result)
     goto fail;
@@ -2837,7 +2952,7 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
                     *data->set.str[STRING_USERAGENT] &&
                     data->state.aptr.uagent) ?
                    data->state.aptr.uagent : "",
-                   p_accept ? p_accept : "",
+                   "", // Accept
                    data->state.aptr.te ? data->state.aptr.te : "",
                    (data->set.str[STRING_ENCODING] &&
                     *data->set.str[STRING_ENCODING] &&
@@ -4620,6 +4735,29 @@ static bool http_TE_has_token(const char *fvalue, const char *token)
   return FALSE;
 }
 
+/*
+ * curl-impersonate:
+ * Determine the position of HTTP/2 pseudo headers.
+ * The pseudo headers ":method", ":path", ":scheme", ":authority"
+ * are sent in different order by different browsers. An important part of the
+ * impersonation is ordering them like the browser does.
+ */
+static CURLcode h2_check_pseudo_header_order(const char *order)
+{
+  if(strlen(order) != 4)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  // All pseudo-headers must be present
+  if(!strchr(order, 'm') ||
+     !strchr(order, 'a') ||
+     !strchr(order, 's') ||
+     !strchr(order, 'p'))
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  return CURLE_OK;
+}
+
+
 CURLcode Curl_http_req_to_h2(struct dynhds *h2_headers,
                              struct httpreq *req, struct Curl_easy *data)
 {
@@ -4628,6 +4766,10 @@ CURLcode Curl_http_req_to_h2(struct dynhds *h2_headers,
   size_t i;
   CURLcode result;
 
+  // curl-impersonate: Use the Chrome ordering by default:
+  // :method, :authority, :scheme, :path
+  char *order = "masp";
+
   DEBUGASSERT(req);
   DEBUGASSERT(h2_headers);
 
@@ -4658,20 +4800,42 @@ CURLcode Curl_http_req_to_h2(struct dynhds *h2_headers,
 
   Curl_dynhds_reset(h2_headers);
   Curl_dynhds_set_opts(h2_headers, DYNHDS_OPT_LOWERCASE);
-  result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_METHOD),
-                           req->method, strlen(req->method));
-  if(!result && scheme) {
-    result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_SCHEME),
-                             scheme, strlen(scheme));
-  }
-  if(!result && authority) {
-    result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_AUTHORITY),
-                             authority, strlen(authority));
+
+  /* curl-impersonate: order of pseudo headers is different from the default */
+  if(data->set.str[STRING_HTTP2_PSEUDO_HEADERS_ORDER]) {
+    order = data->set.str[STRING_HTTP2_PSEUDO_HEADERS_ORDER];
   }
-  if(!result && req->path) {
-    result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_PATH),
-                             req->path, strlen(req->path));
+
+  result = h2_check_pseudo_header_order(order);
+
+  /* curl-impersonate: add http2 pseudo headers according to the specified order. */
+  for(i = 0; !result && i < 4; ++i) {
+    switch(order[i]) {
+      case 'm':
+        result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_METHOD),
+                                 req->method, strlen(req->method));
+        break;
+      case 'a':
+        if(authority) {
+          result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_AUTHORITY),
+                                   authority, strlen(authority));
+        }
+        break;
+      case 's':
+        if(scheme) {
+          result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_SCHEME),
+                                   scheme, strlen(scheme));
+        }
+        break;
+      case 'p':
+        if(req->path) {
+          result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_PATH),
+                                   req->path, strlen(req->path));
+        }
+        break;
+    }
   }
+
   for(i = 0; !result && i < Curl_dynhds_count(&req->headers); ++i) {
     e = Curl_dynhds_getn(&req->headers, i);
     /* "TE" is special in that it is only permissible when it
@@ -4684,6 +4848,8 @@ CURLcode Curl_http_req_to_h2(struct dynhds *h2_headers,
     else if(h2_permissible_field(e)) {
       result = Curl_dynhds_add(h2_headers, e->name, e->namelen,
                                e->value, e->valuelen);
+      /* curl-impersonate: delete the option */
+      Curl_dynhds_del_opt(h2_headers, DYNHDS_OPT_LOWERCASE_VAL);
     }
   }
 
diff --git a/lib/http2.c b/lib/http2.c
index 36dca426d..7207e1d7b 100644
--- a/lib/http2.c
+++ b/lib/http2.c
@@ -51,6 +51,7 @@
 #include "curl_printf.h"
 #include "curl_memory.h"
 #include "memdebug.h"
+#include "rand.h"
 
 #if (NGHTTP2_VERSION_NUM < 0x010c00)
 #error too old nghttp2 version, upgrade!
@@ -75,11 +76,13 @@
 /* on send into TLS, we just want to accumulate small frames */
 #define H2_NW_SEND_CHUNKS       1
 /* this is how much we want "in flight" for a stream, unthrottled  */
-#define H2_STREAM_WINDOW_SIZE_MAX   (10 * 1024 * 1024)
+/* curl-impersonate: match Chrome window size. */
+#define H2_STREAM_WINDOW_SIZE_MAX   (1024 * 1024)
 /* this is how much we want "in flight" for a stream, initially, IFF
  * nghttp2 allows us to tweak the local window size. */
 #if NGHTTP2_HAS_SET_LOCAL_WINDOW_SIZE
-#define H2_STREAM_WINDOW_SIZE_INITIAL  (64 * 1024)
+/* curl-impersonate: match Chrome window size. */
+#define H2_STREAM_WINDOW_SIZE_INITIAL  (1024 * 1024)
 #else
 #define H2_STREAM_WINDOW_SIZE_INITIAL H2_STREAM_WINDOW_SIZE_MAX
 #endif
@@ -93,24 +96,95 @@
  * the overall connection. Streams might become PAUSED which will block their
  * received QUOTA in the connection window. If we run out of space, the server
  * is blocked from sending us any data. See #10988 for an issue with this. */
-#define HTTP2_HUGE_WINDOW_SIZE (100 * H2_STREAM_WINDOW_SIZE_MAX)
+/* curl-impersonate: match Chrome window size. */
+#define HTTP2_HUGE_WINDOW_SIZE (15 * H2_STREAM_WINDOW_SIZE_MAX)
 
-#define H2_SETTINGS_IV_LEN  3
+#define H2_SETTINGS_IV_LEN  8
 #define H2_BINSETTINGS_LEN 80
 
 static size_t populate_settings(nghttp2_settings_entry *iv,
                                 struct Curl_easy *data)
 {
-  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;
-  iv[0].value = Curl_multi_max_concurrent_streams(data->multi);
+  // curl-impersonate:
+  // Setting http2 settings frame based on user instruction.
+  // https://httpwg.org/specs/rfc7540.html#SETTINGS
+  // Format example: 1:65536;2:0;4:6291456;6:262144
+
+  // TODO check if the http2 settings is valid
+  int i = 0;
+  char *delimiter = ";";
 
-  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;
-  iv[1].value = H2_STREAM_WINDOW_SIZE_INITIAL;
+  // Use chrome's settings as default
+  char *http2_settings = "1:65536;2:0;4:6291456;6:262144";
+  if(data->set.str[STRING_HTTP2_SETTINGS]) {
+    http2_settings = data->set.str[STRING_HTTP2_SETTINGS];
+  }
 
-  iv[2].settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;
-  iv[2].value = data->multi->push_cb != NULL;
+  // printf("USING settings %s\n", http2_settings);
 
-  return 3;
+  char *tmp = strdup(http2_settings);
+  char *setting = strtok(tmp, delimiter);
+
+  // loop through the string to extract all other tokens
+  while(setting != NULL) {
+    // deal with each setting
+    switch(setting[0]) {
+      case '1':
+        iv[i].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '2':
+        iv[i].settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '3':
+        // FIXME We also need to notify curl_multi about this setting
+        iv[i].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '4':
+        iv[i].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '5':
+        iv[i].settings_id = NGHTTP2_SETTINGS_MAX_FRAME_SIZE;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '6':
+        iv[i].settings_id = NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      // https://tools.ietf.org/html/rfc8441
+      case '8':
+        iv[i].settings_id = NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      // https://tools.ietf.org/html/rfc9218
+      case '9':
+        iv[i].settings_id = NGHTTP2_SETTINGS_NO_RFC7540_PRIORITIES;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+    }
+    setting = strtok(NULL, delimiter);
+  }
+  free(tmp);
+
+  // curl-impersonate:
+  // Up until Chrome 98, there was a randomly chosen setting number in the
+  // HTTP2 SETTINGS frame. This might be something similar to TLS GREASE.
+  // However, it seems to have been removed since.
+  // Curl_rand(data, (unsigned char *)&iv[4].settings_id, sizeof(iv[4].settings_id));
+  // Curl_rand(data, (unsigned char *)&iv[4].value, sizeof(iv[4].value));
+
+  return i;
 }
 
 static ssize_t populate_binsettings(uint8_t *binsettings,
@@ -204,6 +278,77 @@ static void cf_h2_ctx_close(struct cf_h2_ctx *ctx)
   }
 }
 
+// XXX: this function should be deprecated
+static CURLcode http2_set_stream_priority(struct Curl_cfilter *cf,
+                                          struct Curl_easy *data,
+                                          int32_t stream_id,
+                                          int32_t dep_stream_id,
+                                          int32_t weight,
+                                          int exclusive
+                                          )
+{
+  int rv;
+  struct cf_h2_ctx *ctx = cf->ctx;
+  nghttp2_priority_spec pri_spec;
+
+  nghttp2_priority_spec_init(&pri_spec, dep_stream_id, weight, exclusive);
+  rv = nghttp2_submit_priority(ctx->h2, NGHTTP2_FLAG_NONE,
+                               stream_id, &pri_spec);
+  if(rv) {
+    failf(data, "nghttp2_submit_priority() failed: %s(%d)",
+          nghttp2_strerror(rv), rv);
+    return CURLE_HTTP2;
+  }
+
+  return CURLE_OK;
+}
+
+/*
+ * curl-impersonate: Firefox uses an elaborate scheme of http/2 streams to
+ * split the load for html/js/css/images. It builds a tree of streams with
+ * different weights (priorities) by default and communicates this to the
+ * server. Imitate that behavior.
+ * XXX: This has been deprecated in the RFC
+ */
+static CURLcode http2_set_stream_priorities(struct Curl_cfilter *cf,
+                                            struct Curl_easy *data)
+{
+  CURLcode result;
+  char *stream_delimiter = ",";
+  char *value_delimiter = ":";
+
+  if(!data->set.str[STRING_HTTP2_STREAMS])
+    return CURLE_OK;
+
+  char *tmp1 = strdup(data->set.str[STRING_HTTP2_STREAMS]);
+  char *end1;
+  char *stream = strtok_r(tmp1, stream_delimiter, &end1);
+
+  while(stream != NULL) {
+
+    char *tmp2 = strdup(stream);
+    char *end2;
+
+    int32_t stream_id = atoi(strtok_r(tmp2, value_delimiter, &end2));
+    int exclusive = atoi(strtok_r(NULL, value_delimiter, &end2));
+    int32_t dep_stream_id = atoi(strtok_r(NULL, value_delimiter, &end2));
+    int32_t weight = atoi(strtok_r(NULL, value_delimiter, &end2));
+
+    free(tmp2);
+
+    result = http2_set_stream_priority(cf, data, stream_id, dep_stream_id, weight, exclusive);
+    if(result) {
+      free(tmp1);
+      return result;
+    }
+
+    stream = strtok_r(NULL, stream_delimiter, &end1);
+  }
+
+  free(tmp1);
+  return CURLE_OK;
+}
+
 static CURLcode nw_out_flush(struct Curl_cfilter *cf,
                              struct Curl_easy *data);
 
@@ -348,8 +493,6 @@ static CURLcode cf_h2_update_local_win(struct Curl_cfilter *cf,
                   stream->id, dwsize - wsize);
     }
     else {
-      rv = nghttp2_session_set_local_window_size(ctx->h2, NGHTTP2_FLAG_NONE,
-                                                 stream->id, dwsize);
       if(rv) {
         failf(data, "[%d] nghttp2_session_set_local_window_size() failed: "
               "%s(%d)", stream->id, nghttp2_strerror(rv), rv);
@@ -588,9 +731,21 @@ static CURLcode cf_h2_ctx_open(struct Curl_cfilter *cf,
       goto out;
     }
   }
+  
+  // curl-impersonate:
+  // Directly changing the initial window update using users' settings.
+  int current_window_size = nghttp2_session_get_local_window_size(ctx->h2);
+
+  // Use chrome's value as default
+  int window_update = 15663105;
+  if(data->set.http2_window_update) {
+    window_update = data->set.http2_window_update;
+  }
+
+  rc = nghttp2_session_set_local_window_size(
+      ctx->h2, NGHTTP2_FLAG_NONE, 0,
+      current_window_size + window_update);
 
-  rc = nghttp2_session_set_local_window_size(ctx->h2, NGHTTP2_FLAG_NONE, 0,
-                                             HTTP2_HUGE_WINDOW_SIZE);
   if(rc) {
     failf(data, "nghttp2_session_set_local_window_size() failed: %s(%d)",
           nghttp2_strerror(rc), rc);
@@ -598,6 +753,16 @@ static CURLcode cf_h2_ctx_open(struct Curl_cfilter *cf,
     goto out;
   }
 
+  // curl-impersonate: set stream priorities
+  // No popular browsers are doing this, so it's disabled.
+  // result = http2_set_stream_priorities(cf, data);
+  // if(result)
+  //   goto out;
+
+  // #define FIREFOX_DEFAULT_STREAM_ID   (15)
+  // nghttp2_session_set_next_stream_id(ctx->h2, FIREFOX_DEFAULT_STREAM_ID);
+
+
   /* all set, traffic will be send on connect */
   result = CURLE_OK;
   CURL_TRC_CF(data, cf, "[0] created h2 session%s",
@@ -1911,11 +2076,19 @@ out:
   return result;
 }
 
+/*
+ * curl-impersonate: Use Chrome's default HTTP/2 stream weight
+ * instead of NGINX default stream weight.
+ */
+#define CHROME_DEFAULT_STREAM_WEIGHT    (256)
+#define SAFARI_DEFAULT_STREAM_WEIGHT    (255)
+#define FIREFOX_DEFAULT_STREAM_WEIGHT   (42)
+
 static int sweight_wanted(const struct Curl_easy *data)
 {
   /* 0 weight is not set by user and we take the nghttp2 default one */
   return data->set.priority.weight ?
-    data->set.priority.weight : NGHTTP2_DEFAULT_WEIGHT;
+    data->set.priority.weight : CHROME_DEFAULT_STREAM_WEIGHT;
 }
 
 static int sweight_in_effect(const struct Curl_easy *data)
@@ -1930,6 +2103,12 @@ static int sweight_in_effect(const struct Curl_easy *data)
  * and dependency to the peer. It also stores the updated values in the state
  * struct.
  */
+/*
+ * curl-impersonate: By default Firefox uses stream 13 as the "parent" of the
+ * stream that fetches the main html resource of the web page.
+ */
+#define FIREFOX_DEFAULT_STREAM_DEP  (13)
+
 
 static void h2_pri_spec(struct cf_h2_ctx *ctx,
                         struct Curl_easy *data,
@@ -1938,6 +2117,11 @@ static void h2_pri_spec(struct cf_h2_ctx *ctx,
   struct Curl_data_priority *prio = &data->set.priority;
   struct h2_stream_ctx *depstream = H2_STREAM_CTX(ctx, prio->parent);
   int32_t depstream_id = depstream ? depstream->id : 0;
+  // int32_t depstream_id = depstream? depstream->id:FIREFOX_DEFAULT_STREAM_DEP;
+
+  /* curl-impersonate: Set stream exclusive flag based on user option.
+   * Use data->set, not data->state.
+   */
   nghttp2_priority_spec_init(pri_spec, depstream_id,
                              sweight_wanted(data),
                              data->set.priority.exclusive);
@@ -1957,20 +2141,25 @@ static CURLcode h2_progress_egress(struct Curl_cfilter *cf,
   struct h2_stream_ctx *stream = H2_STREAM_CTX(ctx, data);
   int rv = 0;
 
+  /* curl-impersonate: Check if stream exclusive flag is true. */
   if(stream && stream->id > 0 &&
      ((sweight_wanted(data) != sweight_in_effect(data)) ||
-      (data->set.priority.exclusive != data->state.priority.exclusive) ||
+     (data->set.priority.exclusive != 1) ||
       (data->set.priority.parent != data->state.priority.parent)) ) {
     /* send new weight and/or dependency */
     nghttp2_priority_spec pri_spec;
 
+    // XXX: http2 priority has been deprecated, and not browser sends this frame.
     h2_pri_spec(ctx, data, &pri_spec);
-    CURL_TRC_CF(data, cf, "[%d] Queuing PRIORITY", stream->id);
-    DEBUGASSERT(stream->id != -1);
-    rv = nghttp2_submit_priority(ctx->h2, NGHTTP2_FLAG_NONE,
-                                 stream->id, &pri_spec);
-    if(rv)
-      goto out;
+    /* curl-impersonate: Don't send PRIORITY frames for main stream. */
+    if(stream->id != 1) {
+      CURL_TRC_CF(data, cf, "[%d] Queuing PRIORITY", stream->id);
+      DEBUGASSERT(stream->id != -1);
+      rv = nghttp2_submit_priority(ctx->h2, NGHTTP2_FLAG_NONE,
+                                   stream->id, &pri_spec);
+      if(rv)
+        goto out;
+    }
   }
 
   ctx->nw_out_blocked = 0;
@@ -2267,11 +2456,15 @@ static CURLcode h2_submit(struct h2_stream_ctx **pstream,
   case HTTPREQ_PUT:
     data_prd.read_callback = req_body_read_callback;
     data_prd.source.ptr = NULL;
-    stream_id = nghttp2_submit_request(ctx->h2, &pri_spec, nva, nheader,
+    stream_id = nghttp2_submit_request(ctx->h2,
+                                       data->set.http2_no_priority ? NULL : &pri_spec,
+                                       nva, nheader,
                                        &data_prd, data);
     break;
   default:
-    stream_id = nghttp2_submit_request(ctx->h2, &pri_spec, nva, nheader,
+    stream_id = nghttp2_submit_request(ctx->h2,
+                                       data->set.http2_no_priority ? NULL : &pri_spec,
+                                       nva, nheader,
                                        NULL, data);
   }
 
diff --git a/lib/http2.h b/lib/http2.h
index 93cc2d44f..52e80ce9c 100644
--- a/lib/http2.h
+++ b/lib/http2.h
@@ -31,7 +31,8 @@
 
 /* value for MAX_CONCURRENT_STREAMS we use until we get an updated setting
    from the peer */
-#define DEFAULT_MAX_CONCURRENT_STREAMS 100
+/* curl-impersonate: Use 1000 concurrent streams like Chrome. */
+#define DEFAULT_MAX_CONCURRENT_STREAMS 1000
 
 /*
  * Store nghttp2 version info in this buffer.
diff --git a/lib/impersonate.c b/lib/impersonate.c
new file mode 100644
index 000000000..abe1b8401
--- /dev/null
+++ b/lib/impersonate.c
@@ -0,0 +1,1979 @@
+#include "curl_setup.h"
+
+#include <curl/curl.h>
+
+#include "impersonate.h"
+
+const struct impersonate_opts impersonations[] = {
+  {
+    .target = "chrome100",
+    .alias = "chrome100",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"100\", \"Google Chrome\";v=\"100\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome101",
+    .alias = "chrome101",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"101\", \"Google Chrome\";v=\"101\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome104",
+    .alias = "chrome104",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome107",
+    .alias = "chrome107",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"107\", \"Chromium\";v=\"107\", \"Not=A?Brand\";v=\"24\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome110",
+    .alias = "chrome110",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"110\", \"Not A(Brand\";v=\"24\", \"Google Chrome\";v=\"110\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome116",
+    .alias = "chrome116",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"116\", \"Not)A;Brand\";v=\"24\", \"Google Chrome\";v=\"116\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome119",
+    .alias = "chrome119",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"119\", \"Chromium\";v=\"119\", \"Not?A_Brand\";v=\"24\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "grease",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome120",
+    .alias = "chrome120",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Google Chrome\";v=\"120\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "grease",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome123",
+    .alias = "chrome123",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"123\", \"Not:A-Brand\";v=\"8\", \"Chromium\";v=\"123\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "grease",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome124",
+    .alias = "chrome124",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519Kyber768Draft00:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"124\", \"Google Chrome\";v=\"124\", \"Not-A.Brand\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "grease",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome131",
+    .alias = "chrome131",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"131\", \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "grease",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome131_android",
+    .alias = "chrome131_android",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"131\", \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Android\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Mobile Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "grease",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome133a",
+    .alias = "chrome133a",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Not(A:Brand\";v=\"99\", \"Google Chrome\";v=\"133\", \"Chromium\";v=\"133\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "grease",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = true,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome136",
+    .alias = "chrome136",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", \"Not.A/Brand\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "grease",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = true,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome142",
+    .alias = "chrome142",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"142\", \"Google Chrome\";v=\"142\", \"Not_A Brand\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "grease",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = true,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome99",
+    .alias = "chrome99",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"99\", \"Google Chrome\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "chrome99_android",
+    .alias = "chrome99_android",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"99\", \"Google Chrome\";v=\"99\"",
+      "sec-ch-ua-mobile: ?1",
+      "sec-ch-ua-platform: \"Android\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Linux; Android 12; Pixel 6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.58 Mobile Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "edge101",
+    .alias = "edge101",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"101\", \"Microsoft Edge\";v=\"101\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36 Edg/101.0.1210.47",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "edge99",
+    .alias = "edge99",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"99\", \"Microsoft Edge\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Edg/99.0.1150.30",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "firefox133",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:133.0) Gecko/20100101 Firefox/133.0",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-US,en;q=0.5",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Upgrade-Insecure-Requests: 1",
+      "Sec-Fetch-Dest: document",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-User: ?1",
+      "Priority: u=0, i",
+      "Te: trailers"
+    },
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521:ffdhe2048:ffdhe3072",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_secp521r1_sha512:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha256:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pkcs1_sha512:"
+      "ecdsa_sha1:"
+      "rsa_pkcs1_sha1",
+    .alpn = true,
+    .http2_settings = "1:65536;2:0;4:131072;5:16384",
+    .http2_window_update = 12517377,
+    .http2_pseudo_headers_order = "mpas",
+    .http2_stream_exclusive = 0,
+    .cert_compression = "zlib,brotli,zstd",
+    .ech = "grease",
+    .tls_session_ticket = true,
+    .tls_extension_order = "0-23-65281-10-11-35-16-5-34-51-43-13-45-28-27-65037",
+    .tls_delegated_credentials = "ecdsa_secp256r1_sha256:ecdsa_secp384r1_sha384:ecdsa_secp521r1_sha512:ecdsa_sha1",
+    .tls_record_size_limit = 4001,
+    .tls_grease = false,
+    .tls_signed_cert_timestamps = false,
+    .tls_key_shares_limit = 3,
+  },
+  {
+    .target = "firefox135",
+    .alias = "firefox135",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-US,en;q=0.5",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Upgrade-Insecure-Requests: 1",
+      "Sec-Fetch-Dest: document",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-User: ?1",
+      "Priority: u=0, i",
+      "Te: trailers"
+    },
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521:ffdhe2048:ffdhe3072",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_secp521r1_sha512:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha256:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pkcs1_sha512:"
+      "ecdsa_sha1:"
+      "rsa_pkcs1_sha1",
+    .alpn = true,
+    .http2_settings = "1:65536;2:0;4:131072;5:16384",
+    .http2_window_update = 12517377,
+    .http2_pseudo_headers_order = "mpas",
+    .http2_stream_exclusive = 0,
+    .cert_compression = "zlib,brotli,zstd",
+    .ech = "grease",
+    .tls_session_ticket = true,
+    .tls_extension_order = "0-23-65281-10-11-35-16-5-34-18-51-43-13-45-28-27-65037",
+    .tls_delegated_credentials = "ecdsa_secp256r1_sha256:ecdsa_secp384r1_sha384:ecdsa_secp521r1_sha512:ecdsa_sha1",
+    .tls_record_size_limit = 4001,
+    .tls_grease = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_key_shares_limit = 3,
+  },
+  {
+    .target = "firefox144",
+    .alias = "firefox144",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/144.0",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-US,en;q=0.5",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Upgrade-Insecure-Requests: 1",
+      "Sec-Fetch-Dest: document",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-User: ?1",
+      "Priority: u=0, i",
+      "Te: trailers"
+    },
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521:ffdhe2048:ffdhe3072",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_secp521r1_sha512:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha256:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pkcs1_sha512:"
+      "ecdsa_sha1:"
+      "rsa_pkcs1_sha1",
+    .alpn = true,
+    .http2_settings = "1:65536;2:0;4:131072;5:16384",
+    .http2_window_update = 12517377,
+    .http2_pseudo_headers_order = "mpas",
+    .http2_stream_exclusive = 0,
+    .http2_stream_weight = 42,
+    .cert_compression = "zlib,brotli,zstd",
+    .ech = "grease",
+    .tls_session_ticket = true,
+    .tls_extension_order = "0-23-65281-10-11-35-16-5-34-18-51-43-13-45-28-27-65037",
+    .tls_delegated_credentials = "ecdsa_secp256r1_sha256:ecdsa_secp384r1_sha384:ecdsa_secp521r1_sha512:ecdsa_sha1",
+    .tls_record_size_limit = 4001,
+    .tls_grease = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_key_shares_limit = 3,
+  },
+  {
+    .target = "okhttp4_android",
+    .alias = "okhttp4", /* not working */
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Sec-Fetch-Site: none",
+      "Accept-Encoding: gzip, deflate, br",
+      "Sec-Fetch-Mode: navigate",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
+      "Accept-Language: en-US,en;q=0.9",
+      "Sec-Fetch-Dest: document"
+    },
+    .http2_settings = "2:0;4:4194304;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari153",
+    .alias = "safari15_3",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA256:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA,",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.3 Safari/605.1.15",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-us",
+      "Accept-Encoding: gzip, deflate, br"
+    },
+    .http2_settings = "4:4194304;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari155",
+    .alias = "safari15_5",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Safari/605.1.15",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-GB,en-US;q=0.9,en;q=0.8",
+      "Accept-Encoding: gzip, deflate, br"
+    },
+    .http2_settings = "4:4194304;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari170",
+    .alias = "safari17_0",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Sec-Fetch-Site: none",
+      "Accept-Encoding: gzip, deflate, br",
+      "Sec-Fetch-Mode: navigate",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
+      "Accept-Language: en-US,en;q=0.9",
+      "Sec-Fetch-Dest: document"
+    },
+    .http2_settings = "2:0;4:4194304;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari172_ios",
+    .alias = "safari17_2_ios",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Sec-Fetch-Site: none",
+      "Accept-Encoding: gzip, deflate, br",
+      "Sec-Fetch-Mode: navigate",
+      "User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1",
+      "Accept-Language: en-US,en;q=0.9",
+      "Sec-Fetch-Dest: document"
+    },
+    .http2_settings = "2:0;4:2097152;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari180",
+    .alias = "safari18_0",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Safari/605.1.15",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;8:1;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari180_ios",
+    .alias = "safari18_0_ios",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 18_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;8:1;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari184",
+    .alias = "safari18_4",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Safari/605.1.15",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari184_ios",
+    .alias = "safari18_4_ios",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 18_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari260",
+    .alias = "safari26_0",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Safari/605.1.15",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br, zstd"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_no_priority = true,
+    .tls_session_ticket = true,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari2601",
+    .alias = "safari26_0_1",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0.1 Safari/605.1.15",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_no_priority = true,
+    .tls_session_ticket = false,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "safari260_ios",
+    .alias = "safari26_0_ios",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 26_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br, zstd"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_no_priority = true,
+    .tls_session_ticket = true,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true
+  },
+  {
+    .target = "tor145",  // tor 14.5, based on firefox 128
+    .alias = "tor145",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:128.0) Gecko/20100101 Firefox/128.0",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-US,en;q=0.5",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Sec-GPC: 1",
+      "Upgrade-Insecure-Requests: 1",
+      "Sec-Fetch-Dest: document",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-User: ?1",
+      "Priority: u=0, i",
+      "Te: trailers"
+    },
+    .curves = "X25519:P-256:P-384:P-521:ffdhe2048:ffdhe3072",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_secp521r1_sha512:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha256:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pkcs1_sha512:"
+      "ecdsa_sha1:"
+      "rsa_pkcs1_sha1",
+    .alpn = true,
+    .http2_settings = "1:65536;2:0;4:131072;5:16384",
+    .http2_window_update = 12517377,
+    .http2_pseudo_headers_order = "mpas",
+    .http2_stream_exclusive = 0,
+    .cert_compression = "zlib,brotli,zstd",
+    .ech = "grease",
+    .tls_session_ticket = true,
+    .tls_extension_order = "0-23-65281-10-11-16-5-34-51-43-13-28-65037",
+    .tls_delegated_credentials = "ecdsa_secp256r1_sha256:ecdsa_secp384r1_sha384:ecdsa_secp521r1_sha512:ecdsa_sha1",
+    .tls_record_size_limit = 16385,
+    .tls_grease = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_key_shares_limit = 2,
+  }
+};
+
+const size_t num_impersonations = sizeof(impersonations) / sizeof(impersonations[0]);
diff --git a/lib/impersonate.h b/lib/impersonate.h
new file mode 100644
index 000000000..9f99612ee
--- /dev/null
+++ b/lib/impersonate.h
@@ -0,0 +1,61 @@
+#ifndef HEADER_CURL_IMPERSONATE_H
+#define HEADER_CURL_IMPERSONATE_H
+
+#define IMPERSONATE_MAX_HEADERS 32
+
+/*
+ * curl-impersonate: Options to be set for each supported target browser.
+ */
+struct impersonate_opts {
+  const char *target;
+  const char *alias;
+  int httpversion;
+  int ssl_version;
+  const char *ciphers;
+  /* Elliptic curves (TLS extension 10).
+   * Passed to CURLOPT_SSL_EC_CURVES */
+  const char *curves;
+  /* Signature hash algorithms (TLS extension 13).
+   * Passed to CURLOPT_SSL_SIG_HASH_ALGS */
+  const char *sig_hash_algs;
+  /* Enable TLS NPN extension. */
+  bool npn;
+  /* Enable TLS ALPN extension. */
+  bool alpn;
+  /* Enable TLS ALPS extension. */
+  bool alps;
+  /* Enable TLS session ticket extension. */
+  bool tls_session_ticket;
+  /* TLS certificate compression algorithms.
+   * (TLS extension 27) */
+  const char *cert_compression;
+  const char *http_headers[IMPERSONATE_MAX_HEADERS];
+  const char *http2_pseudo_headers_order;
+  const char *http2_settings;
+  int http2_window_update;
+  const char *http2_streams;
+  bool tls_permute_extensions;
+  bool tls_use_new_alps_codepoint;
+  bool tls_signed_cert_timestamps;
+  const char *ech;
+  const char *tls_extension_order;
+  const char *tls_delegated_credentials;
+  int tls_record_size_limit;
+  int tls_key_shares_limit;  // for firefox key_shares extension
+  bool tls_grease;
+  int http2_stream_weight;
+  int http2_stream_exclusive;
+  bool http2_no_priority;  // disable http2 priority in header frame
+  bool proxy_credential_no_reuse;  // do not reuse TLS sessions or connections from different proxy credentials
+  /* Other TLS options will come here in the future once they are
+   * configurable through curl_easy_setopt() */
+};
+
+/*
+ * curl-impersonate: Global array of supported browsers and their
+ * impersonation options.
+ */
+extern const struct impersonate_opts impersonations[];
+extern const size_t num_impersonations;
+
+#endif /* HEADER_CURL_IMPERSONATE_H */
diff --git a/lib/libcurl.def b/lib/libcurl.def
index 43e26f655..8537a108e 100644
--- a/lib/libcurl.def
+++ b/lib/libcurl.def
@@ -5,6 +5,7 @@ curl_easy_escape
 curl_easy_getinfo
 curl_easy_header
 curl_easy_init
+curl_easy_impersonate
 curl_easy_nextheader
 curl_easy_option_by_id
 curl_easy_option_by_name
diff --git a/lib/multi.c b/lib/multi.c
index b3a7938e3..5da6f894e 100644
--- a/lib/multi.c
+++ b/lib/multi.c
@@ -243,7 +243,8 @@ struct Curl_multi *Curl_multi_handle(unsigned int xfer_table_size,
   Curl_llist_init(&multi->msglist, NULL);
 
   multi->multiplexing = TRUE;
-  multi->max_concurrent_streams = 100;
+  /* curl-impersonate: Use 1000 concurrent streams like Chrome. */
+  multi->max_concurrent_streams = 1000;
   multi->last_timeout_ms = -1;
 
   if(Curl_uint_bset_resize(&multi->process, xfer_table_size) ||
diff --git a/lib/setopt.c b/lib/setopt.c
index 1380c33db..128c13787 100644
--- a/lib/setopt.c
+++ b/lib/setopt.c
@@ -52,6 +52,7 @@
 #include "altsvc.h"
 #include "hsts.h"
 #include "tftp.h"
+#include "slist.h"
 #include "strdup.h"
 #include "escape.h"
 
@@ -747,6 +748,12 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
   case CURLOPT_HTTP_VERSION:
     return setopt_HTTP_VERSION(data, arg);
 
+#ifdef USE_HTTP2
+  case CURLOPT_STREAM_EXCLUSIVE:
+    data->set.priority.exclusive = (int)arg;
+    break;
+#endif
+
   case CURLOPT_EXPECT_100_TIMEOUT_MS:
     /*
      * Time to wait for a response to an HTTP request containing an
@@ -834,6 +841,9 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
     /* Update the current connection proxy_ssl_config. */
     Curl_ssl_conn_config_update(data, TRUE);
     break;
+  case CURLOPT_PROXY_CREDENTIAL_NO_REUSE:
+    data->set.proxy_credential_no_reuse = enabled;
+    break;
 #endif /* ! CURL_DISABLE_PROXY */
 
 #if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
@@ -1334,6 +1344,38 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
   case CURLOPT_SSL_ENABLE_ALPN:
     data->set.ssl_enable_alpn = enabled;
     break;
+  case CURLOPT_SSL_ENABLE_ALPS:
+    data->set.ssl_enable_alps = enabled;
+    break;
+  case CURLOPT_SSL_ENABLE_TICKET:
+    data->set.ssl_enable_ticket = enabled;
+    break;
+  case CURLOPT_SSL_PERMUTE_EXTENSIONS:
+    data->set.ssl_permute_extensions = enabled;
+    break;
+  case CURLOPT_TLS_GREASE:
+    data->set.tls_grease = enabled;
+    break;
+  case CURLOPT_TLS_KEY_USAGE_NO_CHECK:
+    data->set.tls_key_usage_no_check = enabled;
+    break;
+  case CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS:
+    data->set.tls_signed_cert_timestamps = enabled;
+    break;
+  case CURLOPT_TLS_STATUS_REQUEST:
+    data->set.tls_status_request = enabled;
+    break;
+
+#ifdef USE_HTTP2
+  case CURLOPT_HTTP2_WINDOW_UPDATE:
+    if(arg < -1)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    data->set.http2_window_update = arg;
+    break;
+  case CURLOPT_HTTP2_NO_PRIORITY:
+    data->set.http2_no_priority = arg;
+    break;
+#endif
   case CURLOPT_PATH_AS_IS:
     data->set.path_as_is = enabled;
     break;
@@ -1370,9 +1412,17 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
     break;
   case CURLOPT_MAXAGE_CONN:
     return setopt_set_timeout_sec(&data->set.conn_max_idle_ms, arg);
-
   case CURLOPT_MAXLIFETIME_CONN:
     return setopt_set_timeout_sec(&data->set.conn_max_age_ms, arg);
+  case CURLOPT_TLS_RECORD_SIZE_LIMIT:
+    data->set.tls_record_size_limit = arg;
+    break;
+  case CURLOPT_TLS_KEY_SHARES_LIMIT:
+    data->set.tls_key_shares_limit = arg;
+    break;
+  case CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT:
+    data->set.tls_use_new_alps_codepoint = enabled;
+    break;
 
 #ifndef CURL_DISABLE_HSTS
   case CURLOPT_HSTS_CTRL:
@@ -1500,6 +1550,21 @@ static CURLcode setopt_slist(struct Curl_easy *data, CURLoption option,
      */
     data->set.headers = slist;
     break;
+  case CURLOPT_HTTPBASEHEADER:
+    /*
+     * curl-impersonate:
+     * Set a list of "base" headers. These will be merged with any headers
+     * set by CURLOPT_HTTPHEADER. curl-impersonate uses this option in order
+     * to set a list of default browser headers.
+     *
+     * Unlike CURLOPT_HTTPHEADER,
+     * the list is copied and can be immediately freed by the user.
+     */
+    curl_slist_free_all(data->state.base_headers);
+    data->state.base_headers = Curl_slist_duplicate(slist);
+    if (!data->state.base_headers)
+      result = CURLE_OUT_OF_MEMORY;
+    break;
 #endif
 #ifndef CURL_DISABLE_TELNET
   case CURLOPT_TELNETOPTIONS:
@@ -1689,6 +1754,46 @@ static CURLcode setopt_cptr(struct Curl_easy *data, CURLoption option,
     }
     else
       return CURLE_NOT_BUILT_IN;
+  // curl-impersonate
+  case CURLOPT_IMPERSONATE:
+    result = Curl_setstropt(&data->set.str[STRING_IMPERSONATE], ptr);
+    if(result)
+      return result;
+    // for the master option, we simply call the easy_impersonate method here.
+    return curl_easy_impersonate(data, data->set.str[STRING_IMPERSONATE], true);
+    break;
+  case CURLOPT_TLS_EXTENSION_ORDER:
+    return Curl_setstropt(&data->set.str[STRING_TLS_EXTENSION_ORDER], ptr);
+    break;
+  case CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER:
+    return Curl_setstropt(&data->set.str[STRING_HTTP2_PSEUDO_HEADERS_ORDER], ptr);
+    break;
+  case CURLOPT_HTTP2_SETTINGS:
+    return Curl_setstropt(&data->set.str[STRING_HTTP2_SETTINGS], ptr);
+    break;
+  case CURLOPT_HTTP2_STREAMS:
+    return Curl_setstropt(&data->set.str[STRING_HTTP2_STREAMS], ptr);
+    break;
+  case CURLOPT_SSL_SIG_HASH_ALGS:
+    /*
+     * Set the list of hash algorithms we want to use in the SSL connection.
+     * Specify comma-delimited list of algorithms to use.
+     */
+    return Curl_setstropt(&data->set.str[STRING_SSL_SIG_HASH_ALGS], ptr);
+    break;
+  case CURLOPT_SSL_CERT_COMPRESSION:
+    /*
+     * Set the list of ceritifcate compression algorithms we support in the TLS
+     * connection.
+     * Specify comma-delimited list of algorithms to use. Options are "zlib"
+     * and "brotli".
+     */
+    return Curl_setstropt(&data->set.str[STRING_SSL_CERT_COMPRESSION], ptr);
+    break;
+  case CURLOPT_TLS_DELEGATED_CREDENTIALS:
+    return Curl_setstropt(&data->set.str[STRING_TLS_DELEGATED_CREDENTIALS], ptr);
+    break;
+
 #ifndef CURL_DISABLE_PROXY
   case CURLOPT_PROXY_TLS13_CIPHERS:
     if(Curl_ssl_supports(data, SSLSUPP_TLS13_CIPHERSUITES))
@@ -3039,6 +3144,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
        way than being listed explicitly */
     switch(option) {
     case CURLOPT_HTTPHEADER:
+    case CURLOPT_HTTPBASEHEADER:
     case CURLOPT_QUOTE:
     case CURLOPT_POSTQUOTE:
     case CURLOPT_TELNETOPTIONS:
diff --git a/lib/socks.c b/lib/socks.c
index 7d25ef520..fa3fe86f1 100644
--- a/lib/socks.c
+++ b/lib/socks.c
@@ -38,10 +38,16 @@
 #include "select.h"
 #include "cfilters.h"
 #include "connect.h"
+#include "cf-socket.h"
+#if defined(USE_NGTCP2) && defined(USE_NGHTTP3)
+#include "vquic/curl_ngtcp2.h"
+#endif
 #include "curlx/timeval.h"
 #include "socks.h"
 #include "multiif.h" /* for getsock macros */
+#include "curl_addrinfo.h"
 #include "curlx/inet_pton.h"
+#include "curlx/inet_ntop.h"
 #include "url.h"
 
 /* The last 3 #include files should be in this order */
@@ -71,6 +77,17 @@ enum connect_t {
   CONNECT_DONE /* 17 connected fine to the remote or the SOCKS proxy */
 };
 
+enum socks5_atyp {
+  SOCKS5_ATYP_IPV4 = 1,
+  SOCKS5_ATYP_DOMAIN = 3,
+  SOCKS5_ATYP_IPV6 = 4
+};
+
+#define SOCKS5_REPLY_HEADER_LEN 4
+#define SOCKS5_PORT_LEN 2
+#define SOCKS5_IPV4_ADDR_LEN 4
+#define SOCKS5_IPV6_ADDR_LEN 16
+
 #define CURL_SOCKS_BUF_SIZE 600
 
 /* make sure we configure it not too low */
@@ -89,6 +106,25 @@ struct socks_state {
   int remote_port;
   const char *proxy_user;
   const char *proxy_password;
+
+  // See more in RFC 1928
+  size_t replylen;                  /* SOCKS5 reply length to read after fixed header */
+  struct Curl_cfilter *tcp_cf;      /* TCP control channel to the SOCKS proxy for UDP */
+  struct Curl_cfilter *udp_cf;      /* UDP data relay channel to the SOCKS proxy */
+
+  unsigned char udp_relay_addr[16]; /* relay address, port and family */
+  int udp_relay_port;
+  int udp_relay_family;
+  int udp_dest_atyp;                /* SOCKS5 ATYP for UDP destination */
+  unsigned char udp_dest_addr[16];  /* QUIC destination address, port and family */
+  int udp_dest_port;
+  int udp_dest_family;
+  unsigned char udp_dest_domain[256];
+  size_t udp_dest_domain_len;
+  struct Curl_sockaddr_ex udp_peer_addr;
+  BIT(udp_peer_set);
+  BIT(udp_associate);               /* use SOCKS5 UDP ASSOCIATE instead of CONNECT */
+  BIT(udp_dest_set);                /* QUIC destination cached for UDP headers */
 };
 
 #if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
@@ -257,6 +293,61 @@ static CURLproxycode socks_state_recv(struct Curl_cfilter *cf,
   return CURLPX_OK;
 }
 
+/* curl-impersonate: set up udp relay
+ * Parse the address in reply and store the relay address/port in socks_state.
+ */
+static CURLproxycode socks5_set_udp_relay(struct socks_state *sx,
+                                          struct Curl_easy *data)
+{
+  const unsigned char *socksreq = sx->buffer;
+  const unsigned char *addrp =
+    &socksreq[SOCKS5_REPLY_HEADER_LEN]; /* First bytes are VER, REP, RSV, ATYP */
+  size_t addrlen;
+  int atyp = socksreq[3]; /* ATYP from SOCKS5 reply */
+
+  if(sx->replylen < (SOCKS5_REPLY_HEADER_LEN + SOCKS5_PORT_LEN)) {
+    failf(data, "SOCKS5 UDP associate reply too short");
+    return CURLPX_BAD_ADDRESS_TYPE;
+  }
+
+  switch(atyp) {
+    case SOCKS5_ATYP_IPV4:
+      addrlen = SOCKS5_IPV4_ADDR_LEN;
+      sx->udp_relay_family = AF_INET;
+      break;
+#ifdef USE_IPV6
+    case SOCKS5_ATYP_IPV6:
+      addrlen = SOCKS5_IPV6_ADDR_LEN;
+      sx->udp_relay_family = AF_INET6;
+      break;
+#endif
+    case SOCKS5_ATYP_DOMAIN:
+    default:
+      failf(data, "SOCKS5 UDP associate reply has wrong address type.");
+      return CURLPX_BAD_ADDRESS_TYPE;
+  }
+
+  if(SOCKS5_REPLY_HEADER_LEN + addrlen + SOCKS5_PORT_LEN > sx->replylen) {
+    failf(data, "SOCKS5 UDP associate reply truncated");
+    return CURLPX_BAD_ADDRESS_TYPE;
+  }
+
+  memcpy(sx->udp_relay_addr, addrp, addrlen);
+  /* Port is in network byte order in the last two bytes. */
+  sx->udp_relay_port = (int)((addrp[addrlen] << 8) | addrp[addrlen + 1]);
+
+  /* Log the udp relay info */
+  {
+    char addrstr[MAX_IPADR_LEN] = "";
+    if(!curlx_inet_ntop(sx->udp_relay_family, sx->udp_relay_addr,
+                        addrstr, sizeof(addrstr)))
+      strcpy(addrstr, "unknown");
+    infof(data, "SOCKS5 UDP relay reply ATYP=%d BND.ADDR=%s BND.PORT=%d",
+          atyp, addrstr, sx->udp_relay_port);
+  }
+  return CURLPX_OK;
+}
+
 /*
 * This function logs in to a SOCKS4 proxy and sends the specifics to the final
 * destination server.
@@ -769,6 +860,22 @@ CONNECT_AUTH_INIT:
     FALLTHROUGH();
   case CONNECT_REQ_INIT:
 CONNECT_REQ_INIT:
+    /* curl-impersonate: init the UDP associate req by resolving DNS */
+    if(sx->udp_associate) {
+      if(!socks5_resolve_local)
+        goto CONNECT_RESOLVE_REMOTE;
+      result = Curl_resolv(data, sx->hostname, sx->remote_port,
+                           cf->conn->ip_version, TRUE, &dns);
+
+      if(result == CURLE_AGAIN) {
+        sxstate(sx, data, CONNECT_RESOLVING);
+        return CURLPX_OK;
+      }
+      else if(result)
+        return CURLPX_RESOLVE_HOST;
+      sxstate(sx, data, CONNECT_RESOLVED);
+      goto CONNECT_RESOLVED;
+    }
     if(socks5_resolve_local) {
       result = Curl_resolv(data, sx->hostname, sx->remote_port,
                            cf->conn->ip_version, TRUE, &dns);
@@ -819,12 +926,86 @@ CONNECT_RESOLVED:
 
     len = 0;
     socksreq[len++] = 5; /* version (SOCKS5) */
-    socksreq[len++] = 1; /* connect */
+    socksreq[len++] = sx->udp_associate ? 3 : 1; /* associate: 0x03, connect: 0x01 */
     socksreq[len++] = 0; /* must be zero */
+    if(sx->udp_associate) {
+      if(hp->ai_family == AF_INET) {
+        struct sockaddr_in *saddr_in;
+        saddr_in = (struct sockaddr_in *)(void *)hp->ai_addr;
+        memcpy(sx->udp_dest_addr, &saddr_in->sin_addr, sizeof(struct in_addr));
+        sx->udp_dest_family = AF_INET;
+        sx->udp_dest_atyp = SOCKS5_ATYP_IPV4;
+      }
+#ifdef USE_IPV6
+      else if(hp->ai_family == AF_INET6) {
+        struct sockaddr_in6 *saddr_in6;
+        saddr_in6 = (struct sockaddr_in6 *)(void *)hp->ai_addr;
+        memcpy(sx->udp_dest_addr, &saddr_in6->sin6_addr,
+               sizeof(struct in6_addr));
+        sx->udp_dest_family = AF_INET6;
+        sx->udp_dest_atyp = SOCKS5_ATYP_IPV6;
+      }
+#endif
+      else {
+        failf(data, "SOCKS5 UDP associate to %s not supported", dest);
+        return CURLPX_BAD_ADDRESS_TYPE;
+      }
+      sx->udp_dest_port = sx->remote_port;
+      sx->udp_dest_set = TRUE;
+      if(sx->udp_dest_atyp == SOCKS5_ATYP_IPV4 ||
+         sx->udp_dest_atyp == SOCKS5_ATYP_IPV6) {
+        memset(&sx->udp_peer_addr, 0, sizeof(sx->udp_peer_addr));
+        if(sx->udp_dest_atyp == SOCKS5_ATYP_IPV4) {
+          struct sockaddr_in *sa =
+            (struct sockaddr_in *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+          sa->sin_family = AF_INET;
+          memcpy(&sa->sin_addr, sx->udp_dest_addr, sizeof(struct in_addr));
+          sa->sin_port = htons((unsigned short)sx->udp_dest_port);
+          sx->udp_peer_addr.family = AF_INET;
+          sx->udp_peer_addr.socktype = SOCK_DGRAM;
+          sx->udp_peer_addr.protocol = IPPROTO_UDP;
+          sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in);
+          sx->udp_peer_set = TRUE;
+        }
+#ifdef USE_IPV6
+        else {
+          struct sockaddr_in6 *sa6 =
+            (struct sockaddr_in6 *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+          sa6->sin6_family = AF_INET6;
+          memcpy(&sa6->sin6_addr, sx->udp_dest_addr, sizeof(struct in6_addr));
+          sa6->sin6_port = htons((unsigned short)sx->udp_dest_port);
+          sx->udp_peer_addr.family = AF_INET6;
+          sx->udp_peer_addr.socktype = SOCK_DGRAM;
+          sx->udp_peer_addr.protocol = IPPROTO_UDP;
+          sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in6);
+          sx->udp_peer_set = TRUE;
+        }
+#endif
+      }
+
+      infof(data, "SOCKS5 UDP associate storing target %s:%d for UDP header",
+            dest, sx->udp_dest_port);
+
+      if(sx->udp_dest_family == AF_INET6) {
+        socksreq[len++] = SOCKS5_ATYP_IPV6;
+        memset(&socksreq[len], 0, SOCKS5_IPV6_ADDR_LEN);
+        len += SOCKS5_IPV6_ADDR_LEN;
+      }
+      else {
+        socksreq[len++] = SOCKS5_ATYP_IPV4;
+        memset(&socksreq[len], 0, SOCKS5_IPV4_ADDR_LEN);
+        len += SOCKS5_IPV4_ADDR_LEN;
+      }
+
+      infof(data, "SOCKS5 UDP associate to %s:%d (locally resolved)", dest,
+            sx->remote_port);
+      Curl_resolv_unlink(data, &dns); /* not used anymore from now on */
+      goto CONNECT_REQ_SEND;
+    }
     if(hp->ai_family == AF_INET) {
       int i;
       struct sockaddr_in *saddr_in;
-      socksreq[len++] = 1; /* ATYP: IPv4 = 1 */
+      socksreq[len++] = SOCKS5_ATYP_IPV4;
 
       saddr_in = (struct sockaddr_in *)(void *)hp->ai_addr;
       for(i = 0; i < 4; i++) {
@@ -838,7 +1019,7 @@ CONNECT_RESOLVED:
     else if(hp->ai_family == AF_INET6) {
       int i;
       struct sockaddr_in6 *saddr_in6;
-      socksreq[len++] = 4; /* ATYP: IPv6 = 4 */
+      socksreq[len++] = SOCKS5_ATYP_IPV6;
 
       saddr_in6 = (struct sockaddr_in6 *)(void *)hp->ai_addr;
       for(i = 0; i < 16; i++) {
@@ -863,9 +1044,82 @@ CONNECT_RESOLVE_REMOTE:
     /* Authentication is complete, now specify destination to the proxy */
     len = 0;
     socksreq[len++] = 5; /* version (SOCKS5) */
-    socksreq[len++] = 1; /* connect */
+    socksreq[len++] = sx->udp_associate ? 3 : 1; /* associate: 0x03, connect: 0x01 */
     socksreq[len++] = 0; /* must be zero */
 
+    if(sx->udp_associate) {
+      unsigned char ip4[4];
+#ifdef USE_IPV6
+      char ip6[16];
+#endif
+      if(hostname_len > 255) {
+        failf(data, "SOCKS5: the destination hostname is too long to be "
+              "resolved remotely by the proxy.");
+        return CURLPX_LONG_HOSTNAME;
+      }
+      /* Cache target port up front so cached peer info uses the right value. */
+      sx->udp_dest_port = sx->remote_port;
+      if(1 == curlx_inet_pton(AF_INET, sx->hostname, ip4)) {
+        memcpy(sx->udp_dest_addr, ip4, sizeof(ip4));
+        sx->udp_dest_family = AF_INET;
+        sx->udp_dest_atyp = SOCKS5_ATYP_IPV4;
+        memset(&sx->udp_peer_addr, 0, sizeof(sx->udp_peer_addr));
+        {
+          struct sockaddr_in *sa =
+            (struct sockaddr_in *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+          sa->sin_family = AF_INET;
+          memcpy(&sa->sin_addr, sx->udp_dest_addr, sizeof(struct in_addr));
+          sa->sin_port = htons((unsigned short)sx->udp_dest_port);
+          sx->udp_peer_addr.family = AF_INET;
+          sx->udp_peer_addr.socktype = SOCK_DGRAM;
+          sx->udp_peer_addr.protocol = IPPROTO_UDP;
+          sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in);
+          sx->udp_peer_set = TRUE;
+        }
+      }
+#ifdef USE_IPV6
+      else if(1 == curlx_inet_pton(AF_INET6, sx->hostname, ip6)) {
+        memcpy(sx->udp_dest_addr, ip6, sizeof(ip6));
+        sx->udp_dest_family = AF_INET6;
+        sx->udp_dest_atyp = SOCKS5_ATYP_IPV6;
+        memset(&sx->udp_peer_addr, 0, sizeof(sx->udp_peer_addr));
+        {
+          struct sockaddr_in6 *sa6 =
+            (struct sockaddr_in6 *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+          sa6->sin6_family = AF_INET6;
+          memcpy(&sa6->sin6_addr, sx->udp_dest_addr, sizeof(struct in6_addr));
+          sa6->sin6_port = htons((unsigned short)sx->udp_dest_port);
+          sx->udp_peer_addr.family = AF_INET6;
+          sx->udp_peer_addr.socktype = SOCK_DGRAM;
+          sx->udp_peer_addr.protocol = IPPROTO_UDP;
+          sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in6);
+          sx->udp_peer_set = TRUE;
+        }
+      }
+#endif
+      else {
+        sx->udp_dest_atyp = SOCKS5_ATYP_DOMAIN;
+        memcpy(sx->udp_dest_domain, sx->hostname, hostname_len);
+        sx->udp_dest_domain_len = hostname_len;
+      }
+      sx->udp_dest_set = TRUE;
+
+      if(data->set.ipver == CURL_IPRESOLVE_V6) {
+        socksreq[len++] = SOCKS5_ATYP_IPV6;
+        memset(&socksreq[len], 0, 16);
+        len += 16;
+      }
+      else {
+        socksreq[len++] = SOCKS5_ATYP_IPV4;
+        memset(&socksreq[len], 0, 4);
+        len += 4;
+      }
+
+      infof(data, "SOCKS5 UDP associate to %s:%d (remotely resolved)",
+            sx->hostname, sx->remote_port);
+      goto CONNECT_REQ_SEND;
+    }
+
     if(!socks5_resolve_local) {
       /* ATYP: domain name = 3,
          IPv6 == 4,
@@ -876,19 +1130,19 @@ CONNECT_RESOLVE_REMOTE:
         char ip6[16];
         if(1 != curlx_inet_pton(AF_INET6, sx->hostname, ip6))
           return CURLPX_BAD_ADDRESS_TYPE;
-        socksreq[len++] = 4;
+        socksreq[len++] = SOCKS5_ATYP_IPV6;
         memcpy(&socksreq[len], ip6, sizeof(ip6));
         len += sizeof(ip6);
       }
       else
 #endif
       if(1 == curlx_inet_pton(AF_INET, sx->hostname, ip4)) {
-        socksreq[len++] = 1;
+        socksreq[len++] = SOCKS5_ATYP_IPV4;
         memcpy(&socksreq[len], ip4, sizeof(ip4));
         len += sizeof(ip4);
       }
       else {
-        socksreq[len++] = 3;
+        socksreq[len++] = SOCKS5_ATYP_DOMAIN;
         socksreq[len++] = (unsigned char) hostname_len; /* one byte length */
         memcpy(&socksreq[len], sx->hostname, hostname_len); /* w/o NULL */
         len += hostname_len;
@@ -900,10 +1154,15 @@ CONNECT_RESOLVE_REMOTE:
 
   case CONNECT_REQ_SEND:
 CONNECT_REQ_SEND:
-    /* PORT MSB */
-    socksreq[len++] = (unsigned char)((sx->remote_port >> 8) & 0xff);
-    /* PORT LSB */
-    socksreq[len++] = (unsigned char)(sx->remote_port & 0xff);
+    {
+      int reqport = sx->udp_associate ? 0 : sx->remote_port;
+      if(sx->udp_associate)
+        infof(data, "SOCKS5 UDP associate request uses port 0 per RFC");
+      /* PORT MSB */
+      socksreq[len++] = (unsigned char)((reqport >> 8) & 0xff);
+      /* PORT LSB */
+      socksreq[len++] = (unsigned char)(reqport & 0xff);
+    }
 
 #if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
     if(conn->socks5_gssapi_enctype) {
@@ -1005,6 +1264,8 @@ CONNECT_REQ_SEND:
       failf(data, "SOCKS5 reply has wrong address type.");
       return CURLPX_BAD_ADDRESS_TYPE;
     }
+    // curl-impersonate: useful for udp only
+    sx->replylen = len;
 
     /* At this point we already read first 10 bytes */
 #if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
@@ -1036,11 +1297,98 @@ CONNECT_REQ_SEND:
     }
     sxstate(sx, data, CONNECT_DONE);
   }
+  if(sx->udp_associate && !sx->udp_relay_family) {
+    presult = socks5_set_udp_relay(sx, data);
+    if(CURLPX_OK != presult)
+      return presult;
+    infof(data, "SOCKS5 UDP associate relay established");
+  }
   infof(data, "SOCKS5 request granted.");
 
   return CURLPX_OK; /* Proxy was successful! */
 }
 
+static void socks_proxy_discard_tcp(struct socks_state *sx,
+                                    struct Curl_easy *data)
+{
+  if(sx && sx->tcp_cf) {
+    sx->tcp_cf->cft->do_close(sx->tcp_cf, data);
+    Curl_conn_cf_discard_chain(&sx->tcp_cf, data);
+  }
+}
+
+static CURLcode socks_proxy_cf_udp_create(struct Curl_cfilter *cf,
+                                          struct socks_state *sx,
+                                          struct Curl_easy *data)
+{
+  struct Curl_cfilter *udp_cf = NULL;
+  struct Curl_cfilter *tcp_cf = sx->tcp_cf ? sx->tcp_cf : cf->next;
+  struct Curl_addrinfo *ai = NULL;
+  CURLcode result;
+  char addrbuf[MAX_IPADR_LEN];
+  /* QUIC needs a connected UDP socket when using UDP ASSOCIATE. */
+  int transport = sx->udp_associate ? TRNSPRT_QUIC : TRNSPRT_UDP;
+  size_t addrlen;
+  bool relay_zero = TRUE;
+
+  if(!sx->udp_relay_family || !sx->udp_relay_port)
+    return CURLE_FAILED_INIT;
+  infof(data, "SOCKS5 UDP associate relay port=%d family=%s",
+        sx->udp_relay_port,
+        (sx->udp_relay_family == AF_INET6) ? "IPv6" : "IPv4");
+  addrlen = (sx->udp_relay_family == AF_INET6) ? 16 : 4;
+  for(size_t i = 0; i < addrlen; ++i) {
+    if(sx->udp_relay_addr[i]) {
+      relay_zero = FALSE;
+      break;
+    }
+  }
+  /* If the relay address is 0.0.0.0/::, reuse the proxy's TCP peer. */
+  if(relay_zero && tcp_cf) {
+    const struct Curl_sockaddr_ex *peer_addr = NULL;
+    if(!Curl_cf_socket_peek(tcp_cf, data, NULL, &peer_addr, NULL) &&
+       peer_addr) {
+      if(peer_addr->family == AF_INET) {
+        struct sockaddr_in *saddr_in =
+          (struct sockaddr_in *)(void *)&peer_addr->curl_sa_addr;
+        memcpy(sx->udp_relay_addr, &saddr_in->sin_addr,
+               sizeof(struct in_addr));
+        sx->udp_relay_family = AF_INET;
+      }
+#ifdef USE_IPV6
+      else if(peer_addr->family == AF_INET6) {
+        struct sockaddr_in6 *saddr_in6 =
+          (struct sockaddr_in6 *)(void *)&peer_addr->curl_sa_addr;
+        memcpy(sx->udp_relay_addr, &saddr_in6->sin6_addr,
+               sizeof(struct in6_addr));
+        sx->udp_relay_family = AF_INET6;
+      }
+#endif
+    }
+    infof(data, "SOCKS5 UDP relay address was zero; using proxy host address");
+  }
+  if(!curlx_inet_ntop(sx->udp_relay_family, sx->udp_relay_addr,
+                      addrbuf, sizeof(addrbuf)))
+    return CURLE_FAILED_INIT;
+
+  ai = Curl_ip2addr(sx->udp_relay_family, sx->udp_relay_addr,
+                    addrbuf, sx->udp_relay_port);
+  if(!ai)
+    return CURLE_OUT_OF_MEMORY;
+
+  result = Curl_cf_udp_create(&udp_cf, data, cf->conn, ai, transport);
+  Curl_freeaddrinfo(ai);
+  if(result)
+    return result;
+
+  udp_cf->conn = cf->conn;
+  udp_cf->sockindex = cf->sockindex;
+  sx->udp_cf = udp_cf;
+  infof(data, "SOCKS5 UDP relay socket prepared for %s:%d",
+        addrbuf, sx->udp_relay_port);
+  return CURLE_OK;
+}
+
 static CURLcode connect_SOCKS(struct Curl_cfilter *cf,
                               struct socks_state *sxstate,
                               struct Curl_easy *data)
@@ -1049,6 +1397,14 @@ static CURLcode connect_SOCKS(struct Curl_cfilter *cf,
   CURLproxycode pxresult = CURLPX_OK;
   struct connectdata *conn = cf->conn;
 
+  if(sxstate->udp_associate &&
+     conn->socks_proxy.proxytype != CURLPROXY_SOCKS5 &&
+     conn->socks_proxy.proxytype != CURLPROXY_SOCKS5_HOSTNAME) {
+    failf(data, "SOCKS: UDP associate only supported with SOCKS5");
+    data->info.pxcode = CURLPX_REPLY_COMMAND_NOT_SUPPORTED;
+    return CURLE_PROXY;
+  }
+
   switch(conn->socks_proxy.proxytype) {
   case CURLPROXY_SOCKS5:
   case CURLPROXY_SOCKS5_HOSTNAME:
@@ -1072,10 +1428,12 @@ static CURLcode connect_SOCKS(struct Curl_cfilter *cf,
   return result;
 }
 
-static void socks_proxy_cf_free(struct Curl_cfilter *cf)
+static void socks_proxy_cf_free(struct Curl_cfilter *cf,
+                                struct Curl_easy *data)
 {
   struct socks_state *sxstate = cf->ctx;
   if(sxstate) {
+    socks_proxy_discard_tcp(sxstate, data);
     free(sxstate);
     cf->ctx = NULL;
   }
@@ -1096,13 +1454,19 @@ static CURLcode socks_proxy_cf_connect(struct Curl_cfilter *cf,
   struct connectdata *conn = cf->conn;
   int sockindex = cf->sockindex;
   struct socks_state *sx = cf->ctx;
+  struct Curl_cfilter *tcp_cf = NULL;
 
   if(cf->connected) {
     *done = TRUE;
     return CURLE_OK;
   }
 
-  result = cf->next->cft->do_connect(cf->next, data, done);
+  if(sx && sx->tcp_cf)
+    tcp_cf = sx->tcp_cf;
+  else
+    tcp_cf = cf->next;
+
+  result = tcp_cf->cft->do_connect(tcp_cf, data, done);
   if(result || !*done)
     return result;
 
@@ -1132,19 +1496,250 @@ static CURLcode socks_proxy_cf_connect(struct Curl_cfilter *cf,
       conn->remote_port;
     sx->proxy_user = conn->socks_proxy.user;
     sx->proxy_password = conn->socks_proxy.passwd;
+    /* Use UDP associate for explicit HTTP/3-only or QUIC transport. */
+    sx->udp_associate =
+      (conn->transport_wanted == TRNSPRT_QUIC) ||
+      (data->state.http_neg.wanted == CURL_HTTP_V3x);
+    if(sx->udp_associate)
+      infof(data, "SOCKS5 UDP associate starting for HTTP/3 target");
   }
 
   result = connect_SOCKS(cf, sx, data);
   if(!result && sx->state == CONNECT_DONE) {
+    if(sx->udp_associate) {
+      if(!sx->udp_cf) {
+        result = socks_proxy_cf_udp_create(cf, sx, data);
+        if(result)
+          return result;
+        /* Keep TCP control channel and switch data path to UDP relay. */
+        sx->tcp_cf = cf->next;
+        cf->next = sx->udp_cf;
+        infof(data, "SOCKS5 UDP associate switching to UDP relay socket");
+      }
+      result = sx->udp_cf->cft->do_connect(sx->udp_cf, data, done);
+      if(result || !*done)
+        return result;
+    }
     cf->connected = TRUE;
     Curl_verboseconnect(data, conn, cf->sockindex);
-    socks_proxy_cf_free(cf);
+    if(!sx->udp_associate)
+      socks_proxy_cf_free(cf, data);
   }
 
   *done = cf->connected;
   return result;
 }
 
+static CURLcode socks_proxy_cf_send(struct Curl_cfilter *cf,
+                                    struct Curl_easy *data,
+                                    const void *buf, size_t len, bool eos,
+                                    size_t *pnwritten)
+{
+  struct socks_state *sx = cf->ctx;
+
+  if(sx && sx->udp_associate && sx->udp_cf) {
+    /* Wrap outgoing QUIC datagrams in SOCKS5 UDP headers. */
+    size_t header_len;
+    size_t addrlen;
+    size_t nwritten = 0;
+    unsigned char atyp;
+    unsigned char *packet;
+    CURLcode result;
+
+    *pnwritten = 0;
+    if(!sx->udp_dest_set)
+      return CURLE_SEND_ERROR;
+
+    switch(sx->udp_dest_atyp) {
+    case SOCKS5_ATYP_IPV6:
+      addrlen = SOCKS5_IPV6_ADDR_LEN;
+      atyp = SOCKS5_ATYP_IPV6;
+      break;
+    case SOCKS5_ATYP_DOMAIN:
+      if(!sx->udp_dest_domain_len)
+        return CURLE_SEND_ERROR;
+      addrlen = 1 + sx->udp_dest_domain_len;
+      atyp = SOCKS5_ATYP_DOMAIN;
+      break;
+    case SOCKS5_ATYP_IPV4:
+    default:
+      addrlen = SOCKS5_IPV4_ADDR_LEN;
+      atyp = SOCKS5_ATYP_IPV4;
+      break;
+    }
+
+    header_len = SOCKS5_REPLY_HEADER_LEN + addrlen + SOCKS5_PORT_LEN;
+    packet = malloc(header_len + len);
+    if(!packet)
+      return CURLE_OUT_OF_MEMORY;
+
+    packet[0] = 0;
+    packet[1] = 0;
+    packet[2] = 0;
+    packet[SOCKS5_REPLY_HEADER_LEN - 1] = atyp;
+    if(atyp == SOCKS5_ATYP_DOMAIN) {
+      packet[SOCKS5_REPLY_HEADER_LEN] =
+        (unsigned char)sx->udp_dest_domain_len;
+      memcpy(&packet[SOCKS5_REPLY_HEADER_LEN + 1], sx->udp_dest_domain,
+             sx->udp_dest_domain_len);
+    }
+    else
+      memcpy(&packet[SOCKS5_REPLY_HEADER_LEN], sx->udp_dest_addr, addrlen);
+    packet[SOCKS5_REPLY_HEADER_LEN + addrlen] =
+      (unsigned char)((sx->udp_dest_port >> 8) & 0xff);
+    packet[SOCKS5_REPLY_HEADER_LEN + addrlen + 1] =
+      (unsigned char)(sx->udp_dest_port & 0xff);
+    memcpy(&packet[header_len], buf, len);
+
+    infof(data, "SOCKS5 UDP send: payload=%zu header=%zu atyp=%d",
+          len, header_len, atyp);
+    if(atyp == SOCKS5_ATYP_DOMAIN) {
+      infof(data, "SOCKS5 UDP header: domain_len=%zu domain=%.*s port=%d",
+            sx->udp_dest_domain_len,
+            (int)sx->udp_dest_domain_len, sx->udp_dest_domain,
+            sx->udp_dest_port);
+    }
+    result = cf->next->cft->do_send(cf->next, data, packet,
+                                    header_len + len, eos, &nwritten);
+    free(packet);
+    if(result) {
+      if(result == CURLE_AGAIN)
+        *pnwritten = 0;
+      return result;
+    }
+
+    if(nwritten != (header_len + len))
+      return CURLE_SEND_ERROR;
+
+    *pnwritten = len;
+    return CURLE_OK;
+  }
+
+  return Curl_cf_def_send(cf, data, buf, len, eos, pnwritten);
+}
+
+static CURLcode socks_proxy_cf_recv(struct Curl_cfilter *cf,
+                                    struct Curl_easy *data,
+                                    char *buf, size_t len, size_t *pnread)
+{
+  struct socks_state *sx = cf->ctx;
+
+  if(sx && sx->udp_associate && sx->udp_cf) {
+    /* Strip SOCKS5 UDP headers before passing QUIC payload upward. */
+    size_t maxhdr =
+      SOCKS5_REPLY_HEADER_LEN + 1 + 255 + SOCKS5_PORT_LEN;
+    size_t pktlen = len + maxhdr;
+    unsigned char *packet = malloc(pktlen);
+    size_t nread = 0;
+    CURLcode result;
+
+    *pnread = 0;
+    if(!packet)
+      return CURLE_OUT_OF_MEMORY;
+
+    result = cf->next->cft->do_recv(cf->next, data, (char *)packet,
+                                    pktlen, &nread);
+    if(result) {
+      free(packet);
+      return result;
+    }
+
+    if(nread < SOCKS5_REPLY_HEADER_LEN) {
+      free(packet);
+      return CURLE_RECV_ERROR;
+    }
+    if(packet[0] || packet[1] || packet[2]) {
+      free(packet);
+      return CURLE_RECV_ERROR;
+    }
+    {
+      size_t addrlen;
+      size_t off = SOCKS5_REPLY_HEADER_LEN;
+      switch(packet[SOCKS5_REPLY_HEADER_LEN - 1]) {
+      case SOCKS5_ATYP_IPV4:
+        addrlen = SOCKS5_IPV4_ADDR_LEN;
+        break;
+      case SOCKS5_ATYP_IPV6:
+        addrlen = SOCKS5_IPV6_ADDR_LEN;
+        break;
+      case SOCKS5_ATYP_DOMAIN:
+        if(nread < (SOCKS5_REPLY_HEADER_LEN + 1)) {
+          free(packet);
+          return CURLE_RECV_ERROR;
+        }
+        addrlen = 1 + packet[SOCKS5_REPLY_HEADER_LEN];
+        break;
+      default:
+        free(packet);
+        return CURLE_RECV_ERROR;
+      }
+    if(nread < off + addrlen + SOCKS5_PORT_LEN) {
+      free(packet);
+      return CURLE_RECV_ERROR;
+    }
+    /* For socks5h:// with domain names (udp_dest_atyp == SOCKS5_ATYP_DOMAIN),
+     * do NOT set udp_peer_set from received packets. This ensures that
+     * CF_QUERY_REMOTE_ADDR consistently returns the relay address throughout
+     * the connection. The relay address is what QUIC should use as the "peer"
+     * since that's what we're actually communicating with on the network.
+     * TLS verification uses the hostname (not IP) for SNI/certificate checks.
+     * For socks5:// (local DNS) or IP literals, udp_peer_set is already TRUE
+     * from initialization, so we can update udp_peer_addr here. */
+    if((packet[SOCKS5_REPLY_HEADER_LEN - 1] == SOCKS5_ATYP_IPV4 ||
+        packet[SOCKS5_REPLY_HEADER_LEN - 1] == SOCKS5_ATYP_IPV6) &&
+       sx->udp_dest_atyp != SOCKS5_ATYP_DOMAIN) {
+      const unsigned char *addrbytes = &packet[SOCKS5_REPLY_HEADER_LEN];
+      int port = (int)((packet[SOCKS5_REPLY_HEADER_LEN + addrlen] << 8) |
+                       packet[SOCKS5_REPLY_HEADER_LEN + addrlen +
+                              (SOCKS5_PORT_LEN - 1)]);
+      memset(&sx->udp_peer_addr, 0, sizeof(sx->udp_peer_addr));
+      if(packet[SOCKS5_REPLY_HEADER_LEN - 1] == SOCKS5_ATYP_IPV4) {
+        struct sockaddr_in *sa =
+          (struct sockaddr_in *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+        sa->sin_family = AF_INET;
+        memcpy(&sa->sin_addr, addrbytes, sizeof(struct in_addr));
+        sa->sin_port = htons((unsigned short)port);
+        sx->udp_peer_addr.family = AF_INET;
+        sx->udp_peer_addr.socktype = SOCK_DGRAM;
+        sx->udp_peer_addr.protocol = IPPROTO_UDP;
+        sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in);
+        sx->udp_peer_set = TRUE;
+      }
+#ifdef USE_IPV6
+      else {
+        struct sockaddr_in6 *sa6 =
+          (struct sockaddr_in6 *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+        sa6->sin6_family = AF_INET6;
+        memcpy(&sa6->sin6_addr, addrbytes, sizeof(struct in6_addr));
+        sa6->sin6_port = htons((unsigned short)port);
+        sx->udp_peer_addr.family = AF_INET6;
+        sx->udp_peer_addr.socktype = SOCK_DGRAM;
+        sx->udp_peer_addr.protocol = IPPROTO_UDP;
+        sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in6);
+        sx->udp_peer_set = TRUE;
+      }
+#endif
+    }
+    off += addrlen + SOCKS5_PORT_LEN;
+      if(nread > off) {
+        size_t payload = nread - off;
+        if(payload > len)
+          payload = len;
+        memcpy(buf, &packet[off], payload);
+        *pnread = payload;
+        infof(data, "SOCKS5 UDP recv: payload=%zu header=%zu",
+              payload, off);
+      }
+      else
+        *pnread = 0;
+    }
+    free(packet);
+    return CURLE_OK;
+  }
+
+  return Curl_cf_def_recv(cf, data, buf, len, pnread);
+}
+
 static void socks_cf_adjust_pollset(struct Curl_cfilter *cf,
                                     struct Curl_easy *data,
                                     struct easy_pollset *ps)
@@ -1176,15 +1771,14 @@ static void socks_proxy_cf_close(struct Curl_cfilter *cf,
 
   DEBUGASSERT(cf->next);
   cf->connected = FALSE;
-  socks_proxy_cf_free(cf);
+  socks_proxy_cf_free(cf, data);
   cf->next->cft->do_close(cf->next, data);
 }
 
 static void socks_proxy_cf_destroy(struct Curl_cfilter *cf,
                                    struct Curl_easy *data)
 {
-  (void)data;
-  socks_proxy_cf_free(cf);
+  socks_proxy_cf_free(cf, data);
 }
 
 static CURLcode socks_cf_query(struct Curl_cfilter *cf,
@@ -1195,6 +1789,12 @@ static CURLcode socks_cf_query(struct Curl_cfilter *cf,
 
   if(sx) {
     switch(query) {
+    case CF_QUERY_REMOTE_ADDR:
+      if(sx->udp_associate && sx->udp_peer_set) {
+        *((const struct Curl_sockaddr_ex **)pres2) = &sx->udp_peer_addr;
+        return CURLE_OK;
+      }
+      break;
     case CF_QUERY_HOST_PORT:
       *pres1 = sx->remote_port;
       *((const char **)pres2) = sx->hostname;
@@ -1218,14 +1818,25 @@ struct Curl_cftype Curl_cft_socks_proxy = {
   Curl_cf_def_shutdown,
   socks_cf_adjust_pollset,
   Curl_cf_def_data_pending,
-  Curl_cf_def_send,
-  Curl_cf_def_recv,
+  socks_proxy_cf_send,
+  socks_proxy_cf_recv,
   Curl_cf_def_cntrl,
   Curl_cf_def_conn_is_alive,
   Curl_cf_def_conn_keep_alive,
   socks_cf_query,
 };
 
+bool Curl_cf_socks_proxy_is_udp_associate(struct Curl_cfilter *cf)
+{
+  for(; cf; cf = cf->next) {
+    if(cf->cft == &Curl_cft_socks_proxy) {
+      struct socks_state *sx = cf->ctx;
+      return sx && sx->udp_associate;
+    }
+  }
+  return FALSE;
+}
+
 CURLcode Curl_cf_socks_proxy_insert_after(struct Curl_cfilter *cf_at,
                                           struct Curl_easy *data)
 {
diff --git a/lib/socks.h b/lib/socks.h
index d60796316..648a193e2 100644
--- a/lib/socks.h
+++ b/lib/socks.h
@@ -30,7 +30,9 @@
 #define Curl_SOCKS4(a,b,c,d,e) CURLE_NOT_BUILT_IN
 #define Curl_SOCKS5(a,b,c,d,e,f) CURLE_NOT_BUILT_IN
 #define Curl_SOCKS_getsock(x,y,z) 0
+#define Curl_cf_socks_proxy_is_udp_associate(x) FALSE
 #else
+struct Curl_cfilter;
 /*
  * Helper read-from-socket functions. Does the same as Curl_read() but it
  * blocks until all bytes amount of buffersize will be read. No more, no less.
@@ -54,6 +56,9 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
 CURLcode Curl_cf_socks_proxy_insert_after(struct Curl_cfilter *cf_at,
                                           struct Curl_easy *data);
 
+/* Query if a SOCKS filter in the chain is using UDP ASSOCIATE. */
+bool Curl_cf_socks_proxy_is_udp_associate(struct Curl_cfilter *cf);
+
 extern struct Curl_cftype Curl_cft_socks_proxy;
 
 #endif /* CURL_DISABLE_PROXY */
diff --git a/lib/transfer.c b/lib/transfer.c
index 15a61f699..df4c721a1 100644
--- a/lib/transfer.c
+++ b/lib/transfer.c
@@ -104,7 +104,15 @@ char *Curl_checkheaders(const struct Curl_easy *data,
   DEBUGASSERT(thislen);
   DEBUGASSERT(thisheader[thislen-1] != ':');
 
-  for(head = data->set.headers; head; head = head->next) {
+  /*
+   * curl-impersonate:
+   * Check if we have overriden the user-supplied list of headers.
+   */
+  head = data->set.headers;
+  if (data->state.merged_headers)
+    head = data->state.merged_headers;
+
+  for(; head; head = head->next) {
     if(curl_strnequal(head->data, thisheader, thislen) &&
        Curl_headersep(head->data[thislen]) )
       return head->data;
diff --git a/lib/url.c b/lib/url.c
index e4f250f54..09c11f4c0 100644
--- a/lib/url.c
+++ b/lib/url.c
@@ -333,6 +333,10 @@ CURLcode Curl_close(struct Curl_easy **datap)
   Curl_safefree(data->state.aptr.proxyuser);
   Curl_safefree(data->state.aptr.proxypasswd);
 #endif
+  /* curl-impersonate: Free the list set by CURLOPT_HTTPBASEHEADER. */
+  curl_slist_free_all(data->state.base_headers);
+  /* curl-impersonate: Free the dynamic list of headers. */
+  curl_slist_free_all(data->state.merged_headers);
 
 #if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_FORM_API)
   Curl_mime_cleanpart(data->state.formp);
@@ -468,6 +472,9 @@ CURLcode Curl_init_userdefined(struct Curl_easy *data)
   set->tcp_fastopen = FALSE;
   set->tcp_nodelay = TRUE;
   set->ssl_enable_alpn = TRUE;
+  set->ssl_enable_ticket = TRUE;
+  set->tls_grease = FALSE;
+  set->tls_use_new_alps_codepoint = FALSE;
   set->expect_100_timeout = 1000L; /* Wait for a second by default. */
   set->sep_headers = TRUE; /* separated header lists by default */
   set->buffer_size = READBUFFER_SIZE;
@@ -648,6 +655,17 @@ proxy_info_matches(const struct proxy_info *data,
 
   return FALSE;
 }
+/* curl-impersonate: redefine function in case main curl function is modified in upcoming releases */
+static bool proxy_credential_matches(const struct proxy_info *data,
+                                     const struct proxy_info *needle)
+{
+  if(Curl_timestrcmp(data->user, needle->user) ||
+     Curl_timestrcmp(data->passwd, needle->passwd)) {
+      return FALSE;
+  }
+
+  return TRUE;
+}
 
 static bool
 socks_proxy_info_matches(const struct proxy_info *data,
@@ -994,6 +1012,15 @@ static bool url_match_proxy_use(struct connectdata *conn,
     if(!proxy_info_matches(&m->needle->http_proxy, &conn->http_proxy))
       return FALSE;
 
+    if(m->data->set.proxy_credential_no_reuse &&
+       !proxy_credential_matches(&m->needle->http_proxy, &conn->http_proxy)) {
+      DEBUGF(infof(m->data,
+                   "Connection #%" FMT_OFF_T
+                   " has different proxy credentials, cannot reuse",
+                   conn->connection_id));
+      return FALSE;
+    }
+
     if(IS_HTTPS_PROXY(m->needle->http_proxy.proxytype)) {
       /* https proxies come in different types, http/1.1, h2, ... */
       if(m->needle->http_proxy.proxytype != conn->http_proxy.proxytype)
@@ -1456,6 +1483,7 @@ static struct connectdata *allocate_conn(struct Curl_easy *data)
 
   conn->bits.proxy_user_passwd = !!data->state.aptr.proxyuser;
   conn->bits.tunnel_proxy = data->set.tunnel_thru_httpproxy;
+  conn->bits.proxy_credential_no_reuse = data->set.proxy_credential_no_reuse;
 #endif /* CURL_DISABLE_PROXY */
 
 #ifndef CURL_DISABLE_FTP
@@ -3741,6 +3769,11 @@ static CURLcode create_conn(struct Curl_easy *data,
          (default) */
       if(data->set.ssl_enable_alpn)
         conn->bits.tls_enable_alpn = TRUE;
+
+      /* curl-impersonate: Turn on ALPS if ALPN is enabled and the bit is
+       * enabled. */
+      if(data->set.ssl_enable_alps)
+        conn->bits.tls_enable_alps = TRUE;
     }
 
     if(waitpipe) {
diff --git a/lib/urldata.h b/lib/urldata.h
index e54721dd9..3b1500a0d 100644
--- a/lib/urldata.h
+++ b/lib/urldata.h
@@ -275,6 +275,8 @@ struct ssl_primary_config {
   char *password; /* TLS password (for, e.g., SRP) */
 #endif
   char *curves;          /* list of curves to use */
+  char *sig_hash_algs;   /* List of signature hash algorithms to use */
+  char *cert_compression;  /* List of certificate compression algorithms. */
   unsigned int version_max; /* max supported version the client wants to use */
   unsigned char ssl_options;  /* the CURLOPT_SSL_OPTIONS bitmask */
   unsigned char version;    /* what version the client wants to use */
@@ -375,6 +377,7 @@ struct ConnectBits {
                          proxies, but can also be enabled explicitly by
                          apps */
   BIT(proxy); /* if set, this transfer is done through a proxy - any type */
+  BIT(proxy_credential_no_reuse); /* no reuse of SSL sessions/connections via different proxy credentials */
 #endif
   /* always modify bits.close with the connclose() and connkeep() macros! */
   BIT(close); /* if set, we close the connection after this request */
@@ -412,6 +415,11 @@ struct ConnectBits {
   BIT(multiplex); /* connection is multiplexed */
   BIT(tcp_fastopen); /* use TCP Fast Open */
   BIT(tls_enable_alpn); /* TLS ALPN extension? */
+  BIT(tls_enable_alps); /* TLS ALPS extension? */
+  BIT(tls_enable_ticket); /* TLS session ticket extension? */
+  BIT(tls_permute_extensions); /* TLS extension permutations */
+  BIT(tls_use_new_alps_codepoint); /* TLS ALPS new codepoint */
+  BIT(tls_grease);  /* TLS grease? */
 #ifndef CURL_DISABLE_DOH
   BIT(doh);
 #endif
@@ -1119,6 +1127,19 @@ struct UrlState {
                                     curl_easy_setopt(COOKIEFILE) calls */
 #endif
 
+  /*
+   * curl-impersonate:
+   * List of "base" headers set by CURLOPT_HTTPBASEHEADER.
+   */
+  struct curl_slist *base_headers;
+  /*
+   * curl-impersonate:
+   * Dynamically-constructed list of HTTP headers.
+   * This list is a merge of the default HTTP headers needed to impersonate a
+   * browser, together with any user-supplied headers.
+   */
+  struct curl_slist *merged_headers;
+
 #ifndef CURL_DISABLE_VERBOSE_STRINGS
   struct curl_trc_feat *feat; /* opt. trace feature transfer is part of */
 #endif
@@ -1225,6 +1246,7 @@ enum dupstring {
   STRING_SSL_CRLFILE,     /* crl file to check certificate */
   STRING_SSL_ISSUERCERT, /* issuer cert file to check certificate */
   STRING_SERVICE_NAME,    /* Service name */
+  STRING_IMPERSONATE,     /* curl-impersonate */
 #ifndef CURL_DISABLE_PROXY
   STRING_CERT_PROXY,      /* client certificate filename */
   STRING_CERT_TYPE_PROXY, /* format for certificate (default: PEM)*/
@@ -1334,6 +1356,13 @@ enum dupstring {
 #endif
   STRING_ECH_CONFIG,            /* CURLOPT_ECH_CONFIG */
   STRING_ECH_PUBLIC,            /* CURLOPT_ECH_PUBLIC */
+  STRING_SSL_SIG_HASH_ALGS,
+  STRING_SSL_CERT_COMPRESSION,
+  STRING_HTTP2_PSEUDO_HEADERS_ORDER,
+  STRING_HTTP2_SETTINGS,
+  STRING_HTTP2_STREAMS,
+  STRING_TLS_EXTENSION_ORDER,
+  STRING_TLS_DELEGATED_CREDENTIALS,
   STRING_SSL_SIGNATURE_ALGORITHMS, /* CURLOPT_SSL_SIGNATURE_ALGORITHMS */
 
   /* -- end of null-terminated strings -- */
@@ -1595,6 +1624,7 @@ struct UserDefined {
   BIT(get_filetime);     /* get the time and get of the remote file */
 #ifndef CURL_DISABLE_PROXY
   BIT(tunnel_thru_httpproxy); /* use CONNECT through an HTTP proxy */
+  BIT(proxy_credential_no_reuse); /* no reuse of SSL sessions/connections via different proxy credentials */
 #endif
   BIT(prefer_ascii);     /* ASCII rather than binary */
   BIT(remote_append);    /* append, not overwrite, on upload */
@@ -1641,6 +1671,14 @@ struct UserDefined {
   BIT(tcp_keepalive);  /* use TCP keepalives */
   BIT(tcp_fastopen);   /* use TCP Fast Open */
   BIT(ssl_enable_alpn);/* TLS ALPN extension? */
+  BIT(ssl_enable_alps);/* TLS ALPS extension? */
+  BIT(ssl_enable_ticket); /* TLS session ticket extension */
+  BIT(ssl_permute_extensions); /* TLS Permute extensions */
+  BIT(tls_grease);  /* TLS grease? */
+  BIT(tls_key_usage_no_check);  /* TLS key_usage_check? */
+  BIT(tls_signed_cert_timestamps);  /* TLS signed cert timestamps? */
+  BIT(tls_status_request);  /* TLS status request */
+  BIT(tls_use_new_alps_codepoint); /* TLS use new alps codepoint */
   BIT(path_as_is);     /* allow dotdots? */
   BIT(pipewait);       /* wait for multiplex status before starting a new
                           connection */
@@ -1662,10 +1700,15 @@ struct UserDefined {
   BIT(doh_verifystatus);   /* DoH certificate status verification */
 #endif
   BIT(http09_allowed); /* allow HTTP/0.9 responses */
+// BIT(grease);           /* grease enabled? */
 #ifndef CURL_DISABLE_WEBSOCKETS
   BIT(ws_raw_mode);
   BIT(ws_no_auto_pong);
 #endif
+  int http2_window_update;
+  int tls_record_size_limit;
+  int tls_key_shares_limit;
+  BIT(http2_no_priority);
 };
 
 #ifndef CURL_DISABLE_MIME
diff --git a/lib/vquic/curl_ngtcp2.c b/lib/vquic/curl_ngtcp2.c
index 69d54ecce..fd9ea4231 100644
--- a/lib/vquic/curl_ngtcp2.c
+++ b/lib/vquic/curl_ngtcp2.c
@@ -56,6 +56,7 @@
 #include "../cfilters.h"
 #include "../cf-socket.h"
 #include "../connect.h"
+#include "../socks.h"
 #include "../progress.h"
 #include "../strerror.h"
 #include "../curlx/dynbuf.h"
@@ -88,6 +89,43 @@
  * when we take things out of the buffer.
  * Chunk size is large enough to take a full DATA frame */
 #define H3_STREAM_WINDOW_SIZE (128 * 1024)
+
+static const struct alpn_spec ALPN_SPEC_H3 = {
+  { "h3", "h3-29" }, 2
+};
+
+/* Walk the filter chain to find the active socket for QUIC logging. */
+static CURLcode cf_ngtcp2_peek_socket(struct Curl_cfilter *cf,
+                                      struct Curl_easy *data,
+                                      curl_socket_t *psock,
+                                      const struct Curl_sockaddr_ex **paddr,
+                                      struct ip_quadruple *pip)
+{
+  bool got_sock = FALSE;
+  bool got_addr = FALSE;
+  bool got_ip = FALSE;
+  int dummy = 0;
+
+  for(; cf; cf = cf->next) {
+    if(!got_sock && (psock || pip)) {
+      if(!Curl_cf_socket_peek(cf, data, psock, NULL, pip)) {
+        got_sock = (psock != NULL);
+        got_ip = (pip != NULL);
+      }
+    }
+    if(paddr && !got_addr) {
+      const struct Curl_sockaddr_ex *addr = NULL;
+      if(!cf->cft->query(cf, data, CF_QUERY_REMOTE_ADDR, &dummy, &addr) &&
+         addr) {
+        *paddr = addr;
+        got_addr = TRUE;
+      }
+    }
+    if((!psock || got_sock) && (!paddr || got_addr) && (!pip || got_ip))
+      return CURLE_OK;
+  }
+  return CURLE_FAILED_INIT;
+}
 #define H3_STREAM_CHUNK_SIZE   (16 * 1024)
 #if H3_STREAM_CHUNK_SIZE < NGTCP2_MAX_UDP_PAYLOAD_SIZE
 #error H3_STREAM_CHUNK_SIZE smaller than NGTCP2_MAX_UDP_PAYLOAD_SIZE
@@ -2420,9 +2458,6 @@ static CURLcode cf_connect_start(struct Curl_cfilter *cf,
   CURLcode result;
   const struct Curl_sockaddr_ex *sockaddr = NULL;
   int qfd;
-static const struct alpn_spec ALPN_SPEC_H3 = {
-  { "h3", "h3-29" }, 2
-};
 
   DEBUGASSERT(ctx->initialized);
   ctx->dcid.datalen = NGTCP2_MAX_CIDLEN;
@@ -2443,7 +2478,7 @@ static const struct alpn_spec ALPN_SPEC_H3 = {
   if(result)
     return result;
 
-  Curl_cf_socket_peek(cf->next, data, &ctx->q.sockfd, &sockaddr, NULL);
+  cf_ngtcp2_peek_socket(cf->next, data, &ctx->q.sockfd, &sockaddr, NULL);
   if(!sockaddr)
     return CURLE_QUIC_CONNECT_ERROR;
   ctx->q.local_addrlen = sizeof(ctx->q.local_addr);
@@ -2578,7 +2613,7 @@ out:
   if(result) {
     struct ip_quadruple ip;
 
-    Curl_cf_socket_peek(cf->next, data, NULL, NULL, &ip);
+    cf_ngtcp2_peek_socket(cf->next, data, NULL, NULL, &ip);
     infof(data, "QUIC connect to %s port %u failed: %s",
           ip.remote_ip, ip.remote_port, curl_easy_strerror(result));
   }
@@ -2732,7 +2767,10 @@ CURLcode Curl_cf_ngtcp2_create(struct Curl_cfilter **pcf,
                                const struct Curl_addrinfo *ai)
 {
   struct cf_ngtcp2_ctx *ctx = NULL;
-  struct Curl_cfilter *cf = NULL, *udp_cf = NULL;
+  struct Curl_cfilter *cf = NULL;
+  struct Curl_cfilter *udp_cf = NULL;
+  struct Curl_cfilter *socks_cf = NULL;
+  struct Curl_cfilter *tcp_cf = NULL;
   CURLcode result;
 
   (void)data;
@@ -2747,20 +2785,41 @@ CURLcode Curl_cf_ngtcp2_create(struct Curl_cfilter **pcf,
   if(result)
     goto out;
 
-  result = Curl_cf_udp_create(&udp_cf, data, conn, ai, TRNSPRT_QUIC);
-  if(result)
-    goto out;
-
   cf->conn = conn;
-  udp_cf->conn = cf->conn;
-  udp_cf->sockindex = cf->sockindex;
-  cf->next = udp_cf;
+  if(conn->bits.socksproxy) {
+    /* Build SOCKS->TCP chain for the proxy control channel. */
+    result = Curl_cf_create(&socks_cf, &Curl_cft_socks_proxy, NULL);
+    if(result)
+      goto out;
+    socks_cf->conn = cf->conn;
+    socks_cf->sockindex = cf->sockindex;
+    result = Curl_cf_tcp_create(&tcp_cf, data, conn, ai, TRNSPRT_TCP);
+    if(result)
+      goto out;
+    tcp_cf->conn = cf->conn;
+    tcp_cf->sockindex = cf->sockindex;
+    socks_cf->next = tcp_cf;
+    cf->next = socks_cf;
+  }
+  else {
+    result = Curl_cf_udp_create(&udp_cf, data, conn, ai, TRNSPRT_QUIC);
+    if(result)
+      goto out;
+
+    udp_cf->conn = cf->conn;
+    udp_cf->sockindex = cf->sockindex;
+    cf->next = udp_cf;
+  }
 
 out:
   *pcf = (!result) ? cf : NULL;
   if(result) {
     if(udp_cf)
       Curl_conn_cf_discard_sub(cf, udp_cf, data, TRUE);
+    if(socks_cf)
+      Curl_conn_cf_discard_sub(cf, socks_cf, data, TRUE);
+    if(tcp_cf)
+      Curl_conn_cf_discard_sub(cf, tcp_cf, data, TRUE);
     Curl_safefree(cf);
     cf_ngtcp2_ctx_free(ctx);
   }
diff --git a/lib/vquic/vquic.c b/lib/vquic/vquic.c
index 691c0d3fa..cf29e5952 100644
--- a/lib/vquic/vquic.c
+++ b/lib/vquic/vquic.c
@@ -41,6 +41,8 @@
 #include "curl_quiche.h"
 #include "../multiif.h"
 #include "../rand.h"
+#include "../cf-socket.h"
+#include "../socks.h"
 #include "vquic.h"
 #include "vquic_int.h"
 #include "../strerror.h"
@@ -57,6 +59,38 @@
 #define NW_CHUNK_SIZE     (64 * 1024)
 #define NW_SEND_CHUNKS    2
 
+static CURLcode vquic_peek_socket(struct Curl_cfilter *cf,
+                                  struct Curl_easy *data,
+                                  struct ip_quadruple *pip)
+{
+  for(; cf; cf = cf->next) {
+    if(!Curl_cf_socket_peek(cf, data, NULL, NULL, pip))
+      return CURLE_OK;
+  }
+  return CURLE_FAILED_INIT;
+}
+
+/* Resolve the relay address from the active socket for recv callbacks. */
+static bool vquic_get_remote_addr(struct Curl_cfilter *cf,
+                                  struct Curl_easy *data,
+                                  struct sockaddr_storage *remote_addr,
+                                  socklen_t *remote_addrlen)
+{
+  const struct Curl_sockaddr_ex *peer_addr = NULL;
+  int dummy = 0;
+
+  for(; cf; cf = cf->next) {
+    if(!cf->cft->query(cf, data, CF_QUERY_REMOTE_ADDR, &dummy,
+                       &peer_addr) && peer_addr) {
+      memset(remote_addr, 0, sizeof(*remote_addr));
+      memcpy(remote_addr, &peer_addr->curl_sa_addr, peer_addr->addrlen);
+      *remote_addrlen = (socklen_t)peer_addr->addrlen;
+      return TRUE;
+    }
+  }
+  return FALSE;
+}
+
 
 int Curl_vquic_init(void)
 {
@@ -249,6 +283,38 @@ static CURLcode vquic_send_packets(struct Curl_cfilter *cf,
                                    const uint8_t *pkt, size_t pktlen,
                                    size_t gsolen, size_t *psent)
 {
+  if(Curl_cf_socks_proxy_is_udp_associate(cf->next)) {
+    CURLcode result;
+    size_t sent_total = 0;
+    const uint8_t *p = pkt;
+    size_t pktstep = gsolen ? gsolen : pktlen;
+
+    /* SOCKS UDP ASSOCIATE needs per-packet encapsulation in the filter. */
+    infof(data, "QUIC over SOCKS UDP send: bytes=%zu gso=%zu",
+          pktlen, gsolen);
+    qctx->no_gso = TRUE;
+    while(sent_total < pktlen) {
+      size_t len = CURLMIN(pktstep, pktlen - sent_total);
+      size_t nwritten = 0;
+
+      result = Curl_conn_cf_send(cf->next, data, p, len, FALSE, &nwritten);
+      if(result) {
+        if(result == CURLE_AGAIN) {
+          *psent = sent_total;
+          return result;
+        }
+        return result;
+      }
+      if(nwritten != len)
+        return CURLE_SEND_ERROR;
+      sent_total += nwritten;
+      p += nwritten;
+    }
+    *psent = sent_total;
+    qctx->last_io = qctx->last_op;
+    return CURLE_OK;
+  }
+
   CURLcode result;
 #ifdef DEBUGBUILD
   /* simulate network blocking/partial writes */
@@ -378,14 +444,14 @@ static CURLcode recvmmsg_packets(struct Curl_cfilter *cf,
   size_t pktlen;
   size_t offset, to;
   char *sockbuf = NULL;
-  uint8_t (*bufs)[64*1024] = NULL;
+  uint8_t (*bufs)[NW_CHUNK_SIZE] = NULL;
 
   DEBUGASSERT(max_pkts > 0);
   result = Curl_multi_xfer_sockbuf_borrow(data, MMSG_NUM * sizeof(bufs[0]),
                                           &sockbuf);
   if(result)
     goto out;
-  bufs = (uint8_t (*)[64*1024])sockbuf;
+  bufs = (uint8_t (*)[NW_CHUNK_SIZE])sockbuf;
 
   total_nread = 0;
   while(pkts < max_pkts) {
@@ -412,7 +478,7 @@ static CURLcode recvmmsg_packets(struct Curl_cfilter *cf,
       }
       if(!cf->connected && SOCKERRNO == SOCKECONNREFUSED) {
         struct ip_quadruple ip;
-        Curl_cf_socket_peek(cf->next, data, NULL, NULL, &ip);
+        vquic_peek_socket(cf->next, data, &ip);
         failf(data, "QUIC: connection to %s port %u refused",
               ip.remote_ip, ip.remote_port);
         result = CURLE_COULDNT_CONNECT;
@@ -470,7 +536,7 @@ static CURLcode recvmsg_packets(struct Curl_cfilter *cf,
 {
   struct iovec msg_iov;
   struct msghdr msg;
-  uint8_t buf[64*1024];
+  uint8_t buf[NW_CHUNK_SIZE];
   struct sockaddr_storage remote_addr;
   size_t total_nread, pkts;
   ssize_t nread;
@@ -504,7 +570,7 @@ static CURLcode recvmsg_packets(struct Curl_cfilter *cf,
       }
       if(!cf->connected && SOCKERRNO == SOCKECONNREFUSED) {
         struct ip_quadruple ip;
-        Curl_cf_socket_peek(cf->next, data, NULL, NULL, &ip);
+        vquic_peek_socket(cf->next, data, &ip);
         failf(data, "QUIC: connection to %s port %u refused",
               ip.remote_ip, ip.remote_port);
         result = CURLE_COULDNT_CONNECT;
@@ -556,7 +622,7 @@ static CURLcode recvfrom_packets(struct Curl_cfilter *cf,
                                  size_t max_pkts,
                                  vquic_recv_pkt_cb *recv_cb, void *userp)
 {
-  uint8_t buf[64*1024];
+  uint8_t buf[NW_CHUNK_SIZE];
   int bufsize = (int)sizeof(buf);
   struct sockaddr_storage remote_addr;
   socklen_t remote_addrlen = sizeof(remote_addr);
@@ -579,7 +645,7 @@ static CURLcode recvfrom_packets(struct Curl_cfilter *cf,
       }
       if(!cf->connected && SOCKERRNO == SOCKECONNREFUSED) {
         struct ip_quadruple ip;
-        Curl_cf_socket_peek(cf->next, data, NULL, NULL, &ip);
+        vquic_peek_socket(cf->next, data, &ip);
         failf(data, "QUIC: connection to %s port %u refused",
               ip.remote_ip, ip.remote_port);
         result = CURLE_COULDNT_CONNECT;
@@ -615,6 +681,51 @@ CURLcode vquic_recv_packets(struct Curl_cfilter *cf,
                             vquic_recv_pkt_cb *recv_cb, void *userp)
 {
   CURLcode result;
+
+  if(Curl_cf_socks_proxy_is_udp_associate(cf->next)) {
+    uint8_t buf[NW_CHUNK_SIZE];
+    struct sockaddr_storage remote_addr;
+    socklen_t remote_addrlen = 0;
+    size_t total_nread = 0;
+    size_t pkts = 0;
+
+    result = CURLE_OK;
+    /* SOCKS UDP ASSOCIATE recv path goes through the filter chain. */
+    infof(data, "QUIC over SOCKS UDP recv: max_pkts=%zu", max_pkts);
+    for(pkts = 0, total_nread = 0; pkts < max_pkts;) {
+      size_t nread = 0;
+      result = Curl_conn_cf_recv(cf->next, data, (char *)buf, sizeof(buf),
+                                 &nread);
+      if(result) {
+        if(result == CURLE_AGAIN) {
+          result = CURLE_OK;
+          break;
+        }
+        if(!cf->connected && data->state.os_errno == SOCKECONNREFUSED) {
+          struct ip_quadruple ip;
+          vquic_peek_socket(cf->next, data, &ip);
+          failf(data, "QUIC: connection to %s port %u refused",
+                ip.remote_ip, ip.remote_port);
+          return CURLE_COULDNT_CONNECT;
+        }
+        return result;
+      }
+
+      if(!vquic_get_remote_addr(cf->next, data, &remote_addr,
+                                &remote_addrlen))
+        return CURLE_FAILED_INIT;
+      ++pkts;
+      total_nread += nread;
+      result = recv_cb(buf, nread, &remote_addr, remote_addrlen, 0, userp);
+      if(result)
+        return result;
+    }
+
+    if(total_nread || result)
+      CURL_TRC_CF(data, cf, "recvd %zu packets with %zu bytes -> %d",
+                  pkts, total_nread, result);
+  }
+  else
 #if defined(HAVE_SENDMMSG)
   result = recvmmsg_packets(cf, data, qctx, max_pkts, recv_cb, userp);
 #elif defined(HAVE_SENDMSG)
@@ -715,10 +826,6 @@ CURLcode Curl_conn_may_http3(struct Curl_easy *data,
     return CURLE_URL_MALFORMAT;
   }
 #ifndef CURL_DISABLE_PROXY
-  if(conn->bits.socksproxy) {
-    failf(data, "HTTP/3 is not supported over a SOCKS proxy");
-    return CURLE_URL_MALFORMAT;
-  }
   if(conn->bits.httpproxy && conn->bits.tunnel_proxy) {
     failf(data, "HTTP/3 is not supported over an HTTP proxy");
     return CURLE_URL_MALFORMAT;
diff --git a/lib/vtls/openssl.c b/lib/vtls/openssl.c
index b0f91cf40..7c4de5fc6 100644
--- a/lib/vtls/openssl.c
+++ b/lib/vtls/openssl.c
@@ -82,9 +82,20 @@
 #include <openssl/bio.h>
 #include <openssl/buffer.h>
 #include <openssl/pkcs12.h>
+#include <openssl/pool.h>
 #include <openssl/tls1.h>
 #include <openssl/evp.h>
 
+#ifdef HAVE_LIBZ
+#include <zlib.h>
+#endif
+#ifdef HAVE_BROTLI
+#include <brotli/decode.h>
+#endif
+#ifdef HAVE_ZSTD
+#include <zstd.h>
+#endif
+
 #ifdef HAVE_SSL_SET1_ECH_CONFIG_LIST
 #define USE_ECH_OPENSSL
 #endif
@@ -262,6 +273,113 @@ typedef int numcert_t;
 #define HAVE_OPENSSL_VERSION
 #endif
 
+#if defined(OPENSSL_IS_BORINGSSL)
+#define HAVE_SSL_CTX_SET_VERIFY_ALGORITHM_PREFS
+
+/*
+ * kMaxSignatureAlgorithmNameLen and kSignatureAlgorithmNames
+ * Taken from BoringSSL, see ssl/ssl_privkey.cc
+ * */
+static const size_t kMaxSignatureAlgorithmNameLen = 23;
+
+static const struct {
+  uint16_t signature_algorithm;
+  const char *name;
+} kSignatureAlgorithmNames[] = {
+    {SSL_SIGN_RSA_PKCS1_MD5_SHA1, "rsa_pkcs1_md5_sha1"},
+    {SSL_SIGN_RSA_PKCS1_SHA1, "rsa_pkcs1_sha1"},
+    {SSL_SIGN_RSA_PKCS1_SHA256, "rsa_pkcs1_sha256"},
+    {SSL_SIGN_RSA_PKCS1_SHA384, "rsa_pkcs1_sha384"},
+    {SSL_SIGN_RSA_PKCS1_SHA512, "rsa_pkcs1_sha512"},
+    {SSL_SIGN_ECDSA_SHA1, "ecdsa_sha1"},
+    {SSL_SIGN_ECDSA_SECP256R1_SHA256, "ecdsa_secp256r1_sha256"},
+    {SSL_SIGN_ECDSA_SECP384R1_SHA384, "ecdsa_secp384r1_sha384"},
+    {SSL_SIGN_ECDSA_SECP521R1_SHA512, "ecdsa_secp521r1_sha512"},
+    {SSL_SIGN_RSA_PSS_RSAE_SHA256, "rsa_pss_rsae_sha256"},
+    {SSL_SIGN_RSA_PSS_RSAE_SHA384, "rsa_pss_rsae_sha384"},
+    {SSL_SIGN_RSA_PSS_RSAE_SHA512, "rsa_pss_rsae_sha512"},
+    {SSL_SIGN_ED25519, "ed25519"},
+};
+
+#define MAX_SIG_ALGS \
+  sizeof(kSignatureAlgorithmNames) / sizeof(kSignatureAlgorithmNames[0])
+
+/* Default signature hash algorithms taken from Chrome/Chromium.
+ * See kVerifyPeers @ net/socket/ssl_client_socket_impl.cc */
+static const uint16_t default_sig_algs[] = {
+  SSL_SIGN_ECDSA_SECP256R1_SHA256, SSL_SIGN_RSA_PSS_RSAE_SHA256,
+  SSL_SIGN_RSA_PKCS1_SHA256,       SSL_SIGN_ECDSA_SECP384R1_SHA384,
+  SSL_SIGN_RSA_PSS_RSAE_SHA384,    SSL_SIGN_RSA_PKCS1_SHA384,
+  SSL_SIGN_RSA_PSS_RSAE_SHA512,    SSL_SIGN_RSA_PKCS1_SHA512,
+};
+
+#define DEFAULT_SIG_ALGS_LENGTH  \
+  sizeof(default_sig_algs) / sizeof(default_sig_algs[0])
+
+static CURLcode parse_sig_algs(struct Curl_easy *data,
+                               const char *sigalgs,
+                               uint16_t *algs,
+                               size_t *nalgs)
+{
+  *nalgs = 0;
+  while (sigalgs && sigalgs[0]) {
+    int i;
+    bool found = FALSE;
+    const char *end;
+    size_t len;
+    char algname[kMaxSignatureAlgorithmNameLen + 1];
+
+    end = strpbrk(sigalgs, ":,");
+    if (end)
+      len = end - sigalgs;
+    else
+      len = strlen(sigalgs);
+
+    if (len > kMaxSignatureAlgorithmNameLen) {
+      failf(data, "Bad signature hash algorithm list");
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    }
+
+    if (!len) {
+      ++sigalgs;
+      continue;
+    }
+
+    if (*nalgs == MAX_SIG_ALGS) {
+      /* Reached the maximum number of possible algorithms, but more data
+       * available in the list. */
+      failf(data, "Bad signature hash algorithm list");
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    }
+
+    memcpy(algname, sigalgs, len);
+    algname[len] = 0;
+
+    for (i = 0; i < MAX_SIG_ALGS; i++) {
+      if (curl_strequal(algname, kSignatureAlgorithmNames[i].name)) {
+        algs[*nalgs] = kSignatureAlgorithmNames[i].signature_algorithm;
+        (*nalgs)++;
+        found = TRUE;
+        break;
+      }
+    }
+
+    if (!found) {
+      failf(data, "Unknown signature hash algorithm: '%s'", algname);
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    }
+
+    if (end)
+      sigalgs = ++end;
+    else
+      break;
+  }
+
+  return CURLE_OK;
+}
+
+#endif
+
 #if defined(OPENSSL_IS_BORINGSSL) || defined(OPENSSL_IS_AWSLC)
 typedef uint32_t sslerr_t;
 #else
@@ -2740,6 +2858,182 @@ static const char *tls_rt_type(int type)
   }
 }
 
+#ifdef HAVE_LIBZ
+int DecompressZlibCert(SSL *ssl,
+                       CRYPTO_BUFFER** out,
+                       size_t uncompressed_len,
+                       const uint8_t* in,
+                       size_t in_len)
+{
+  z_stream strm;
+  uint8_t* data;
+  CRYPTO_BUFFER* decompressed = CRYPTO_BUFFER_alloc(&data, uncompressed_len);
+  if(!decompressed) {
+    return 0;
+  }
+
+  strm.zalloc = NULL;
+  strm.zfree = NULL;
+  strm.opaque = NULL;
+  strm.next_in = (Bytef *)in;
+  strm.avail_in = in_len;
+  strm.next_out = (Bytef *)data;
+  strm.avail_out = uncompressed_len;
+
+  if(inflateInit(&strm) != Z_OK) {
+    CRYPTO_BUFFER_free(decompressed);
+    return 0;
+  }
+
+  if(inflate(&strm, Z_FINISH) != Z_STREAM_END ||
+    strm.avail_in != 0 ||
+    strm.avail_out != 0) {
+    inflateEnd(&strm);
+    CRYPTO_BUFFER_free(decompressed);
+    return 0;
+  }
+
+  inflateEnd(&strm);
+  *out = decompressed;
+  return 1;
+}
+#endif
+
+#ifdef HAVE_BROTLI
+
+/* Taken from Chromium and adapted to C,
+ * see net/ssl/cert_compression.cc
+ */
+int DecompressBrotliCert(SSL* ssl,
+                         CRYPTO_BUFFER** out,
+                         size_t uncompressed_len,
+                         const uint8_t* in,
+                         size_t in_len) {
+  uint8_t* data;
+  CRYPTO_BUFFER* decompressed = CRYPTO_BUFFER_alloc(&data, uncompressed_len);
+  if (!decompressed) {
+    return 0;
+  }
+
+  size_t output_size = uncompressed_len;
+  if (BrotliDecoderDecompress(in_len, in, &output_size, data) !=
+          BROTLI_DECODER_RESULT_SUCCESS ||
+      output_size != uncompressed_len) {
+    CRYPTO_BUFFER_free(decompressed);
+    return 0;
+  }
+
+  *out = decompressed;
+  return 1;
+}
+#endif
+
+// curl-impersonate: decompress the zstd cert
+#ifdef HAVE_ZSTD
+int DecompressZstdCert(SSL* ssl,
+                       CRYPTO_BUFFER** out,
+                       size_t uncompressed_len,
+                       const uint8_t* in,
+                       size_t in_len) {
+  size_t result;
+  uint8_t* data;
+  CRYPTO_BUFFER* decompressed = CRYPTO_BUFFER_alloc(&data, uncompressed_len);
+  if (!decompressed) {
+    return 0;
+  }
+
+  // zstd returns the size of decompressed content
+  result = ZSTD_decompress(data, uncompressed_len, in, in_len);
+  if (ZSTD_isError(result)) {
+    CRYPTO_BUFFER_free(decompressed);
+    return 0;
+  }
+
+  *out = decompressed;
+  return 1;
+}
+
+#endif
+
+
+#if defined(HAVE_LIBZ) || defined(HAVE_BROTLI) || defined(HAVE_ZSTD)
+static struct {
+  char *alg_name;
+  uint16_t alg_id;
+  ssl_cert_compression_func_t compress;
+  ssl_cert_decompression_func_t decompress;
+} cert_compress_algs[] = {
+#ifdef HAVE_LIBZ
+  {"zlib", TLSEXT_cert_compression_zlib, NULL, DecompressZlibCert},
+#endif
+#ifdef HAVE_BROTLI
+  {"brotli", TLSEXT_cert_compression_brotli, NULL, DecompressBrotliCert},
+#endif
+#ifdef HAVE_ZSTD
+  {"zstd", TLSEXT_cert_compression_zstd, NULL, DecompressZstdCert},
+#endif
+};
+
+#define NUM_CERT_COMPRESSION_ALGS \
+  sizeof(cert_compress_algs) / sizeof(cert_compress_algs[0])
+
+/*
+ * curl-impersonate:
+ * Add support for TLS extension 27 - compress_certificate.
+ * This calls the BoringSSL-specific API SSL_CTX_add_cert_compression_alg
+ * for each algorithm specified in cert_compression, which is a comma separated list.
+ */
+static CURLcode add_cert_compression(struct Curl_easy *data,
+                                     SSL_CTX *ctx,
+                                     const char *algorithms)
+{
+  int i;
+  const char *s = algorithms;
+  char *alg_name;
+  size_t alg_name_len;
+  bool found;
+
+  while (s && s[0]) {
+    found = FALSE;
+
+    for(i = 0; i < NUM_CERT_COMPRESSION_ALGS; i++) {
+      alg_name = cert_compress_algs[i].alg_name;
+      alg_name_len = strlen(alg_name);
+      if(strlen(s) >= alg_name_len &&
+         curl_strnequal(s, alg_name, alg_name_len) &&
+         (s[alg_name_len] == ',' || s[alg_name_len] == 0)) {
+        if(!SSL_CTX_add_cert_compression_alg(ctx,
+                    cert_compress_algs[i].alg_id,
+                    cert_compress_algs[i].compress,
+                    cert_compress_algs[i].decompress)) {
+          failf(data, "Error adding certificate compression algorithm '%s'",
+                alg_name);
+          return CURLE_SSL_CIPHER;
+        }
+        s += alg_name_len;
+        if(*s == ',')
+          s += 1;
+        found = TRUE;
+        break;
+      }
+    }
+
+    if(!found) {
+      failf(data, "Invalid compression algorithm list");
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    }
+  }
+
+  return CURLE_OK;
+}
+#else
+static CURLcode add_cert_compression(SSL_CTX *ctx, const char *algorithms)
+{
+  /* No compression algorithms are available. */
+  return CURLE_BAD_FUNCTION_ARGUMENT;
+}
+#endif
+
 /*
  * Our callback from the SSL/TLS layers.
  */
@@ -3871,6 +4165,8 @@ static CURLcode ossl_init_ssl(struct ossl_ctx *octx,
                               void *ssl_user_data,
                               Curl_ossl_init_session_reuse_cb *sess_reuse_cb)
 {
+  struct ssl_connect_data *connssl = cf->ctx;
+
   /* Let's make an SSL structure */
   if(octx->ssl)
     SSL_free(octx->ssl);
@@ -3882,6 +4178,29 @@ static CURLcode ossl_init_ssl(struct ossl_ctx *octx,
 
   SSL_set_app_data(octx->ssl, ssl_user_data);
 
+#ifdef HAS_ALPN_OPENSSL
+  if(connssl->alps) {
+    size_t i;
+    struct alpn_proto_buf proto;
+
+    /* curl-impersonate: Set new ALPS codepoint before adding any ALPS settings */
+    if(data->set.tls_use_new_alps_codepoint) {
+      SSL_set_alps_use_new_codepoint(octx->ssl, 1);
+    }
+
+    for(i = 0; i < connssl->alps->count; ++i) {
+      /* curl-impersonate: Add the ALPS extension (17513) like Chrome does. */
+      // XXX: Firefox does not enable this.
+      SSL_add_application_settings(octx->ssl, connssl->alps->entries[i],
+                                   strlen(connssl->alps->entries[i]), NULL,
+                                   0);
+    }
+
+    Curl_alpn_to_proto_str(&proto, connssl->alps);
+    infof(data, VTLS_INFOF_ALPS_OFFER_1STR, proto.data);
+  }
+#endif
+
 #if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_OCSP)
   if(Curl_ssl_cf_get_primary_config(cf)->verifystatus)
     SSL_set_tlsext_status_type(octx->ssl, TLSEXT_STATUSTYPE_ocsp);
@@ -4002,6 +4321,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   const struct curl_blob *ssl_cert_blob = ssl_config->primary.cert_blob;
   const char * const ssl_cert_type = ssl_config->cert_type;
   const bool verifypeer = conn_config->verifypeer;
+  struct ssl_connect_data *connssl = cf->ctx;
   unsigned int ssl_version_min;
   char error_buffer[256];
 
@@ -4084,7 +4404,14 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   ctx_options = SSL_OP_ALL;
 
 #ifdef SSL_OP_NO_TICKET
-  ctx_options |= SSL_OP_NO_TICKET;
+  if(data->set.ssl_enable_ticket) {
+  /* curl-impersonate:
+   * Turn off SSL_OP_NO_TICKET, we want TLS extension 35 (session_ticket)
+   * to be present in the client hello. */
+    ctx_options &= ~SSL_OP_NO_TICKET;
+  } else {
+    ctx_options |= SSL_OP_NO_TICKET;
+  }
 #endif
 
 #ifdef SSL_OP_NO_COMPRESSION
@@ -4156,6 +4483,20 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   SSL_CTX_set_mode(octx->ssl_ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
 #endif
 
+  SSL_CTX_set_options(octx->ssl_ctx, SSL_OP_LEGACY_SERVER_CONNECT);
+  SSL_CTX_set_mode(octx->ssl_ctx,
+      SSL_MODE_CBC_RECORD_SPLITTING | SSL_MODE_ENABLE_FALSE_START);
+
+  /* curl-impersonate: Enable TLS extensions 18 - signed_certificate_timestamp. */
+  if(data->set.tls_signed_cert_timestamps) {
+    SSL_CTX_enable_signed_cert_timestamps(octx->ssl_ctx);
+  }
+
+  /* curl-impersonate: Enable TLS extensions 5 - status_request */
+  if(data->set.tls_status_request) {
+    SSL_CTX_enable_ocsp_stapling(octx->ssl_ctx);
+  }
+
   ciphers = conn_config->cipher_list;
   if(!ciphers && (peer->transport != TRNSPRT_QUIC))
     ciphers = DEFAULT_CIPHER_SELECTION;
@@ -4229,6 +4570,35 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   }
 #endif
 
+#ifdef HAVE_SSL_CTX_SET_VERIFY_ALGORITHM_PREFS
+  {
+    uint16_t algs[MAX_SIG_ALGS];
+    size_t nalgs;
+    /* curl-impersonate: Set the signature algorithms (TLS extension 13).
+     * See net/socket/ssl_client_socket_impl.cc in Chromium's source. */
+    char *sig_hash_algs = conn_config->sig_hash_algs;
+    if (sig_hash_algs) {
+      CURLcode result = parse_sig_algs(data, sig_hash_algs, algs, &nalgs);
+      if (result)
+        return result;
+      if (!SSL_CTX_set_verify_algorithm_prefs(octx->ssl_ctx, algs, nalgs)) {
+        failf(data, "failed setting signature hash algorithms list: '%s'",
+              sig_hash_algs);
+        return CURLE_SSL_CIPHER;
+      }
+    } else {
+      /* Use defaults from Chrome. */
+      if (!SSL_CTX_set_verify_algorithm_prefs(octx->ssl_ctx,
+                                              default_sig_algs,
+                                              DEFAULT_SIG_ALGS_LENGTH)) {
+        failf(data, "failed setting signature hash algorithms list: '%s'",
+              sig_hash_algs);
+        return CURLE_SSL_CIPHER;
+      }
+    }
+  }
+#endif
+
 #ifdef USE_OPENSSL_SRP
   if(ssl_config->primary.username && Curl_auth_allowed_to_host(data)) {
     char * const ssl_username = ssl_config->primary.username;
@@ -4254,6 +4624,55 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   }
 #endif
 
+  /* curl-impersonate:
+   * Configure BoringSSL to behave like Chrome.
+   * See Constructor of SSLContext at net/socket/ssl_client_socket_impl.cc
+   * and SSLClientSocketImpl::Init()
+   * in the Chromium's source code. */
+
+  /* curl-impersonate: Enable TLS GREASE. */
+  if(data->set.tls_grease) {
+    SSL_CTX_set_grease_enabled(octx->ssl_ctx, 1);
+  }
+
+  /*
+   * curl-impersonate: Enable TLS extension permutation, enabled by default
+   * since Chrome 110.
+   */
+  if(data->set.ssl_permute_extensions) {
+    SSL_CTX_set_permute_extensions(octx->ssl_ctx, 1);
+  }
+
+  /* curl-impersonate: Set TLS extensions order. */
+  if(data->set.str[STRING_TLS_EXTENSION_ORDER]) {
+    SSL_CTX_set_extension_order(octx->ssl_ctx, data->set.str[STRING_TLS_EXTENSION_ORDER]);
+  }
+
+  if(data->set.str[STRING_TLS_DELEGATED_CREDENTIALS]) {
+    SSL_CTX_set_delegated_credentials(octx->ssl_ctx, data->set.str[STRING_TLS_DELEGATED_CREDENTIALS]);
+  }
+
+  if(data->set.tls_record_size_limit) {
+    SSL_CTX_set_record_size_limit(octx->ssl_ctx, data->set.tls_record_size_limit);
+  }
+
+  if(data->set.tls_key_shares_limit) {
+    SSL_CTX_set_key_shares_limit(octx->ssl_ctx, data->set.tls_key_shares_limit);
+  }
+
+  // curl-impersonate: Set key usage check
+  if(data->set.tls_key_usage_no_check) {
+    SSL_CTX_set_key_usage_check_enabled(octx->ssl_ctx, 0);
+  }else{
+    SSL_CTX_set_key_usage_check_enabled(octx->ssl_ctx, 1);
+  }
+
+  if(conn_config->cert_compression &&
+     add_cert_compression(data,
+                          octx->ssl_ctx,
+                          conn_config->cert_compression))
+    return CURLE_SSL_CIPHER;
+
   /* OpenSSL always tries to verify the peer, this only says whether it should
    * fail to connect if the verification fails, or if it should continue
    * anyway. In the latter case the result of the verification is checked with
diff --git a/lib/vtls/vtls.c b/lib/vtls/vtls.c
index db4e57342..560def512 100644
--- a/lib/vtls/vtls.c
+++ b/lib/vtls/vtls.c
@@ -167,6 +167,17 @@ alpn_get_spec(http_majors allowed, bool use_alpn)
      Avoid "http/1.0" because some servers do not support it. */
   return &ALPN_SPEC_H11;
 }
+
+static const struct alpn_spec *alps_get_spec(int httpwant, bool use_alps)
+{
+  if(!use_alps)
+    return NULL;
+#ifdef USE_HTTP2
+  if(httpwant >= CURL_HTTP_VERSION_2)
+    return &ALPN_SPEC_H2;
+#endif
+  return NULL;
+}
 #endif /* USE_SSL */
 
 
@@ -210,6 +221,8 @@ match_ssl_primary_config(struct Curl_easy *data,
      curl_strequal(c1->cipher_list, c2->cipher_list) &&
      curl_strequal(c1->cipher_list13, c2->cipher_list13) &&
      curl_strequal(c1->curves, c2->curves) &&
+     curl_strequal(c1->sig_hash_algs, c2->sig_hash_algs) &&
+     curl_strequal(c1->cert_compression, c2->cert_compression) &&
      curl_strequal(c1->signature_algorithms, c2->signature_algorithms) &&
      curl_strequal(c1->CRLfile, c2->CRLfile) &&
      curl_strequal(c1->pinned_key, c2->pinned_key))
@@ -255,6 +268,8 @@ static bool clone_ssl_primary_config(struct ssl_primary_config *source,
   CLONE_STRING(cipher_list13);
   CLONE_STRING(pinned_key);
   CLONE_STRING(curves);
+  CLONE_STRING(sig_hash_algs);
+  CLONE_STRING(cert_compression);
   CLONE_STRING(signature_algorithms);
   CLONE_STRING(CRLfile);
 #ifdef USE_TLS_SRP
@@ -278,6 +293,8 @@ static void free_primary_ssl_config(struct ssl_primary_config *sslc)
   Curl_safefree(sslc->ca_info_blob);
   Curl_safefree(sslc->issuercert_blob);
   Curl_safefree(sslc->curves);
+  Curl_safefree(sslc->sig_hash_algs);
+  Curl_safefree(sslc->cert_compression);
   Curl_safefree(sslc->signature_algorithms);
   Curl_safefree(sslc->CRLfile);
 #ifdef USE_TLS_SRP
@@ -304,6 +321,8 @@ CURLcode Curl_ssl_easy_config_complete(struct Curl_easy *data)
   data->set.ssl.primary.cert_blob = data->set.blobs[BLOB_CERT];
   data->set.ssl.primary.ca_info_blob = data->set.blobs[BLOB_CAINFO];
   data->set.ssl.primary.curves = data->set.str[STRING_SSL_EC_CURVES];
+  data->set.ssl.primary.sig_hash_algs = data->set.str[STRING_SSL_SIG_HASH_ALGS];
+  data->set.ssl.primary.cert_compression = data->set.str[STRING_SSL_CERT_COMPRESSION];
 #ifdef USE_TLS_SRP
   data->set.ssl.primary.username = data->set.str[STRING_TLSAUTH_USERNAME];
   data->set.ssl.primary.password = data->set.str[STRING_TLSAUTH_PASSWORD];
@@ -455,7 +474,8 @@ static bool ssl_prefs_check(struct Curl_easy *data)
 }
 
 static struct ssl_connect_data *cf_ctx_new(struct Curl_easy *data,
-                                           const struct alpn_spec *alpn)
+                                           const struct alpn_spec *alpn,
+                                           const struct alpn_spec *alps)
 {
   struct ssl_connect_data *ctx;
 
@@ -466,6 +486,7 @@ static struct ssl_connect_data *cf_ctx_new(struct Curl_easy *data,
 
   ctx->ssl_impl = Curl_ssl;
   ctx->alpn = alpn;
+  ctx->alps = alps;
   Curl_bufq_init2(&ctx->earlydata, CURL_SSL_EARLY_MAX, 1, BUFQ_OPT_NO_SPARES);
   ctx->backend = calloc(1, ctx->ssl_impl->sizeof_ssl_backend_data);
   if(!ctx->backend) {
@@ -1644,9 +1665,10 @@ static CURLcode cf_ssl_create(struct Curl_cfilter **pcf,
   DEBUGASSERT(!conn->bits.tls_enable_alpn);
   ctx = cf_ctx_new(data, NULL);
 #else
-  ctx = cf_ctx_new(data, alpn_get_spec(data->state.http_neg.wanted,
-                                       conn->bits.tls_enable_alpn));
+  ctx = cf_ctx_new(data, alpn_get_spec(data->state.http_neg.wanted, conn->bits.tls_enable_alpn),
+                   alps_get_spec(data->state.http_neg.wanted, conn->bits.tls_enable_alps));
 #endif
+
   if(!ctx) {
     result = CURLE_OUT_OF_MEMORY;
     goto out;
@@ -1696,6 +1718,7 @@ static CURLcode cf_ssl_proxy_create(struct Curl_cfilter **pcf,
   struct ssl_connect_data *ctx;
   CURLcode result;
   bool use_alpn = conn->bits.tls_enable_alpn;
+  bool use_alps = conn->bits.tls_enable_alps;
   http_majors allowed = CURL_HTTP_V1x;
 
 #ifdef USE_HTTP2
@@ -1705,7 +1728,8 @@ static CURLcode cf_ssl_proxy_create(struct Curl_cfilter **pcf,
   }
 #endif
 
-  ctx = cf_ctx_new(data, alpn_get_spec(allowed, use_alpn));
+  ctx = cf_ctx_new(data, alpn_get_spec(allowed, use_alpn),
+                   alps_get_spec(allowed, use_alps));
   if(!ctx) {
     result = CURLE_OUT_OF_MEMORY;
     goto out;
diff --git a/lib/vtls/vtls.h b/lib/vtls/vtls.h
index c62b8ae25..1ae8d6b27 100644
--- a/lib/vtls/vtls.h
+++ b/lib/vtls/vtls.h
@@ -58,6 +58,8 @@ struct dynbuf;
   "ALPN: server did not agree on a protocol. Uses default."
 #define VTLS_INFOF_ALPN_OFFER_1STR    \
   "ALPN: curl offers %s"
+#define VTLS_INFOF_ALPS_OFFER_1STR    \
+  "ALPS: offers %s"
 #define VTLS_INFOF_ALPN_ACCEPTED      \
   ALPN_ACCEPTED "%.*s"
 
diff --git a/lib/vtls/vtls_int.h b/lib/vtls/vtls_int.h
index 11987c382..9be95ab36 100644
--- a/lib/vtls/vtls_int.h
+++ b/lib/vtls/vtls_int.h
@@ -110,6 +110,7 @@ struct ssl_connect_data {
   const struct Curl_ssl *ssl_impl;  /* TLS backend for this filter */
   struct ssl_peer peer;             /* peer the filter talks to */
   const struct alpn_spec *alpn;     /* ALPN to use or NULL for none */
+  const struct alpn_spec *alps;     /* ALPS to use or NULL for none */
   void *backend;                    /* vtls backend specific props */
   struct cf_call_data call_data;    /* data handle used in current call */
   struct curltime handshake_done;   /* time when handshake finished */
diff --git a/lib/vtls/vtls_scache.c b/lib/vtls/vtls_scache.c
index 662539cd8..29f545c69 100644
--- a/lib/vtls/vtls_scache.c
+++ b/lib/vtls/vtls_scache.c
@@ -533,6 +533,48 @@ CURLcode Curl_ssl_peer_key_make(struct Curl_cfilter *cf,
     if(r)
       goto out;
   }
+#ifndef CURL_DISABLE_PROXY
+  // make sure SSL sessions started by one proxy are not resumed from a different one
+  if(cf->conn->bits.proxy && cf->conn->bits.proxy_credential_no_reuse) {
+    const char *proxy_type = NULL;
+    const struct proxy_info *p_info = NULL;
+
+    if(cf->conn->bits.httpproxy) {
+      proxy_type = "HTTP";
+      p_info = &cf->conn->http_proxy;
+    }
+    else if(cf->conn->bits.socksproxy) {
+      proxy_type = "SOCKS";
+      p_info = &cf->conn->socks_proxy;
+    }
+
+    if(p_info) {
+      r = curlx_dyn_addf(&buf, ":PTYPE-%s", proxy_type);
+      if(r)
+        goto out;
+      if(p_info->host.name) {
+        r = curlx_dyn_addf(&buf, ":PHOST-%s", p_info->host.name);
+        if(r)
+          goto out;
+      }
+      r = curlx_dyn_addf(&buf, ":PPORT-%d", (int)p_info->port);
+      if(r)
+        goto out;
+      if(p_info->user) {
+        r = curlx_dyn_addf(&buf, ":PUSER-%s", p_info->user);
+        if(r)
+          goto out;
+      }
+      if(p_info->passwd) {
+        // password should not be shared among users. but authless vs auth
+        // proxy should be treated separately.
+        r = curlx_dyn_add(&buf, ":PPW");
+        if(r)
+          goto out;
+      }
+    }
+  }
+#endif
   if(ssl->verifypeer) {
     r = cf_ssl_peer_key_add_path(&buf, "CA", ssl->CAfile, &is_local);
     if(r)
diff --git a/lib/ws.c b/lib/ws.c
index 7f8a688ca..ab34231bc 100644
--- a/lib/ws.c
+++ b/lib/ws.c
@@ -1587,7 +1587,7 @@ const struct Curl_handler Curl_handler_wss = {
   CURLPROTO_WSS,                        /* protocol */
   CURLPROTO_HTTP,                       /* family */
   PROTOPT_SSL | PROTOPT_CREDSPERREQUEST | /* flags */
-  PROTOPT_USERPWDCTRL
+  PROTOPT_USERPWDCTRL | PROTOPT_ALPN
 };
 #endif
 
diff --git a/libcurl.pc.in b/libcurl.pc.in
index c0ba5244a..b5e9cb4ee 100644
--- a/libcurl.pc.in
+++ b/libcurl.pc.in
@@ -35,7 +35,7 @@ Description: Library to transfer files with HTTP, FTP, etc.
 Version: @CURLVERSION@
 Requires: @LIBCURL_PC_REQUIRES@
 Requires.private: @LIBCURL_PC_REQUIRES_PRIVATE@
-Libs: -L${libdir} -lcurl @LIBCURL_PC_LIBS@
+Libs: -L${libdir} -lcurl-impersonate @LIBCURL_PC_LIBS@
 Libs.private: @LIBCURL_PC_LDFLAGS_PRIVATE@ @LIBCURL_PC_LIBS_PRIVATE@
 Cflags: -I${includedir} @LIBCURL_PC_CFLAGS@
 Cflags.private: @LIBCURL_PC_CFLAGS_PRIVATE@
diff --git a/m4/curl-compilers.m4 b/m4/curl-compilers.m4
index dc6d3aa4c..94778e421 100644
--- a/m4/curl-compilers.m4
+++ b/m4/curl-compilers.m4
@@ -393,42 +393,55 @@ AC_DEFUN([CURL_CONVERT_INCLUDE_TO_ISYSTEM], [
   AC_REQUIRE([CURL_SHFUNC_SQUEEZE])dnl
   AC_REQUIRE([CURL_CHECK_COMPILER])dnl
   AC_MSG_CHECKING([convert -I options to -isystem])
-  if test "$compiler_id" = "GNU_C" ||
-    test "$compiler_id" = "CLANG" -o "$compiler_id" = "APPLECLANG"; then
-    AC_MSG_RESULT([yes])
-    tmp_has_include="no"
-    tmp_chg_FLAGS="$CFLAGS"
-    for word1 in $tmp_chg_FLAGS; do
-      case "$word1" in
-        -I*)
-          tmp_has_include="yes"
-          ;;
-      esac
-    done
-    if test "$tmp_has_include" = "yes"; then
-      tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/^-I/ -isystem /g'`
-      tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/ -I/ -isystem /g'`
-      CFLAGS="$tmp_chg_FLAGS"
-      squeeze CFLAGS
-    fi
-    tmp_has_include="no"
-    tmp_chg_FLAGS="$CPPFLAGS"
-    for word1 in $tmp_chg_FLAGS; do
-      case "$word1" in
-        -I*)
-          tmp_has_include="yes"
-          ;;
-      esac
-    done
-    if test "$tmp_has_include" = "yes"; then
-      tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/^-I/ -isystem /g'`
-      tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/ -I/ -isystem /g'`
-      CPPFLAGS="$tmp_chg_FLAGS"
-      squeeze CPPFLAGS
-    fi
-  else
+  case $host_os in
+  darwin*)
+    dnl curl-impersonate: On macos, clang gives priority to /usr/local/include
+    dnl over locations specified with -isystem for some unknown reason. In turn
+    dnl this causes clang to use the system's openssl, which conflicts with
+    dnl curl-impersonate's boringssl headers.
+    dnl To prevent that, disable curl's automatic conversion of -I flags to
+    dnl -isystem.
     AC_MSG_RESULT([no])
-  fi
+    ;;
+  *)
+    if test "$compiler_id" = "GNU_C" ||
+      test "$compiler_id" = "CLANG"; then
+      AC_MSG_RESULT([yes])
+      tmp_has_include="no"
+      tmp_chg_FLAGS="$CFLAGS"
+      for word1 in $tmp_chg_FLAGS; do
+        case "$word1" in
+          -I*)
+            tmp_has_include="yes"
+            ;;
+        esac
+      done
+      if test "$tmp_has_include" = "yes"; then
+        tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/^-I/ -isystem /g'`
+        tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/ -I/ -isystem /g'`
+        CFLAGS="$tmp_chg_FLAGS"
+        squeeze CFLAGS
+      fi
+      tmp_has_include="no"
+      tmp_chg_FLAGS="$CPPFLAGS"
+      for word1 in $tmp_chg_FLAGS; do
+        case "$word1" in
+          -I*)
+            tmp_has_include="yes"
+            ;;
+        esac
+      done
+      if test "$tmp_has_include" = "yes"; then
+        tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/^-I/ -isystem /g'`
+        tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/ -I/ -isystem /g'`
+        CPPFLAGS="$tmp_chg_FLAGS"
+        squeeze CPPFLAGS
+      fi
+    else
+      AC_MSG_RESULT([no])
+    fi
+    ;;
+  esac
 ])
 
 
diff --git a/scripts/singleuse.pl b/scripts/singleuse.pl
index b6ec18b47..0606f50eb 100755
--- a/scripts/singleuse.pl
+++ b/scripts/singleuse.pl
@@ -57,6 +57,7 @@ my %api = (
     'curl_easy_escape' => 'API',
     'curl_easy_getinfo' => 'API',
     'curl_easy_init' => 'API',
+    'curl_easy_impersonate' => 'API',
     'curl_easy_pause' => 'API',
     'curl_easy_perform' => 'API',
     'curl_easy_recv' => 'API',
diff --git a/src/Makefile.am b/src/Makefile.am
index 78e2f8124..6cff00a82 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -46,7 +46,7 @@ AM_CPPFLAGS = -I$(top_srcdir)/include        \
               -I$(top_srcdir)/lib            \
               -I$(srcdir)
 
-bin_PROGRAMS = curl
+bin_PROGRAMS = curl-impersonate
 
 curlinfo_SOURCES = curlinfo.c
 noinst_PROGRAMS = curlinfo
@@ -83,18 +83,18 @@ if USE_UNITY
 curltool_unity.c: $(top_srcdir)/scripts/mk-unity.pl $(CURL_CFILES) $(curl_cfiles_gen) $(curlx_csrc)
 	@PERL@ $(top_srcdir)/scripts/mk-unity.pl --include $(CURL_CFILES) $(curl_cfiles_gen) $(curlx_csrc) > curltool_unity.c
 
-nodist_curl_SOURCES = curltool_unity.c
-curl_SOURCES =
+nodist_curl_impersonate_SOURCES = curltool_unity.c
+curl_impersonate_SOURCES =
 CLEANFILES += curltool_unity.c
 else
-curl_SOURCES = $(CURL_CFILES) $(CURL_HFILES) $(curl_cfiles_gen) $(curl_hfiles_gen) $(curlx_csrc) $(curlx_hsrc)
+curl_impersonate_SOURCES = $(CURL_CFILES) $(CURL_HFILES) $(curl_cfiles_gen) $(curl_hfiles_gen) $(curlx_csrc) $(curlx_hsrc)
 endif
 if HAVE_WINDRES
-curl_SOURCES += $(CURL_RCFILES)
+curl_impersonate_SOURCES += $(CURL_RCFILES)
 $(CURL_RCFILES): tool_version.h
 endif
 
-curl_LDFLAGS = $(AM_LDFLAGS) $(CURL_LDFLAGS_BIN) $(UNICODEFLAG)
+curl_impersonate_LDFLAGS = $(AM_LDFLAGS) $(CURL_LDFLAGS_BIN) $(UNICODEFLAG)
 
 # This might hold -Werror
 CFLAGS += @CURL_CFLAG_EXTRAS@
@@ -102,7 +102,7 @@ CFLAGS += @CURL_CFLAG_EXTRAS@
 # Prevent LIBS from being used for all link targets
 LIBS = $(BLANK_AT_MAKETIME)
 
-curl_LDADD = $(top_builddir)/lib/libcurl.la @LIBCURL_PC_LIBS_PRIVATE@
+curl_impersonate_LDADD = $(top_builddir)/lib/libcurl-impersonate.la @LIBCURL_PC_LIBS_PRIVATE@
 
 # if unit tests are enabled, build a static library to link them with
 if BUILD_UNITTESTS
diff --git a/src/config2setopts.c b/src/config2setopts.c
index 8e4af65ba..ce9371eff 100644
--- a/src/config2setopts.c
+++ b/src/config2setopts.c
@@ -418,6 +418,51 @@ static CURLcode ssl_setopts(struct OperationConfig *config, CURL *curl)
             "--proxy-tls13-ciphers", ssl_backend());
   }
 
+  /* curl-impersonate */
+  if(config->ssl_sig_hash_algs)
+    my_setopt_str(curl, CURLOPT_SSL_SIG_HASH_ALGS,
+                  config->ssl_sig_hash_algs);
+
+  if(config->ssl_cert_compression)
+    my_setopt_str(curl, CURLOPT_SSL_CERT_COMPRESSION,
+                  config->ssl_cert_compression);
+
+  if(config->ssl_permute_extensions)
+    my_setopt(curl, CURLOPT_SSL_PERMUTE_EXTENSIONS, 1L);
+
+  if(config->tls_grease)
+    my_setopt(curl, CURLOPT_TLS_GREASE, 1L);
+
+  if(config->tls_extension_order)
+    my_setopt_str(curl, CURLOPT_TLS_EXTENSION_ORDER, config->tls_extension_order);
+
+  if (config->tls_use_new_alps_codepoint)
+    my_setopt(curl, CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT, 1L);
+
+  if(config->tls_delegated_credentials)
+    my_setopt_str(curl, CURLOPT_TLS_DELEGATED_CREDENTIALS, config->tls_delegated_credentials);
+ 
+  if(config->tls_record_size_limit)
+    my_setopt(curl, CURLOPT_TLS_RECORD_SIZE_LIMIT, config->tls_record_size_limit);
+ 
+  if(config->tls_key_shares_limit)
+    my_setopt(curl, CURLOPT_TLS_KEY_SHARES_LIMIT, config->tls_key_shares_limit);
+
+  if(config->alps) {
+    my_setopt(curl, CURLOPT_SSL_ENABLE_ALPS, 1L);
+  }
+
+  if (config->noticket) {
+    my_setopt(curl, CURLOPT_SSL_ENABLE_TICKET, 0L);
+  }
+
+  if(config->tls_signed_cert_timestamps) {
+    my_setopt(curl, CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS, 1L);
+  }
+
+  my_setopt(curl, CURLOPT_TLS_STATUS_REQUEST, 1L);
+  /* end of curl-impersonate */
+
   /* curl 7.16.0 */
   if(config->disable_sessionid)
     /* disable it */
@@ -509,6 +554,43 @@ static CURLcode http_setopts(struct OperationConfig *config,
   if(config->hsts)
     my_setopt_str(curl, CURLOPT_HSTS, config->hsts);
 
+  /* curl-impersonate */
+  if(config->http2_no_priority)
+    my_setopt(curl,
+              CURLOPT_HTTP2_NO_PRIORITY,
+              config->http2_no_priority);
+
+  if(config->http2_pseudo_headers_order)
+    my_setopt_str(curl,
+                  CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER,
+                  config->http2_pseudo_headers_order);
+
+  if(config->http2_settings)
+    my_setopt_str(curl,
+                  CURLOPT_HTTP2_SETTINGS,
+                  config->http2_settings);
+
+  if(config->http2_window_update)
+    my_setopt(curl,
+              CURLOPT_HTTP2_WINDOW_UPDATE,
+              config->http2_window_update);
+
+  if(config->http2_stream_exclusive)
+    my_setopt(curl,
+              CURLOPT_STREAM_EXCLUSIVE,
+              config->http2_stream_exclusive);
+
+  if(config->http2_stream_weight)
+    my_setopt(curl,
+              CURLOPT_STREAM_WEIGHT,
+              config->http2_stream_weight);
+
+  if(config->http2_streams)
+    my_setopt_str(curl,
+                  CURLOPT_HTTP2_STREAMS,
+                  config->http2_streams);
+  /* end of curl-impersonate */
+
   /* new in 7.47.0 */
   if(config->expect100timeout_ms > 0)
     my_setopt_long(curl, CURLOPT_EXPECT_100_TIMEOUT_MS,
@@ -732,6 +814,12 @@ static CURLcode proxy_setopts(struct OperationConfig *config, CURL *curl)
   if(config->haproxy_clientip)
     my_setopt_str(curl, CURLOPT_HAPROXY_CLIENT_IP, config->haproxy_clientip);
 
+
+  /* curl-impersonate */
+  if (config->proxy_credential_no_reuse) {
+    my_setopt(curl, CURLOPT_PROXY_CREDENTIAL_NO_REUSE, 1L);
+  }
+
   return CURLE_OK;
 }
 
@@ -1117,5 +1205,10 @@ CURLcode config2setopts(struct OperationConfig *config,
   /* new in 8.13.0 */
   if(config->upload_flags)
     my_setopt_long(curl, CURLOPT_UPLOAD_FLAGS, config->upload_flags);
+
+  /* curl-impersonate */
+  if(config->impersonate)
+    my_setopt_str(curl, CURLOPT_IMPERSONATE, config->impersonate);
+
   return result;
 }
diff --git a/src/tool_cfgable.c b/src/tool_cfgable.c
index 975ef2a45..f1a723765 100644
--- a/src/tool_cfgable.c
+++ b/src/tool_cfgable.c
@@ -101,6 +101,15 @@ static void free_config_fields(struct OperationConfig *config)
   tool_safefree(config->proto_str);
   tool_safefree(config->proto_redir_str);
 
+  // curl-impersonate
+  tool_safefree(config->ssl_sig_hash_algs);
+  tool_safefree(config->ssl_cert_compression);
+  tool_safefree(config->http2_pseudo_headers_order);
+  tool_safefree(config->http2_settings);
+  tool_safefree(config->http2_streams);
+  tool_safefree(config->tls_extension_order);
+  tool_safefree(config->impersonate);
+
   urlnode = config->url_list;
   while(urlnode) {
     struct getout *next = urlnode->next;
diff --git a/src/tool_cfgable.h b/src/tool_cfgable.h
index 62ca06ad1..245f45142 100644
--- a/src/tool_cfgable.h
+++ b/src/tool_cfgable.h
@@ -151,6 +151,7 @@ struct OperationConfig {
   char *proxy_key_type;
   char *key_passwd;
   char *proxy_key_passwd;
+  bool proxy_credential_no_reuse;
   char *pubkey;
   char *hostpubmd5;
   char *hostpubsha256;
@@ -159,13 +160,30 @@ struct OperationConfig {
   char *etag_compare_file;
   char *customrequest;
   char *ssl_ec_curves;
+  char *ssl_cert_compression;
+  char *ssl_sig_hash_algs;
   char *ssl_signature_algorithms;
   char *krblevel;
   char *request_target;
+  char *http2_pseudo_headers_order;
+  char *http2_settings;
+  long http2_window_update;
+  long http2_stream_weight;
+  long http2_stream_exclusive;
+  char *http2_streams;
+  char *impersonate;
+  bool http2_no_priority;
+  bool tls_grease;
+  char *tls_extension_order;
+  char *tls_delegated_credentials;
+  long tls_record_size_limit;
+  long tls_key_shares_limit;
+  bool tls_use_new_alps_codepoint;
   char *writeout;           /* %-styled format string to output */
   struct curl_slist *quote;
   struct curl_slist *postquote;
   struct curl_slist *prequote;
+  bool ssl_permute_extensions;
   struct curl_slist *headers;
   struct curl_slist *proxyheaders;
   struct tool_mime *mimeroot;
@@ -222,6 +240,9 @@ struct OperationConfig {
   long alivetime;           /* keepalive-time */
   long alivecnt;            /* keepalive-cnt */
   long gssapi_delegation;
+  bool alps;                      /* enable/disable TLS ALPS extension */
+  bool noticket;                  /* enable/disable TLS session ticket */
+  bool tls_signed_cert_timestamps;    /* curl-impersonate: enable extension 18 */
   long expect100timeout_ms;
   long happy_eyeballs_timeout_ms; /* happy eyeballs timeout in milliseconds.
                                      0 is valid. default: CURL_HET_DEFAULT. */
diff --git a/src/tool_getparam.c b/src/tool_getparam.c
index 4766dade2..6a8512c82 100644
--- a/src/tool_getparam.c
+++ b/src/tool_getparam.c
@@ -85,6 +85,7 @@ static ParameterError getstrn(char **str, const char *val,
 static const struct LongShort aliases[]= {
   {"abstract-unix-socket",       ARG_FILE, ' ', C_ABSTRACT_UNIX_SOCKET},
   {"alpn",                       ARG_BOOL|ARG_NO|ARG_TLS, ' ', C_ALPN},
+  {"alps",                       ARG_BOOL, ' ', C_ALPS},  // curl-impersonate
   {"alt-svc",                    ARG_STRG, ' ', C_ALT_SVC},
   {"anyauth",                    ARG_NONE, ' ', C_ANYAUTH},
   {"append",                     ARG_BOOL, 'a', C_APPEND},
@@ -95,6 +96,7 @@ static const struct LongShort aliases[]= {
   {"cacert",                     ARG_FILE|ARG_TLS, ' ', C_CACERT},
   {"capath",                     ARG_FILE|ARG_TLS, ' ', C_CAPATH},
   {"cert",                       ARG_FILE|ARG_TLS|ARG_CLEAR, 'E', C_CERT},
+  {"cert-compression",           ARG_STRG|ARG_TLS, ' ', C_CERT_COMPRESSION},  // curl-impersonate
   {"cert-status",                ARG_BOOL|ARG_TLS, ' ', C_CERT_STATUS},
   {"cert-type",                  ARG_STRG|ARG_TLS, ' ', C_CERT_TYPE},
   {"ciphers",                    ARG_STRG|ARG_TLS, ' ', C_CIPHERS},
@@ -175,10 +177,18 @@ static const struct LongShort aliases[]= {
   {"http1.0",                    ARG_NONE, '0', C_HTTP1_0},
   {"http1.1",                    ARG_NONE, ' ', C_HTTP1_1},
   {"http2",                      ARG_NONE, ' ', C_HTTP2},
+  {"http2-no-priority",          ARG_BOOL, ' ', C_HTTP2_NO_PRIORITY},  // curl-impersonate
   {"http2-prior-knowledge",      ARG_NONE, ' ', C_HTTP2_PRIOR_KNOWLEDGE},
+  {"http2-pseudo-headers-order", ARG_STRG, ' ', C_HTTP2_PSEUDO_HEADERS_ORDER},  // curl-impersonate
+  {"http2-settings",             ARG_STRG, ' ', C_HTTP2_SETTINGS},  // curl-impersonate
+  {"http2-stream-exclusive",     ARG_STRG, ' ', C_HTTP2_STREAM_EXCLUSIVE},  // curl-impersonate
+  {"http2-stream-weight",        ARG_STRG, ' ', C_HTTP2_STREAM_WEIGHT},  // curl-impersonate
+  {"http2-streams",              ARG_STRG, ' ', C_HTTP2_STREAMS},  // curl-impersonate
+  {"http2-window-update",        ARG_STRG, ' ', C_HTTP2_WINDOW_UPDATE},  // curl-impersonate
   {"http3",                      ARG_NONE|ARG_TLS, ' ', C_HTTP3},
   {"http3-only",                 ARG_NONE|ARG_TLS, ' ', C_HTTP3_ONLY},
   {"ignore-content-length",      ARG_BOOL, ' ', C_IGNORE_CONTENT_LENGTH},
+  {"impersonate",                ARG_STRG, ' ', C_IMPERSONATE},
   {"include",                    ARG_BOOL, ' ', C_INCLUDE},
   {"insecure",                   ARG_BOOL, 'k', C_INSECURE},
   {"interface",                  ARG_STRG, ' ', C_INTERFACE},
@@ -250,6 +260,7 @@ static const struct LongShort aliases[]= {
   {"proxy-cert",                ARG_FILE|ARG_TLS|ARG_CLEAR, ' ', C_PROXY_CERT},
   {"proxy-cert-type",            ARG_STRG|ARG_TLS, ' ', C_PROXY_CERT_TYPE},
   {"proxy-ciphers",              ARG_STRG|ARG_TLS, ' ', C_PROXY_CIPHERS},
+  {"proxy-credential-no-reuse",  ARG_BOOL|ARG_TLS, ' ', C_PROXY_CREDENTIAL_NO_REUSE},
   {"proxy-crlfile",              ARG_FILE|ARG_TLS, ' ', C_PROXY_CRLFILE},
   {"proxy-digest",               ARG_BOOL, ' ', C_PROXY_DIGEST},
   {"proxy-header",               ARG_STRG, ' ', C_PROXY_HEADER},
@@ -300,8 +311,8 @@ static const struct LongShort aliases[]= {
   {"sessionid",                  ARG_BOOL|ARG_NO, ' ', C_SESSIONID},
   {"show-error",                 ARG_BOOL, 'S', C_SHOW_ERROR},
   {"show-headers",               ARG_BOOL, 'i', C_SHOW_HEADERS},
-  {"sigalgs",                    ARG_STRG|ARG_TLS, ' ',
-   C_SIGNATURE_ALGORITHMS},
+  {"sigalgs",                    ARG_STRG|ARG_TLS, ' ', C_SIGNATURE_ALGORITHMS},
+  {"signature-hashes",           ARG_STRG, ' ', C_SIGNATURE_HASHES}, // curl-impersonate
   {"silent",                     ARG_BOOL, 's', C_SILENT},
   {"skip-existing",              ARG_BOOL, ' ', C_SKIP_EXISTING},
   {"socks4",                     ARG_STRG, ' ', C_SOCKS4},
@@ -338,8 +349,17 @@ static const struct LongShort aliases[]= {
   {"tftp-blksize",               ARG_STRG, ' ', C_TFTP_BLKSIZE},
   {"tftp-no-options",            ARG_BOOL, ' ', C_TFTP_NO_OPTIONS},
   {"time-cond",                  ARG_STRG, 'z', C_TIME_COND},
+  {"tls-delegated-credentials",  ARG_STRG, ' ', C_TLS_DELEGATED_CREDENTIALS},  // curl-impersonate
   {"tls-earlydata",              ARG_BOOL|ARG_TLS, ' ', C_TLS_EARLYDATA},
+  {"tls-extension-order",        ARG_STRG, ' ', C_TLS_EXTENSION_ORDER},  // curl-impersonate
+  {"tls-grease",                 ARG_BOOL, ' ', C_TLS_GREASE},  // curl-impersonate
+  {"tls-key-shares-limit",       ARG_STRG, ' ', C_TLS_KEY_SHARES_LIMIT},  // curl-impersonate
   {"tls-max",                    ARG_STRG|ARG_TLS, ' ', C_TLS_MAX},
+  {"tls-permute-extensions",     ARG_BOOL, ' ', C_TLS_PERMUTE_EXTENSIONS},  // curl-impersonate
+  {"tls-record-size-limit",      ARG_STRG, ' ', C_TLS_RECORD_SIZE_LIMIT},  // curl-impersonate
+  {"tls-session-ticket",         ARG_BOOL, ' ', C_TLS_SESSION_TICKET},  // curl-impersonate
+  {"tls-signed-cert-timestamps", ARG_BOOL, ' ', C_TLS_SIGNED_CERT_TIMESTAMPS}, // curl-impersonate
+  {"tls-use-new-alps-codepoint", ARG_BOOL, ' ', C_TLS_USE_NEW_ALPS_CODEPOINT},  // curl-impersonate
   {"tls13-ciphers",              ARG_STRG|ARG_TLS, ' ', C_TLS13_CIPHERS},
   {"tlsauthtype",                ARG_STRG|ARG_TLS, ' ', C_TLSAUTHTYPE},
   {"tlspassword",              ARG_STRG|ARG_TLS|ARG_CLEAR, ' ', C_TLSPASSWORD},
@@ -1771,6 +1791,9 @@ static ParameterError opt_bool(struct OperationConfig *config,
   case C_ALPN: /* --alpn */
     config->noalpn = !toggle;
     break;
+  case C_ALPS:  /* --alps curl-impersonate */
+    config->alps = toggle;
+    break;
   case C_DISABLE_EPSV: /* --disable-epsv */
     config->disable_epsv = toggle;
     break;
@@ -1936,6 +1959,26 @@ static ParameterError opt_bool(struct OperationConfig *config,
   case C_TLS_EARLYDATA: /* --tls-earlydata */
     config->ssl_allow_earlydata = toggle;
     break;
+  case C_TLS_SIGNED_CERT_TIMESTAMPS:
+    config->tls_signed_cert_timestamps = toggle;
+    break;
+  case C_TLS_SESSION_TICKET:  /* --tls-session-ticket curl-impersonate */
+    config->noticket = (!toggle)?TRUE:FALSE;
+    break;
+  case C_TLS_PERMUTE_EXTENSIONS:  /* --tls-permute-extensions curl-impersonate */
+    config->ssl_permute_extensions = toggle;
+    break;
+  case C_TLS_GREASE:  /* --tls-grease curl-impersonate */
+    config->tls_grease = toggle;
+    break;
+  case C_TLS_USE_NEW_ALPS_CODEPOINT: /* --tls-use-new-alps-codepoint curl-impersonate */
+    config->tls_use_new_alps_codepoint = toggle;
+    break;
+  case C_HTTP2_NO_PRIORITY:
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    config->http2_no_priority = toggle;
+    break;
   case C_SUPPRESS_CONNECT_HEADERS: /* --suppress-connect-headers */
     config->suppress_connect_headers = toggle;
     break;
@@ -2144,6 +2187,9 @@ static ParameterError opt_bool(struct OperationConfig *config,
   case C_MPTCP: /* --mptcp */
     config->mptcp = toggle;
     break;
+  case C_PROXY_CREDENTIAL_NO_REUSE: /*  --proxy-credential-no-reuse */
+    config->proxy_credential_no_reuse = toggle;
+    break;
   default:
     return PARAM_OPTION_UNKNOWN;
   }
@@ -2424,6 +2470,57 @@ static ParameterError opt_filestring(struct OperationConfig *config,
   case C_TLS_MAX: /* --tls-max */
     err = str2tls_max(&config->ssl_version_max, nextarg);
     break;
+  case C_TLS_RECORD_SIZE_LIMIT:
+    err = str2unum(&config->tls_record_size_limit, nextarg);
+    break;
+  case C_TLS_KEY_SHARES_LIMIT:
+    err = str2unum(&config->tls_key_shares_limit, nextarg);
+    break;
+  case C_TLS_EXTENSION_ORDER:  /* --tls-extension-order curl-impersonate */
+    err = getstr(&config->tls_extension_order, nextarg, ALLOW_BLANK);
+    break;
+  case C_TLS_DELEGATED_CREDENTIALS:
+    err = getstr(&config->tls_delegated_credentials, nextarg, ALLOW_BLANK);
+    break;
+  case C_HTTP2_PSEUDO_HEADERS_ORDER: /* --http2-pseudo-headers-order curl-impersonate */
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = getstr(&config->http2_pseudo_headers_order, nextarg, ALLOW_BLANK);
+    break;
+  case C_HTTP2_SETTINGS:  /* --http2-settings curl-impersonate */
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = getstr(&config->http2_settings, nextarg, ALLOW_BLANK);
+    break;
+  case C_HTTP2_STREAM_EXCLUSIVE:
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = str2num(&config->http2_stream_exclusive, nextarg);
+    if(config->http2_stream_exclusive < 0) return PARAM_BAD_NUMERIC;
+    break;
+  case C_HTTP2_STREAM_WEIGHT:
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = str2num(&config->http2_stream_weight, nextarg);
+    if(config->http2_stream_weight < 0) return PARAM_BAD_NUMERIC;
+    break;
+  case C_HTTP2_WINDOW_UPDATE:  /* --http2-window-update curl-impersonate */
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = str2num(&config->http2_window_update, nextarg);
+    if(config->http2_window_update < -1) return PARAM_BAD_NUMERIC;
+    break;
+  case C_HTTP2_STREAMS:  /* --http2-streams curl-impersonate */
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = getstr(&config->http2_streams, nextarg, ALLOW_BLANK);
+    break;
+  case C_CERT_COMPRESSION:  /* --cert-compression curl-impersonate */
+    err = getstr(&config->ssl_cert_compression, nextarg, ALLOW_BLANK);
+    break;
+  case C_SIGNATURE_HASHES: /* --signature-hashes */
+    err = getstr(&config->ssl_sig_hash_algs, nextarg, ALLOW_BLANK);
+    break;
   case C_HAPPY_EYEBALLS_TIMEOUT_MS: /* --happy-eyeballs-timeout-ms */
     err = str2unum(&config->happy_eyeballs_timeout_ms, nextarg);
     /* 0 is a valid value for this timeout */
@@ -2456,6 +2553,9 @@ static ParameterError opt_filestring(struct OperationConfig *config,
     else
       err = getstr(&config->hsts, nextarg, ALLOW_BLANK);
     break;
+  case C_IMPERSONATE: /* --impersonate */
+    err = getstr(&config->impersonate, nextarg, DENY_BLANK);
+    break;
   case C_COOKIE: /* --cookie */
     if(strchr(nextarg, '=')) {
       /* A cookie string must have a =-letter */
diff --git a/src/tool_getparam.h b/src/tool_getparam.h
index 50625d144..03dd2e389 100644
--- a/src/tool_getparam.h
+++ b/src/tool_getparam.h
@@ -31,6 +31,7 @@
 typedef enum {
   C_ABSTRACT_UNIX_SOCKET,
   C_ALPN,
+  C_ALPS,
   C_ALT_SVC,
   C_ANYAUTH,
   C_APPEND,
@@ -41,6 +42,7 @@ typedef enum {
   C_CACERT,
   C_CAPATH,
   C_CERT,
+  C_CERT_COMPRESSION,
   C_CERT_STATUS,
   C_CERT_TYPE,
   C_CIPHERS,
@@ -121,10 +123,18 @@ typedef enum {
   C_HTTP1_0,
   C_HTTP1_1,
   C_HTTP2,
+  C_HTTP2_NO_PRIORITY,
   C_HTTP2_PRIOR_KNOWLEDGE,
+  C_HTTP2_PSEUDO_HEADERS_ORDER,
+  C_HTTP2_SETTINGS,
+  C_HTTP2_STREAM_EXCLUSIVE,
+  C_HTTP2_STREAM_WEIGHT,
+  C_HTTP2_STREAMS,
+  C_HTTP2_WINDOW_UPDATE,
   C_HTTP3,
   C_HTTP3_ONLY,
   C_IGNORE_CONTENT_LENGTH,
+  C_IMPERSONATE,
   C_INCLUDE,
   C_INSECURE,
   C_INTERFACE,
@@ -193,6 +203,7 @@ typedef enum {
   C_PROXY_CERT,
   C_PROXY_CERT_TYPE,
   C_PROXY_CIPHERS,
+  C_PROXY_CREDENTIAL_NO_REUSE,
   C_PROXY_CRLFILE,
   C_PROXY_DIGEST,
   C_PROXY_HEADER,
@@ -241,6 +252,7 @@ typedef enum {
   C_SESSIONID,
   C_SHOW_ERROR,
   C_SHOW_HEADERS,
+  C_SIGNATURE_HASHES,
   C_SILENT,
   C_SIGNATURE_ALGORITHMS,
   C_SKIP_EXISTING,
@@ -275,7 +287,16 @@ typedef enum {
   C_TFTP_NO_OPTIONS,
   C_TIME_COND,
   C_TLS_EARLYDATA,
+  C_TLS_DELEGATED_CREDENTIALS,
+  C_TLS_EXTENSION_ORDER,
+  C_TLS_GREASE,
+  C_TLS_KEY_SHARES_LIMIT,
   C_TLS_MAX,
+  C_TLS_PERMUTE_EXTENSIONS,
+  C_TLS_RECORD_SIZE_LIMIT,
+  C_TLS_SESSION_TICKET,
+  C_TLS_SIGNED_CERT_TIMESTAMPS,
+  C_TLS_USE_NEW_ALPS_CODEPOINT,
   C_TLS13_CIPHERS,
   C_TLSAUTHTYPE,
   C_TLSPASSWORD,
diff --git a/src/tool_listhelp.c b/src/tool_listhelp.c
index beb034eea..4f0506ac1 100644
--- a/src/tool_listhelp.c
+++ b/src/tool_listhelp.c
@@ -111,6 +111,27 @@ const struct helptxt helptext[] = {
   {"    --curves <list>",
    "(EC) TLS key exchange algorithms to request",
    CURLHELP_TLS},
+  {"    --signature-hashes <algorithm list>",
+   "TLS signature hash algorithm(s) to use",
+   CURLHELP_TLS},
+  {"    --cert-compression <algorithm list>",
+   "TLS cert compressions algorithm(s) to use",
+   CURLHELP_TLS},
+  {"    --no-tls-session-ticket",
+   "Disable the TLS session ticket extension",
+   CURLHELP_TLS},
+  {"    --http2-pseudo-headers-order",
+   "Change the order of the HTTP2 pseudo headers",
+   CURLHELP_HTTP},
+  {"    --http2-settings",
+   "Change the order and values of the HTTP2 settings frame, e.g. 1:65536;2:0;4:6291456;6:262144",
+   CURLHELP_HTTP},
+  {"    --http2-window-update",
+   "Change the initial value for window update",
+   CURLHELP_HTTP},
+  {"    --tls-permute-extensions",
+   "Enable BoringSSL TLS extensions permutations on client hello",
+   CURLHELP_TLS},
   {"-d, --data <data>",
    "HTTP POST data",
    CURLHELP_IMPORTANT | CURLHELP_HTTP | CURLHELP_POST | CURLHELP_UPLOAD},
@@ -302,6 +323,9 @@ const struct helptxt helptext[] = {
   {"    --ignore-content-length",
    "Ignore the size of the remote resource",
    CURLHELP_HTTP | CURLHELP_FTP},
+  {"    --impersonate <target>",
+   "Impersonate a browser or client",
+   CURLHELP_CURL},
   {"-k, --insecure",
    "Allow insecure server connections",
    CURLHELP_TLS | CURLHELP_SFTP | CURLHELP_SCP | CURLHELP_SSH},
@@ -411,6 +435,9 @@ const struct helptxt helptext[] = {
   {"    --no-alpn",
    "Disable the ALPN TLS extension",
    CURLHELP_TLS | CURLHELP_HTTP},
+  {"    --alps",
+   "Enable the ALPS TLS extension",
+   CURLHELP_TLS | CURLHELP_HTTP},
   {"-N, --no-buffer",
    "Disable buffering of the output stream",
    CURLHELP_OUTPUT},
@@ -517,6 +544,9 @@ const struct helptxt helptext[] = {
   {"    --proxy-ciphers <list>",
    "TLS 1.2 (1.1, 1.0) ciphers to use for proxy",
    CURLHELP_PROXY | CURLHELP_TLS},
+   {"    --proxy-credential-no-reuse",
+   "Disallows reusing connections or ssl sessions over different proxy credentials for the same host",
+   CURLHELP_PROXY | CURLHELP_TLS},
   {"    --proxy-crlfile <file>",
    "Set a CRL list for proxy",
    CURLHELP_PROXY | CURLHELP_TLS},
diff --git a/src/tool_paramhlp.c b/src/tool_paramhlp.c
index 97a6b6e2e..37a01eae1 100644
--- a/src/tool_paramhlp.c
+++ b/src/tool_paramhlp.c
@@ -718,8 +718,8 @@ CURLcode get_args(struct OperationConfig *config, const size_t i)
   if(!result && config->proxyuserpwd)
     result = checkpasswd("proxy", i, last, &config->proxyuserpwd);
 
-  /* Check if we have a user agent */
-  if(!result && !config->useragent) {
+  /* Check if we have a user agent, do not override impersonate value */
+  if(!result && !config->useragent && !config->impersonate) {
     config->useragent = my_useragent();
     if(!config->useragent) {
       errorf(config->global, "out of memory");
diff --git a/src/tool_setopt.c b/src/tool_setopt.c
index 89505979c..89305b0f7 100644
--- a/src/tool_setopt.c
+++ b/src/tool_setopt.c
@@ -156,6 +156,9 @@ static const struct NameValue setopt_nv_CURLNONZERODEFAULTS[] = {
   NV1(CURLOPT_SSL_VERIFYHOST, 1),
   NV1(CURLOPT_SSL_ENABLE_NPN, 1),
   NV1(CURLOPT_SSL_ENABLE_ALPN, 1),
+  NV1(CURLOPT_SSL_ENABLE_TICKET, 1),
+  NV1(CURLOPT_SSL_PERMUTE_EXTENSIONS, 1),
+  NV1(CURLOPT_TLS_STATUS_REQUEST, 1),
   NV1(CURLOPT_TCP_NODELAY, 1),
   NV1(CURLOPT_PROXY_SSL_VERIFYPEER, 1),
   NV1(CURLOPT_PROXY_SSL_VERIFYHOST, 1),
