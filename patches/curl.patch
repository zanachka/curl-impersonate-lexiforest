diff --git a/CMakeLists.txt b/CMakeLists.txt
index c0cc0c57b8..0963d9b7bf 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -174,7 +174,7 @@ else()
   set(CURL_OS "\"${CMAKE_SYSTEM_NAME}\"")
 endif()
 
-set(LIB_NAME "libcurl")
+set(LIB_NAME "libcurl-impersonate")
 
 set_property(DIRECTORY APPEND PROPERTY INCLUDE_DIRECTORIES "${PROJECT_SOURCE_DIR}/include")
 
@@ -2470,7 +2470,7 @@ if(NOT CURL_DISABLE_INSTALL)
       COMMAND ${CMAKE_COMMAND} -P "${CMAKE_CURRENT_BINARY_DIR}/CMake/cmake_uninstall.cmake")
   endif()
 
-  install(FILES "${PROJECT_SOURCE_DIR}/scripts/wcurl"
+  install(FILES "${PROJECT_SOURCE_DIR}/scripts/wcurl-impersonate"
     DESTINATION ${CMAKE_INSTALL_BINDIR}
     PERMISSIONS
       OWNER_READ OWNER_WRITE OWNER_EXECUTE
diff --git a/Makefile.am b/Makefile.am
index 08d59e807f..dbe5a0c893 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -85,13 +85,13 @@ EXTRA_DIST = CHANGES.md COPYING RELEASE-NOTES Dockerfile \
 
 DISTCLEANFILES = buildinfo.txt
 
-bin_SCRIPTS = curl-config
+bin_SCRIPTS = curl-impersonate-config
 
 SUBDIRS = lib docs src scripts
 DIST_SUBDIRS = $(SUBDIRS) tests packages include docs
 
 pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = libcurl.pc
+pkgconfig_DATA = libcurl-impersonate.pc
 
 dist-hook:
 	rm -rf $(top_builddir)/tests/log
diff --git a/configure.ac b/configure.ac
index bce4bf69e7..cf7b1500b0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1476,7 +1476,11 @@ if test X"$OPT_BROTLI" != Xno; then
   CPPFLAGS="$CPPFLAGS $CPP_BROTLI"
   LIBS="$LIB_BROTLI $LIBS"
 
-  AC_CHECK_LIB(brotlidec, BrotliDecoderDecompress)
+  AC_CHECK_LIB(brotlidec, BrotliDecoderDecompress,
+    # curl-impersonate: Define 'action-if-found' explicitly to prevent
+    # -lbrotlidec from being added to LIBS (already added before)
+    AC_DEFINE(HAVE_LIBBROTLI, 1, [Define to 1 if libbrotli exists])
+  )
 
   AC_CHECK_HEADERS(brotli/decode.h,
     curl_brotli_msg="enabled (libbrotlidec)"
@@ -5472,6 +5476,8 @@ SUPPORT_PROTOCOLS=`echo $SUPPORT_PROTOCOLS | tr ' ' '\012' | sort | tr '\012' '
 
 AC_SUBST(SUPPORT_PROTOCOLS)
 
+AC_CHECK_FUNCS([SSL_set_alps_use_new_codepoint])
+
 dnl squeeze whitespace out of some variables
 
 squeeze CFLAGS
@@ -5526,8 +5532,8 @@ AC_CONFIG_FILES([\
   tests/http/Makefile \
   packages/Makefile \
   packages/vms/Makefile \
-  curl-config \
-  libcurl.pc
+  curl-impersonate-config:curl-config.in \
+  libcurl-impersonate.pc:libcurl.pc.in
 ])
 AC_OUTPUT
 
diff --git a/curl-config.in b/curl-config.in
index 31ea30b24a..6534c11666 100644
--- a/curl-config.in
+++ b/curl-config.in
@@ -155,9 +155,9 @@ while test "$#" -gt 0; do
       curllibdir=''
     fi
     if test 'X@ENABLE_SHARED@' = 'Xno'; then
-      echo "${curllibdir}-lcurl @LIBCURL_PC_LIBS_PRIVATE@"
+      echo "${curllibdir}-lcurl-impersonate @LIBCURL_PC_LIBS_PRIVATE@"
     else
-      echo "${curllibdir}-lcurl"
+      echo "${curllibdir}-lcurl-impersonate"
     fi
     ;;
 
@@ -167,7 +167,7 @@ while test "$#" -gt 0; do
 
   --static-libs)
     if test 'X@ENABLE_STATIC@' != 'Xno'; then
-      echo "@libdir@/libcurl.@libext@ @LIBCURL_PC_LDFLAGS_PRIVATE@ @LIBCURL_PC_LIBS_PRIVATE@"
+      echo "@libdir@/libcurl-impersonate.@libext@ @LIBCURL_PC_LDFLAGS_PRIVATE@ @LIBCURL_PC_LIBS_PRIVATE@"
     else
       echo 'curl was built with static libraries disabled' >&2
       exit 1
diff --git a/docs/CMakeLists.txt b/docs/CMakeLists.txt
index 5f342954cc..e63b7aa100 100644
--- a/docs/CMakeLists.txt
+++ b/docs/CMakeLists.txt
@@ -30,7 +30,7 @@ if(ENABLE_CURL_MANUAL AND BUILD_CURL_EXE)
 endif()
 
 if(BUILD_MISC_DOCS)
-  foreach(_man_misc IN ITEMS "curl-config" "mk-ca-bundle" "wcurl" "runtests" "testcurl")
+  foreach(_man_misc IN ITEMS "curl-config" "mk-ca-bundle" "wcurl-impersonate" "runtests" "testcurl")
     set(_man_target "${CMAKE_CURRENT_BINARY_DIR}/${_man_misc}.1")
     add_custom_command(OUTPUT "${_man_target}"
       WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
diff --git a/docs/Makefile.am b/docs/Makefile.am
index 554657e889..aaa5e84907 100644
--- a/docs/Makefile.am
+++ b/docs/Makefile.am
@@ -29,10 +29,10 @@ if BUILD_DOCS
 MK_CA_DOCS = mk-ca-bundle.1
 CURLCONF_DOCS = curl-config.1
 TEST_DOCS = runtests.1 testcurl.1
-man_MANS = curl-config.1 wcurl.1
+man_MANS = curl-config.1 wcurl-impersonate.1
 endif
 
-CURLPAGES = curl-config.md mk-ca-bundle.md wcurl.md runtests.md testcurl.md
+CURLPAGES = curl-config.md mk-ca-bundle.md wcurl-impersonate.md runtests.md testcurl.md
 
 SUBDIRS = . cmdline-opts libcurl
 DIST_SUBDIRS = $(SUBDIRS) examples
@@ -144,7 +144,7 @@ curl-config.1: curl-config.md
 
 mk-ca-bundle.1: mk-ca-bundle.md
 
-wcurl.1: wcurl.md
+wcurl-impersonate.1: wcurl-impersonate.md
 
 distclean:
 	rm -f $(CLEANFILES)
diff --git a/docs/wcurl-impersonate.md b/docs/wcurl-impersonate.md
new file mode 100644
index 0000000000..3d5a9759b8
--- /dev/null
+++ b/docs/wcurl-impersonate.md
@@ -0,0 +1,151 @@
+---
+c: Copyright (C) Samuel Henrique <samueloph@debian.org>, Sergio Durigan Junior <sergiodj@debian.org> and many contributors, see the AUTHORS file.
+SPDX-License-Identifier: curl
+Title: wcurl-impersonate
+Section: 1
+Source: wcurl-impersonate
+See-also:
+  - curl (1)
+  - trurl (1)
+Added-in: n/a
+---
+
+# NAME
+
+**wcurl-impersonate** - a simple wrapper around curl-impersonate to easily
+download files.
+
+# SYNOPSIS
+
+**wcurl-impersonate \<URL\>...**
+
+**wcurl-impersonate [--curl-options \<CURL_OPTIONS\>]... [--dry-run] [--no-decode-filename] [-o|-O|--output \<PATH\>] [--] \<URL\>...**
+
+**wcurl-impersonate [--curl-options=\<CURL_OPTIONS\>]... [--dry-run] [--no-decode-filename] [--output=\<PATH\>] [--] \<URL\>...**
+
+**wcurl-impersonate -V|--version**
+
+**wcurl-impersonate -h|--help**
+
+# DESCRIPTION
+
+**wcurl-impersonate** is a simple curl wrapper which lets you use
+curl-impersonate to download files without having to remember any parameters.
+
+Simply call **wcurl-impersonate** with a list of URLs you want to download and
+**wcurl-impersonate** picks sane defaults.
+
+If you need anything more complex, you can provide any of curl-impersonate's
+supported
+parameters via the **--curl-options** option. Just beware that you likely
+should be using curl-impersonate directly if your use case is not covered.
+
+By default, **wcurl-impersonate** does:
+
+## * Percent-encode whitespaces in URLs;
+
+## * Download multiple URLs in parallel
+    if the installed curl-impersonate's version is \>= 7.66.0 (--parallel);
+
+## * Follow redirects;
+
+## * Automatically choose a filename as output;
+
+## * Avoid overwriting files
+     if the installed curl-impersonate's version is \>= 7.83.0 (--no-clobber);
+
+## * Perform retries;
+
+## * Set the downloaded file timestamp
+    to the value provided by the server, if available;
+
+## * Default to https
+    if the URL does not contain any scheme;
+
+## * Disable curl-impersonate's URL globbing parser
+    so {} and [] characters in URLs are not treated specially;
+
+## * Percent-decode the resulting filename;
+
+## * Use 'index.html' as the default filename
+    if there is none in the URL.
+
+# OPTIONS
+
+## --curl-options, --curl-options=\<CURL_OPTIONS\>...
+
+Specify extra options to be passed when invoking curl-impersonate. May be
+specified more than once.
+
+## -o, -O, --output, --output=\<PATH\>
+
+Use the provided output path instead of getting it from the URL. If multiple
+URLs are provided, resulting files share the same name with a number appended to
+the end (curl-impersonate \>= 7.83.0). If this option is provided multiple
+times, only the last value is considered.
+
+## --no-decode-filename
+
+Don't percent-decode the output filename, even if the percent-encoding in the
+URL was done by **wcurl-impersonate**, e.g.: The URL contained whitespaces.
+
+## --dry-run
+
+Do not actually execute curl-impersonate, just print what would be invoked.
+
+## -V, \--version
+
+Print version information.
+
+## -h, \--help
+
+Print help message.
+
+# CURL_OPTIONS
+
+Any option supported by curl-impersonate can be set here. This is not used by
+**wcurl-impersonate**; it is instead forwarded to the curl-impersonate
+invocation.
+
+# URL
+
+URL to be downloaded. Anything that is not a parameter is considered
+an URL. Whitespaces are percent-encoded and the URL is passed to
+curl-impersonate, which then performs the parsing. May be specified more than
+once.
+
+# EXAMPLES
+
+Download a single file:
+
+**wcurl-impersonate example.com/filename.txt**
+
+Download two files in parallel:
+
+**wcurl-impersonate example.com/filename1.txt example.com/filename2.txt**
+
+Download a file passing the **--progress-bar** and **--http2** flags to
+curl-impersonate:
+
+**wcurl-impersonate --curl-options="--progress-bar --http2" example.com/filename.txt**
+
+Resume from an interrupted download (if more options are used, this needs to
+be the last one in the list):
+
+**wcurl-impersonate --curl-options="--continue-at -" example.com/filename.txt**
+
+# AUTHORS
+
+    Samuel Henrique \<samueloph@debian.org\>
+    Sergio Durigan Junior \<sergiodj@debian.org\>
+    and many contributors, see the AUTHORS file.
+
+# REPORTING BUGS
+
+If you experience any problems with **wcurl-impersonate** that you do not
+experience with curl-impersonate, submit an issue on Github:
+https://github.com/curl/wcurl
+
+# COPYRIGHT
+
+**wcurl-impersonate** is licensed under the curl license
diff --git a/docs/wcurl.md b/docs/wcurl.md
deleted file mode 100644
index 4111af5226..0000000000
--- a/docs/wcurl.md
+++ /dev/null
@@ -1,145 +0,0 @@
----
-c: Copyright (C) Samuel Henrique <samueloph@debian.org>, Sergio Durigan Junior <sergiodj@debian.org> and many contributors, see the AUTHORS file.
-SPDX-License-Identifier: curl
-Title: wcurl
-Section: 1
-Source: wcurl
-See-also:
-  - curl (1)
-  - trurl (1)
-Added-in: n/a
----
-
-# NAME
-
-**wcurl** - a simple wrapper around curl to easily download files.
-
-# SYNOPSIS
-
-**wcurl \<URL\>...**
-
-**wcurl [--curl-options \<CURL_OPTIONS\>]... [--dry-run] [--no-decode-filename] [-o|-O|--output \<PATH\>] [--] \<URL\>...**
-
-**wcurl [--curl-options=\<CURL_OPTIONS\>]... [--dry-run] [--no-decode-filename] [--output=\<PATH\>] [--] \<URL\>...**
-
-**wcurl -V|--version**
-
-**wcurl -h|--help**
-
-# DESCRIPTION
-
-**wcurl** is a simple curl wrapper which lets you use curl to download files
-without having to remember any parameters.
-
-Simply call **wcurl** with a list of URLs you want to download and **wcurl**
-picks sane defaults.
-
-If you need anything more complex, you can provide any of curl's supported
-parameters via the **--curl-options** option. Just beware that you likely
-should be using curl directly if your use case is not covered.
-
-By default, **wcurl** does:
-
-## * Percent-encode whitespaces in URLs;
-
-## * Download multiple URLs in parallel
-    if the installed curl's version is \>= 7.66.0 (--parallel);
-
-## * Follow redirects;
-
-## * Automatically choose a filename as output;
-
-## * Avoid overwriting files
-     if the installed curl's version is \>= 7.83.0 (--no-clobber);
-
-## * Perform retries;
-
-## * Set the downloaded file timestamp
-    to the value provided by the server, if available;
-
-## * Default to https
-    if the URL does not contain any scheme;
-
-## * Disable curl's URL globbing parser
-    so {} and [] characters in URLs are not treated specially;
-
-## * Percent-decode the resulting filename;
-
-## * Use 'index.html' as the default filename
-    if there is none in the URL.
-
-# OPTIONS
-
-## --curl-options, --curl-options=\<CURL_OPTIONS\>...
-
-Specify extra options to be passed when invoking curl. May be specified more
-than once.
-
-## -o, -O, --output, --output=\<PATH\>
-
-Use the provided output path instead of getting it from the URL. If multiple
-URLs are provided, resulting files share the same name with a number appended to
-the end (curl \>= 7.83.0). If this option is provided multiple times, only the
-last value is considered.
-
-## --no-decode-filename
-
-Don't percent-decode the output filename, even if the percent-encoding in the
-URL was done by **wcurl**, e.g.: The URL contained whitespaces.
-
-## --dry-run
-
-Do not actually execute curl, just print what would be invoked.
-
-## -V, \--version
-
-Print version information.
-
-## -h, \--help
-
-Print help message.
-
-# CURL_OPTIONS
-
-Any option supported by curl can be set here. This is not used by **wcurl**; it
-is instead forwarded to the curl invocation.
-
-# URL
-
-URL to be downloaded. Anything that is not a parameter is considered
-an URL. Whitespaces are percent-encoded and the URL is passed to curl, which
-then performs the parsing. May be specified more than once.
-
-# EXAMPLES
-
-Download a single file:
-
-**wcurl example.com/filename.txt**
-
-Download two files in parallel:
-
-**wcurl example.com/filename1.txt example.com/filename2.txt**
-
-Download a file passing the **--progress-bar** and **--http2** flags to curl:
-
-**wcurl --curl-options="--progress-bar --http2" example.com/filename.txt**
-
-Resume from an interrupted download (if more options are used, this needs to
-be the last one in the list):
-
-**wcurl --curl-options="--continue-at -" example.com/filename.txt**
-
-# AUTHORS
-
-    Samuel Henrique \<samueloph@debian.org\>
-    Sergio Durigan Junior \<sergiodj@debian.org\>
-    and many contributors, see the AUTHORS file.
-
-# REPORTING BUGS
-
-If you experience any problems with **wcurl** that you do not experience with
-curl, submit an issue on Github: https://github.com/curl/wcurl
-
-# COPYRIGHT
-
-**wcurl** is licensed under the curl license
diff --git a/export.sh b/export.sh
new file mode 100755
index 0000000000..0b981b811c
--- /dev/null
+++ b/export.sh
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+# TODO: use cmake to generate mingw makefile, see:
+#
+# 1. https://github.com/curl/curl/pull/13244/files
+# 2. https://everything.curl.dev/build/windows.html
+
+git df curl-8_15_0 > chrome.patch
+mv chrome.patch ../curl-impersonate/patches/curl.patch
diff --git a/include/curl/curl.h b/include/curl/curl.h
index 7ef5b99349..7b86cb7afd 100644
--- a/include/curl/curl.h
+++ b/include/curl/curl.h
@@ -2249,6 +2249,116 @@ typedef enum {
   /* set TLS supported signature algorithms */
   CURLOPT(CURLOPT_SSL_SIGNATURE_ALGORITHMS, CURLOPTTYPE_STRINGPOINT, 328),
 
+  /* curl-impersonate: The master option for setting an impersonate target */
+  CURLOPT(CURLOPT_IMPERSONATE, CURLOPTTYPE_STRINGPOINT, 999),
+
+  /* curl-impersonate: A list of headers used by the impersonated browser.
+   * If given, merged with CURLOPT_HTTPHEADER. */
+  CURLOPT(CURLOPT_HTTPBASEHEADER, CURLOPTTYPE_SLISTPOINT, 1000),
+
+  /* curl-impersonate: A list of TLS signature hash algorithms.
+   * This has been implemented by curl as option 328, but we will keep it for compatibility.
+   * See https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.1.4.1 */
+  CURLOPT(CURLOPT_SSL_SIG_HASH_ALGS, CURLOPTTYPE_STRINGPOINT, 1001),
+
+  /* curl-impersonate: Whether to enable ALPS in TLS or not.
+   * See https://datatracker.ietf.org/doc/html/draft-vvv-tls-alps.
+   * Support for ALPS is minimal and is intended only for the TLS client
+   * hello to match. */
+  CURLOPT(CURLOPT_SSL_ENABLE_ALPS, CURLOPTTYPE_LONG, 1002),
+
+  /* curl-impersonate: Comma-separated list of certificate compression
+   * algorithms to use. These are published in the client hello.
+   * Supported algorithms are "zlib" and "brotli".
+   * See https://datatracker.ietf.org/doc/html/rfc8879 */
+  CURLOPT(CURLOPT_SSL_CERT_COMPRESSION, CURLOPTTYPE_STRINGPOINT, 1003),
+
+  /* Enable/disable TLS session ticket extension (RFC5077) */
+  CURLOPT(CURLOPT_SSL_ENABLE_TICKET, CURLOPTTYPE_LONG, 1004),
+
+  /*
+   * curl-impersonate:
+   * Set the order of the HTTP/2 pseudo headers. The value must contain
+   * the letters 'm', 'a', 's', 'p' representing the pseudo-headers
+   * ":method", ":authority", ":scheme", ":path" in the desired order of
+   * appearance in the HTTP/2 HEADERS frame.
+   */
+  CURLOPT(CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER, CURLOPTTYPE_STRINGPOINT, 1005),
+
+  /* curl-impersonate: HTTP2 settings frame keys and values, format: 1:v;2:v;3:v */
+  CURLOPT(CURLOPT_HTTP2_SETTINGS, CURLOPTTYPE_STRINGPOINT, 1006),
+
+  /*
+   * curl-impersonate: Whether to enable Boringssl permute extensions
+   * See https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#SSL_set_permute_extensions.
+   */
+  CURLOPT(CURLOPT_SSL_PERMUTE_EXTENSIONS, CURLOPTTYPE_LONG, 1007),
+
+  /* curl-impersonate: HTTP2 initial window update */
+  CURLOPT(CURLOPT_HTTP2_WINDOW_UPDATE, CURLOPTTYPE_LONG, 1008),
+
+  /* curl-impersonate: Set the initial streams settings for http2. */
+  CURLOPT(CURLOPT_HTTP2_STREAMS, CURLOPTTYPE_STRINGPOINT, 1010),
+
+  /* curl-impersonate: enable tls grease */
+  CURLOPT(CURLOPT_TLS_GREASE, CURLOPTTYPE_LONG, 1011),
+
+  /* curl-impersonate: set tls extension order */
+  CURLOPT(CURLOPT_TLS_EXTENSION_ORDER, CURLOPTTYPE_STRINGPOINT, 1012),
+
+  /* curl-impersonate: Set stream exclusiveness, 0 or 1 */
+  CURLOPT(CURLOPT_STREAM_EXCLUSIVE, CURLOPTTYPE_LONG, 1013),
+
+  /* curl-impersonate: enable tls key usage check, defaults: on */
+  CURLOPT(CURLOPT_TLS_KEY_USAGE_NO_CHECK, CURLOPTTYPE_LONG, 1014),
+
+  /* curl-impersonate: enable tls signed cert stamps */
+  CURLOPT(CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS, CURLOPTTYPE_LONG, 1015),
+
+  /* curl-impersonate: enable tls status request */
+  CURLOPT(CURLOPT_TLS_STATUS_REQUEST, CURLOPTTYPE_LONG, 1016),
+
+  /* curl-impersonate: firefox delegated credentials */
+  CURLOPT(CURLOPT_TLS_DELEGATED_CREDENTIALS, CURLOPTTYPE_STRINGPOINT, 1017),
+
+  /* curl-impersonate: firefox record size limit */
+  CURLOPT(CURLOPT_TLS_RECORD_SIZE_LIMIT, CURLOPTTYPE_LONG, 1018),
+
+  /* curl-impersonate: firefox key_shares_limit */
+  CURLOPT(CURLOPT_TLS_KEY_SHARES_LIMIT, CURLOPTTYPE_LONG, 1019),
+
+  /* curl-impersonate: Use the new ALPS code point */
+  CURLOPT(CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT, CURLOPTTYPE_LONG, 1020),
+
+  /* curl-impersonate: Do not set the priority bit in http2 header frame */
+  CURLOPT(CURLOPT_HTTP2_NO_PRIORITY, CURLOPTTYPE_LONG, 1021),
+
+  /* curl-impersonate: Do not reuse TLS sessions or connections from different proxy credentials */
+  CURLOPT(CURLOPT_PROXY_CREDENTIAL_NO_REUSE, CURLOPTTYPE_LONG, 1022),
+
+  /* curl-impersonate: Split cookies into separate Cookie headers */
+  CURLOPT(CURLOPT_SPLIT_COOKIES, CURLOPTTYPE_LONG, 1023),
+
+  /* curl-impersonate: Set multipart/form-data boundary style */
+  CURLOPT(CURLOPT_FORM_BOUNDARY, CURLOPTTYPE_STRINGPOINT, 1024),
+
+  /*
+   * curl-impersonate:
+   * Set the order of the HTTP/3 pseudo headers. The value must contain
+   * the letters 'm', 'a', 's', 'p' representing the pseudo-headers
+   * ":method", ":authority", ":scheme", ":path" in the desired order of
+   * appearance in the HTTP/3 HEADERS frame.
+   *
+   * This is very similar to the http/2 option.
+   */
+  CURLOPT(CURLOPT_HTTP3_PSEUDO_HEADERS_ORDER, CURLOPTTYPE_STRINGPOINT, 1025),
+
+  /* curl-impersonate: HTTP3 settings frame keys and values, format: 1:v;6:v;7:v */
+  CURLOPT(CURLOPT_HTTP3_SETTINGS, CURLOPTTYPE_STRINGPOINT, 1026),
+
+  /* curl-impersonate: QUIC transport parameters, format: id:value;id:value */
+  CURLOPT(CURLOPT_QUIC_TRANSPORT_PARAMETERS, CURLOPTTYPE_STRINGPOINT, 1027),
+
   CURLOPT_LASTENTRY /* the last unused */
 } CURLoption;
 
diff --git a/include/curl/curlver.h b/include/curl/curlver.h
index b3fc29b91c..0edf9b98f7 100644
--- a/include/curl/curlver.h
+++ b/include/curl/curlver.h
@@ -32,7 +32,7 @@
 
 /* This is the version number of the libcurl package from which this header
    file origins: */
-#define LIBCURL_VERSION "8.15.0-DEV"
+#define LIBCURL_VERSION "8.15.0-IMPERSONATE"
 
 /* The numeric version number is also available "in parts" by using these
    defines: */
diff --git a/include/curl/easy.h b/include/curl/easy.h
index 56f8060e04..1a348c502c 100644
--- a/include/curl/easy.h
+++ b/include/curl/easy.h
@@ -43,6 +43,17 @@ CURL_EXTERN CURLcode curl_easy_setopt(CURL *curl, CURLoption option, ...);
 CURL_EXTERN CURLcode curl_easy_perform(CURL *curl);
 CURL_EXTERN void curl_easy_cleanup(CURL *curl);
 
+/*
+ * curl-impersonate: Tell libcurl to impersonate a browser.
+ * This is a wrapper function that calls curl_easy_setopt()
+ * multiple times with all the parameters required. That's also why it was
+ * created as a separate API function and not just as another option to
+ * curl_easy_setopt().
+ */
+CURL_EXTERN CURLcode curl_easy_impersonate(CURL *curl, const char *target,
+                                           int default_headers);
+
+
 /*
  * NAME curl_easy_getinfo()
  *
diff --git a/include/curl/typecheck-gcc.h b/include/curl/typecheck-gcc.h
index ca0c0ef9d6..8bd314c486 100644
--- a/include/curl/typecheck-gcc.h
+++ b/include/curl/typecheck-gcc.h
@@ -345,8 +345,15 @@ CURLWARNING(_curl_easy_getinfo_err_curl_off_t,
    (option) == CURLOPT_FTP_ACCOUNT ||                                   \
    (option) == CURLOPT_FTP_ALTERNATIVE_TO_USER ||                       \
    (option) == CURLOPT_FTPPORT ||                                       \
+   (option) == CURLOPT_FORM_BOUNDARY ||                                 \
    (option) == CURLOPT_HAPROXY_CLIENT_IP ||                             \
    (option) == CURLOPT_HSTS ||                                          \
+   (option) == CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER ||                    \
+   (option) == CURLOPT_HTTP2_SETTINGS ||                                \
+   (option) == CURLOPT_HTTP2_STREAMS ||                                 \
+   (option) == CURLOPT_HTTP3_PSEUDO_HEADERS_ORDER ||                    \
+   (option) == CURLOPT_HTTP3_SETTINGS ||                                \
+   (option) == CURLOPT_QUIC_TRANSPORT_PARAMETERS ||                     \
    (option) == CURLOPT_INTERFACE ||                                     \
    (option) == CURLOPT_ISSUERCERT ||                                    \
    (option) == CURLOPT_KEYPASSWD ||                                     \
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 75fbbdf4b9..2d57e33670 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -35,7 +35,7 @@ EXTRA_DIST = config-mac.h config-os400.h config-plan9.h config-riscos.h \
   config-win32.h curl_config.h.in $(LIB_RCFILES) libcurl.def            \
   $(CMAKE_DIST) Makefile.soname optiontable.pl $(CHECKSRC_DIST)
 
-lib_LTLIBRARIES = libcurl.la
+lib_LTLIBRARIES = libcurl-impersonate.la
 
 if BUILD_UNITTESTS
 noinst_LTLIBRARIES = libcurlu.la
@@ -84,63 +84,63 @@ if USE_UNITY
 libcurl_unity.c: $(top_srcdir)/scripts/mk-unity.pl $(CSOURCES)
 	@PERL@ $(top_srcdir)/scripts/mk-unity.pl --include $(CSOURCES) > libcurl_unity.c
 
-nodist_libcurl_la_SOURCES = libcurl_unity.c
-libcurl_la_SOURCES =
+nodist_libcurl_impersonate_la_SOURCES = libcurl_unity.c
+libcurl_impersonate_la_SOURCES =
 nodist_libcurlu_la_SOURCES = libcurl_unity.c
 libcurlu_la_SOURCES =
 CLEANFILES = libcurl_unity.c
 else
-libcurl_la_SOURCES = $(CSOURCES) $(HHEADERS)
+libcurl_impersonate_la_SOURCES = $(CSOURCES) $(HHEADERS)
 libcurlu_la_SOURCES = $(CSOURCES) $(HHEADERS)
 CLEANFILES =
 endif
 
 CLEANFILES += $(UNITPROTOS)
 
-libcurl_la_CPPFLAGS_EXTRA =
-libcurl_la_LDFLAGS_EXTRA =
-libcurl_la_CFLAGS_EXTRA =
+libcurl_impersonate_la_CPPFLAGS_EXTRA =
+libcurl_impersonate_la_LDFLAGS_EXTRA =
+libcurl_impersonate_la_CFLAGS_EXTRA =
 
 if CURL_LT_SHLIB_USE_VERSION_INFO
 # Get VERSIONCHANGE, VERSIONADD, VERSIONDEL, VERSIONINFO variables
 include Makefile.soname
-libcurl_la_LDFLAGS_EXTRA += $(VERSIONINFO)
+libcurl_impersonate_la_LDFLAGS_EXTRA += $(VERSIONINFO)
 endif
 
 if CURL_LT_SHLIB_USE_NO_UNDEFINED
-libcurl_la_LDFLAGS_EXTRA += -no-undefined
+libcurl_impersonate_la_LDFLAGS_EXTRA += -no-undefined
 endif
 
 if CURL_LT_SHLIB_USE_MIMPURE_TEXT
-libcurl_la_LDFLAGS_EXTRA += -mimpure-text
+libcurl_impersonate_la_LDFLAGS_EXTRA += -mimpure-text
 endif
 
 if CURL_LT_SHLIB_USE_VERSIONED_SYMBOLS
-libcurl_la_LDFLAGS_EXTRA += -Wl,--version-script=libcurl.vers
+libcurl_impersonate_la_LDFLAGS_EXTRA += -Wl,--version-script=libcurl.vers
 else
 # if symbol-hiding is enabled, hide them!
 if DOING_CURL_SYMBOL_HIDING
-libcurl_la_LDFLAGS_EXTRA += -export-symbols-regex '^curl_.*'
+libcurl_impersonate_la_LDFLAGS_EXTRA += -export-symbols-regex '^curl_.*'
 endif
 endif
 
 if USE_CPPFLAG_CURL_STATICLIB
-libcurl_la_CPPFLAGS_EXTRA += -DCURL_STATICLIB
+libcurl_impersonate_la_CPPFLAGS_EXTRA += -DCURL_STATICLIB
 else
 if HAVE_WINDRES
-libcurl_la_SOURCES += $(LIB_RCFILES)
+libcurl_impersonate_la_SOURCES += $(LIB_RCFILES)
 $(LIB_RCFILES): $(top_srcdir)/include/curl/curlver.h
 endif
 endif
 
 if DOING_CURL_SYMBOL_HIDING
-libcurl_la_CPPFLAGS_EXTRA += -DCURL_HIDDEN_SYMBOLS
-libcurl_la_CFLAGS_EXTRA += $(CFLAG_CURL_SYMBOL_HIDING)
+libcurl_impersonate_la_CPPFLAGS_EXTRA += -DCURL_HIDDEN_SYMBOLS
+libcurl_impersonate_la_CFLAGS_EXTRA += $(CFLAG_CURL_SYMBOL_HIDING)
 endif
 
-libcurl_la_CPPFLAGS = $(AM_CPPFLAGS) $(libcurl_la_CPPFLAGS_EXTRA)
-libcurl_la_LDFLAGS = $(AM_LDFLAGS) $(libcurl_la_LDFLAGS_EXTRA) $(CURL_LDFLAGS_LIB) $(LIBCURL_PC_LIBS_PRIVATE)
-libcurl_la_CFLAGS = $(AM_CFLAGS) $(libcurl_la_CFLAGS_EXTRA)
+libcurl_impersonate_la_CPPFLAGS = $(AM_CPPFLAGS) $(libcurl_impersonate_la_CPPFLAGS_EXTRA)
+libcurl_impersonate_la_LDFLAGS = $(AM_LDFLAGS) $(libcurl_impersonate_la_LDFLAGS_EXTRA) $(CURL_LDFLAGS_LIB) $(LIBCURL_PC_LIBS_PRIVATE)
+libcurl_impersonate_la_CFLAGS = $(AM_CFLAGS) $(libcurl_impersonate_la_CFLAGS_EXTRA)
 
 libcurlu_la_CPPFLAGS = $(AM_CPPFLAGS) -DCURL_STATICLIB -DUNITTESTS
 libcurlu_la_LDFLAGS = $(AM_LDFLAGS) -static $(LIBCURL_PC_LIBS_PRIVATE)
diff --git a/lib/Makefile.inc b/lib/Makefile.inc
index 257e104de9..ccd06bae03 100644
--- a/lib/Makefile.inc
+++ b/lib/Makefile.inc
@@ -210,6 +210,7 @@ LIB_CFILES =         \
   idn.c              \
   if2ip.c            \
   imap.c             \
+  impersonate.c      \
   krb5.c             \
   ldap.c             \
   llist.c            \
diff --git a/lib/connect.c b/lib/connect.c
index ac16c3399b..4f84781cd2 100644
--- a/lib/connect.c
+++ b/lib/connect.c
@@ -1292,12 +1292,18 @@ connect_sub_chain:
   /* sub-chain connected, do we need to add more? */
 #ifndef CURL_DISABLE_PROXY
   if(ctx->state < CF_SETUP_CNNCT_SOCKS && cf->conn->bits.socksproxy) {
-    result = Curl_cf_socks_proxy_insert_after(cf, data);
-    if(result)
-      return result;
-    ctx->state = CF_SETUP_CNNCT_SOCKS;
-    if(!cf->next || !cf->next->connected)
-      goto connect_sub_chain;
+    /* curl-impersonate: for QUIC transport, update the state here. */
+    if(ctx->transport == TRNSPRT_QUIC) {
+      ctx->state = CF_SETUP_CNNCT_SOCKS;
+    }
+    else {
+      result = Curl_cf_socks_proxy_insert_after(cf, data);
+      if(result)
+        return result;
+      ctx->state = CF_SETUP_CNNCT_SOCKS;
+      if(!cf->next || !cf->next->connected)
+        goto connect_sub_chain;
+    }
   }
 
   if(ctx->state < CF_SETUP_CNNCT_HTTP_PROXY && cf->conn->bits.httpproxy) {
diff --git a/lib/dynhds.c b/lib/dynhds.c
index dcb9193a8b..30be16064f 100644
--- a/lib/dynhds.c
+++ b/lib/dynhds.c
@@ -56,6 +56,9 @@ entry_new(const char *name, size_t namelen,
   e->valuelen = valuelen;
   if(opts & DYNHDS_OPT_LOWERCASE)
     Curl_strntolower(e->name, e->name, e->namelen);
+  // curl-impersonate: Make header value also lower case
+  if(opts & DYNHDS_OPT_LOWERCASE_VAL)
+    Curl_strntolower(e->value, e->value, e->valuelen);
   return e;
 }
 
@@ -138,6 +141,19 @@ void Curl_dynhds_set_opts(struct dynhds *dynhds, int opts)
   dynhds->opts = opts;
 }
 
+// curl-impersonate
+void Curl_dynhds_set_opt(struct dynhds *dynhds, int opt)
+{
+  dynhds->opts |= opt;
+}
+
+// curl-impersonate
+void Curl_dynhds_del_opt(struct dynhds *dynhds, int opt)
+{
+  dynhds->opts &= ~opt;
+}
+
+
 struct dynhds_entry *Curl_dynhds_getn(struct dynhds *dynhds, size_t n)
 {
   DEBUGASSERT(dynhds);
@@ -175,7 +191,7 @@ CURLcode Curl_dynhds_add(struct dynhds *dynhds,
   if(dynhds->strs_len + namelen + valuelen > dynhds->max_strs_size)
     return CURLE_OUT_OF_MEMORY;
 
-entry = entry_new(name, namelen, value, valuelen, dynhds->opts);
+  entry = entry_new(name, namelen, value, valuelen, dynhds->opts);
   if(!entry)
     goto out;
 
diff --git a/lib/dynhds.h b/lib/dynhds.h
index e533dcc369..84d8c5d701 100644
--- a/lib/dynhds.h
+++ b/lib/dynhds.h
@@ -53,6 +53,7 @@ struct dynhds {
 
 #define DYNHDS_OPT_NONE          (0)
 #define DYNHDS_OPT_LOWERCASE     (1 << 0)
+#define DYNHDS_OPT_LOWERCASE_VAL (1 << 1)
 
 /**
  * Init for use on first time or after a reset.
@@ -82,6 +83,9 @@ size_t Curl_dynhds_count(struct dynhds *dynhds);
  * This will not have an effect on already existing headers.
  */
 void Curl_dynhds_set_opts(struct dynhds *dynhds, int opts);
+// curl-impersonate
+void Curl_dynhds_set_opt(struct dynhds *dynhds, int opt);
+void Curl_dynhds_del_opt(struct dynhds *dynhds, int opt);
 
 /**
  * Return the n-th header entry or NULL if it does not exist.
@@ -99,7 +103,7 @@ struct dynhds_entry *Curl_dynhds_cget(struct dynhds *dynhds, const char *name);
 /* used by unit2602.c */
 
 /**
- * Return TRUE iff one or more headers with the given name exist.
+ * Return TRUE if one or more headers with the given name exist.
  */
 bool Curl_dynhds_contains(struct dynhds *dynhds,
                           const char *name, size_t namelen);
diff --git a/lib/easy.c b/lib/easy.c
index 9c1f1c6969..710469ddcf 100644
--- a/lib/easy.c
+++ b/lib/easy.c
@@ -74,9 +74,12 @@
 #include "http_digest.h"
 #include "system_win32.h"
 #include "http2.h"
+#include "rand.h"
 #include "curlx/dynbuf.h"
 #include "altsvc.h"
 #include "hsts.h"
+#include "strcase.h"
+#include "impersonate.h"
 
 #include "easy_lock.h"
 
@@ -345,6 +348,440 @@ CURLsslset curl_global_sslset(curl_sslbackend id, const char *name,
   return rc;
 }
 
+
+
+/*
+ * curl-impersonate:
+ * Actually call curl_easy_setopt() with all the needed options
+ * */
+static CURLcode permute_extension_order(struct Curl_easy *data,
+                                        const char *order,
+                                        char **porder)
+{
+  CURLcode result = CURLE_OK;
+  char *tmp;
+  char *p;
+  char *start;
+  char **tokens = NULL;
+  size_t ntokens = 0;
+  size_t talloc = 0;
+  size_t i;
+  size_t outlen;
+  char *out;
+
+  DEBUGASSERT(porder);
+  *porder = NULL;
+
+  if(!order || !*order)
+    return CURLE_OK;
+
+  tmp = strdup(order);
+  if(!tmp)
+    return CURLE_OUT_OF_MEMORY;
+
+  start = tmp;
+  p = tmp;
+  while(1) {
+    char **newtokens;
+    size_t newalloc;
+    if(*p && (*p != '-')) {
+      ++p;
+      continue;
+    }
+    if(ntokens == talloc) {
+      newalloc = talloc ? (talloc * 2) : 8;
+      newtokens = realloc(tokens, newalloc * sizeof(*tokens));
+      if(!newtokens) {
+        result = CURLE_OUT_OF_MEMORY;
+        goto out;
+      }
+      tokens = newtokens;
+      talloc = newalloc;
+    }
+    tokens[ntokens++] = start;
+    if(!*p)
+      break;
+    *p = '\0';
+    start = p + 1;
+    ++p;
+  }
+
+  if(ntokens < 2)
+    goto out;
+
+  for(i = ntokens - 1; i > 0; --i) {
+    uint64_t r;
+    size_t j;
+    char *swp;
+    result = Curl_rand(data, (unsigned char *)&r, sizeof(r));
+    if(result)
+      goto out;
+    j = (size_t)(r % (i + 1));
+    if(i == j)
+      continue;
+    swp = tokens[i];
+    tokens[i] = tokens[j];
+    tokens[j] = swp;
+  }
+
+  outlen = strlen(order);
+  out = malloc(outlen + 1);
+  if(!out) {
+    result = CURLE_OUT_OF_MEMORY;
+    goto out;
+  }
+
+  p = out;
+  for(i = 0; i < ntokens; ++i) {
+    size_t len = strlen(tokens[i]);
+    memcpy(p, tokens[i], len);
+    p += len;
+    if((i + 1) < ntokens)
+      *p++ = '-';
+  }
+  *p = '\0';
+  *porder = out;
+
+out:
+  free(tokens);
+  free(tmp);
+  return result;
+}
+
+static CURLcode _do_impersonate(struct Curl_easy *data,
+                        const struct impersonate_opts *opts,
+                        int default_headers)
+{
+  bool use_http3;
+  int i;
+  int ret;
+  struct curl_slist *headers = NULL;
+  const char *tls_extension_order;
+
+  if(opts->target == NULL) {
+    DEBUGF(fprintf(stderr, "Error: unknown impersonation target '%s'\n",
+                   opts->target));
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+  }
+
+  use_http3 = (data->set.httpwant == CURL_HTTP_VERSION_3 ||
+               data->set.httpwant == CURL_HTTP_VERSION_3ONLY ||
+               opts->httpversion == CURL_HTTP_VERSION_3 ||
+               opts->httpversion == CURL_HTTP_VERSION_3ONLY);
+  tls_extension_order = opts->tls_extension_order;
+  if(use_http3 && opts->http3_tls_extension_order)
+    tls_extension_order = opts->http3_tls_extension_order;
+
+  if(opts->httpversion != CURL_HTTP_VERSION_NONE) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP_VERSION, opts->httpversion);
+    if(ret)
+      return ret;
+  }
+
+  if (opts->ssl_version != CURL_SSLVERSION_DEFAULT) {
+    ret = curl_easy_setopt(data, CURLOPT_SSLVERSION, opts->ssl_version);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->ciphers) {
+    ret = curl_easy_setopt(data, CURLOPT_SSL_CIPHER_LIST, opts->ciphers);
+    if (ret)
+      return ret;
+  }
+
+  if(opts->curves) {
+    ret = curl_easy_setopt(data, CURLOPT_SSL_EC_CURVES, opts->curves);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->sig_hash_algs) {
+    ret = curl_easy_setopt(data, CURLOPT_SSL_SIG_HASH_ALGS,
+                           opts->sig_hash_algs);
+    if(ret)
+      return ret;
+  }
+
+  // TODO: remove npn, which has been deprecated by curl
+  ret = curl_easy_setopt(data, CURLOPT_SSL_ENABLE_NPN, opts->npn ? 1 : 0);
+  if(ret)
+    return ret;
+
+  ret = curl_easy_setopt(data, CURLOPT_SSL_ENABLE_ALPN, opts->alpn ? 1 : 0);
+  if(ret)
+    return ret;
+
+  ret = curl_easy_setopt(data, CURLOPT_SSL_ENABLE_ALPS, opts->alps ? 1 : 0);
+  if(ret)
+    return ret;
+
+  ret = curl_easy_setopt(data, CURLOPT_SSL_ENABLE_TICKET,
+                         opts->tls_session_ticket ? 1 : 0);
+  if(ret)
+    return ret;
+
+  // always enable this for browsers
+  ret = curl_easy_setopt(data, CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS, 1);
+  if(ret)
+    return ret;
+
+  // always enable this for browsers
+  ret = curl_easy_setopt(data, CURLOPT_TLS_STATUS_REQUEST, 1);
+  if(ret)
+    return ret;
+
+  if(opts->tls_permute_extensions) {
+    ret = curl_easy_setopt(data, CURLOPT_SSL_PERMUTE_EXTENSIONS, 1);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->cert_compression) {
+    ret = curl_easy_setopt(data,
+                           CURLOPT_SSL_CERT_COMPRESSION,
+                           opts->cert_compression);
+    if(ret)
+      return ret;
+  }
+
+  if(default_headers) {
+    /* Build a linked list out of the static array of headers. */
+    for(i = 0; i < IMPERSONATE_MAX_HEADERS; i++) {
+      if(opts->http_headers[i]) {
+        headers = curl_slist_append(headers, opts->http_headers[i]);
+        if(!headers) {
+          return CURLE_OUT_OF_MEMORY;
+        }
+      }
+    }
+
+    if(headers) {
+      ret = curl_easy_setopt(data, CURLOPT_HTTPBASEHEADER, headers);
+      curl_slist_free_all(headers);
+      if(ret)
+        return ret;
+    }
+  }
+
+  if(opts->http2_pseudo_headers_order) {
+    ret = curl_easy_setopt(data,
+                           CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER,
+                           opts->http2_pseudo_headers_order);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_settings) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP2_SETTINGS, opts->http2_settings);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http3_pseudo_headers_order) {
+    ret = curl_easy_setopt(data,
+                           CURLOPT_HTTP3_PSEUDO_HEADERS_ORDER,
+                           opts->http3_pseudo_headers_order);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http3_settings) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP3_SETTINGS, opts->http3_settings);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->quic_transport_parameters) {
+    ret = curl_easy_setopt(data, CURLOPT_QUIC_TRANSPORT_PARAMETERS,
+                           opts->quic_transport_parameters);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_window_update) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP2_WINDOW_UPDATE, opts->http2_window_update);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_streams) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP2_STREAMS, opts->http2_streams);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_no_priority) {
+    ret = curl_easy_setopt(data, CURLOPT_HTTP2_NO_PRIORITY, opts->http2_no_priority);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->ech) {
+    ret = curl_easy_setopt(data, CURLOPT_ECH, opts->ech);
+    if(ret)
+      return ret;
+  }
+
+  ret = curl_easy_setopt(data, CURLOPT_TLS_GREASE, opts->tls_grease);
+  if(ret)
+    return ret;
+
+  if(tls_extension_order) {
+    char *permuted_order = NULL;
+    const char *order_to_set = tls_extension_order;
+    if(opts->tls_permute_extensions) {
+      ret = permute_extension_order(data, tls_extension_order,
+                                    &permuted_order);
+      if(ret)
+        return ret;
+      if(permuted_order)
+        order_to_set = permuted_order;
+    }
+    ret = curl_easy_setopt(data, CURLOPT_TLS_EXTENSION_ORDER,
+                           order_to_set);
+    free(permuted_order);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->tls_delegated_credentials) {
+    ret = curl_easy_setopt(data, CURLOPT_TLS_DELEGATED_CREDENTIALS, opts->tls_delegated_credentials);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->tls_record_size_limit) {
+    ret = curl_easy_setopt(data, CURLOPT_TLS_RECORD_SIZE_LIMIT, opts->tls_record_size_limit);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->tls_key_shares_limit) {
+    ret = curl_easy_setopt(data, CURLOPT_TLS_KEY_SHARES_LIMIT, opts->tls_key_shares_limit);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->tls_use_new_alps_codepoint) {
+    ret = curl_easy_setopt(data, CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT, opts->tls_use_new_alps_codepoint);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_stream_weight) {
+    ret = curl_easy_setopt(data, CURLOPT_STREAM_WEIGHT, opts->http2_stream_weight);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->http2_stream_exclusive) {
+    ret = curl_easy_setopt(data, CURLOPT_STREAM_EXCLUSIVE, opts->http2_stream_exclusive);
+    if(ret)
+      return ret;
+  }
+
+  if(opts->proxy_credential_no_reuse) {
+    ret = curl_easy_setopt(data, CURLOPT_PROXY_CREDENTIAL_NO_REUSE, opts->proxy_credential_no_reuse);
+    if(ret)
+      return ret;
+  }
+
+  ret = curl_easy_setopt(data, CURLOPT_SPLIT_COOKIES,
+                         opts->split_cookies ? 1L : 0L);
+  if(ret)
+    return ret;
+
+  if(opts->form_boundary) {
+    ret = curl_easy_setopt(data, CURLOPT_FORM_BOUNDARY,
+                           opts->form_boundary);
+    if(ret)
+      return ret;
+  }
+
+  return CURLE_OK;
+}
+
+
+/*
+ * curl-impersonate:
+ * Call curl_easy_setopt() with all the needed options as defined by the target
+ * */
+CURLcode curl_easy_impersonate_customized(struct Curl_easy *data,
+                                          const struct impersonate_opts *opts,
+                                          int default_headers)
+{
+  int ret;
+
+  ret = _do_impersonate(data, opts, default_headers);
+  if(ret)
+    return ret;
+
+  return CURLE_OK;
+}
+
+
+static const struct impersonate_opts *binary_search(size_t size, const char *key)
+{
+  int low = 0;
+  int high = size - 1;
+
+  while(low <= high) {
+    int mid = low + (high - low) / 2;
+    int cmp = strcmp(impersonations[mid].target, key);
+
+    if(cmp == 0) {
+      return &impersonations[mid];
+    } else if(cmp < 0) {
+      low = mid + 1;
+    } else {
+      high = mid - 1;
+    }
+  }
+
+  return NULL;
+}
+
+/*
+ * curl-impersonate:
+ * Call curl_easy_setopt() with all the needed options as defined in the
+ * 'impersonations' array.
+ * */
+CURLcode curl_easy_impersonate(CURL *data, const char *target,
+                               int default_headers)
+{
+  int ret;
+  const struct impersonate_opts *opts = NULL;
+  struct Curl_easy *_data = (struct Curl_easy *)data;
+
+  opts = binary_search(num_impersonations, target);
+
+  // If not found, fallback and search by alias again
+  if(opts == NULL) {
+    for(int i = 0; i < num_impersonations; ++i) {
+      if (curl_strequal(target, impersonations[i].alias)) {
+        opts = impersonations + i;
+        break;
+      }
+    }
+  }
+
+  if(opts == NULL) {
+    failf(_data, "Unknown impersonation target '%s'. "
+          "Use a valid --impersonate target such as firefox147.", target);
+    DEBUGF(fprintf(stderr, "Error: unknown impersonation target '%s'\n",
+                   target));
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+  }
+
+  ret = _do_impersonate(_data, opts, default_headers);
+  if(ret)
+    return ret;
+
+  return CURLE_OK;
+}
+
+
 /*
  * curl_easy_init() is the external interface to alloc, setup and init an
  * easy handle that is returned. If anything goes wrong, NULL is returned.
@@ -353,6 +790,8 @@ CURL *curl_easy_init(void)
 {
   CURLcode result;
   struct Curl_easy *data;
+  char *env_target = NULL;
+  char *env_headers = NULL;
 
   /* Make sure we inited the global SSL stuff */
   global_init_lock();
@@ -375,6 +814,29 @@ CURL *curl_easy_init(void)
     return NULL;
   }
 
+  /*
+   * curl-impersonate: Hook into curl_easy_init() to set the required options
+   * from an environment variable.
+   * This is a bit hacky but allows seamless integration of libcurl-impersonate
+   * without code modifications to the app.
+   */
+  env_target = curl_getenv("CURL_IMPERSONATE");
+  if(env_target) {
+    env_headers = curl_getenv("CURL_IMPERSONATE_HEADERS");
+    if(env_headers) {
+      result = curl_easy_impersonate(data, env_target,
+                                     !curl_strequal(env_headers, "no"));
+      free(env_headers);
+    } else {
+      result = curl_easy_impersonate(data, env_target, true);
+    }
+    free(env_target);
+    if(result) {
+      Curl_close(&data);
+      return NULL;
+    }
+  }
+
   return data;
 }
 
@@ -1017,6 +1479,13 @@ CURL *curl_easy_duphandle(CURL *d)
     outcurl->state.referer_alloc = TRUE;
   }
 
+  if(data->state.base_headers) {
+    outcurl->state.base_headers =
+      Curl_slist_duplicate(data->state.base_headers);
+    if(!outcurl->state.base_headers)
+      goto fail;
+  }
+
   /* Reinitialize an SSL engine for the new handle
    * note: the engine name has already been copied by dupset */
   if(outcurl->set.str[STRING_SSL_ENGINE]) {
@@ -1073,6 +1542,9 @@ fail:
  */
 void curl_easy_reset(CURL *d)
 {
+  char *env_target;
+  char *env_headers;
+
   struct Curl_easy *data = d;
   Curl_req_hard_reset(&data->req, data);
   Curl_hash_clean(&data->meta_hash);
@@ -1106,6 +1578,22 @@ void curl_easy_reset(CURL *d)
   Curl_http_auth_cleanup_digest(data);
 #endif
   data->master_mid = UINT_MAX;
+  /*
+   * curl-impersonate: Hook into curl_easy_reset() to set the required options
+   * from an environment variable, just like in curl_easy_init().
+   */
+  env_target = curl_getenv("CURL_IMPERSONATE");
+  if(env_target) {
+    env_headers = curl_getenv("CURL_IMPERSONATE_HEADERS");
+    if(env_headers) {
+      curl_easy_impersonate(data, env_target,
+                            !curl_strequal(env_headers, "no"));
+      free(env_headers);
+    } else {
+      curl_easy_impersonate(data, env_target, true);
+    }
+    free(env_target);
+  }
 }
 
 /*
diff --git a/lib/easyoptions.c b/lib/easyoptions.c
index 03d676df0e..1763386bc1 100644
--- a/lib/easyoptions.c
+++ b/lib/easyoptions.c
@@ -98,6 +98,7 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"FNMATCH_FUNCTION", CURLOPT_FNMATCH_FUNCTION, CURLOT_FUNCTION, 0},
   {"FOLLOWLOCATION", CURLOPT_FOLLOWLOCATION, CURLOT_LONG, 0},
   {"FORBID_REUSE", CURLOPT_FORBID_REUSE, CURLOT_LONG, 0},
+  {"FORM_BOUNDARY", CURLOPT_FORM_BOUNDARY, CURLOT_STRING, 0},
   {"FRESH_CONNECT", CURLOPT_FRESH_CONNECT, CURLOT_LONG, 0},
   {"FTPAPPEND", CURLOPT_APPEND, CURLOT_LONG, CURLOT_FLAG_ALIAS},
   {"FTPLISTONLY", CURLOPT_DIRLISTONLY, CURLOT_LONG, CURLOT_FLAG_ALIAS},
@@ -134,7 +135,15 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"HSTS_CTRL", CURLOPT_HSTS_CTRL, CURLOT_LONG, 0},
   {"HTTP09_ALLOWED", CURLOPT_HTTP09_ALLOWED, CURLOT_LONG, 0},
   {"HTTP200ALIASES", CURLOPT_HTTP200ALIASES, CURLOT_SLIST, 0},
+  {"HTTP2_NO_PRIORITY", CURLOPT_HTTP2_NO_PRIORITY, CURLOT_LONG, 0},
+  {"HTTP2_PSEUDO_HEADERS_ORDER", CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER, CURLOT_STRING, 0},
+  {"HTTP2_SETTINGS", CURLOPT_HTTP2_SETTINGS, CURLOT_STRING, 0},
+  {"HTTP2_STREAMS", CURLOPT_HTTP2_STREAMS, CURLOT_STRING, 0},
+  {"HTTP2_WINDOW_UPDATE", CURLOPT_HTTP2_WINDOW_UPDATE, CURLOT_LONG, 0},
+  {"HTTP3_PSEUDO_HEADERS_ORDER", CURLOPT_HTTP3_PSEUDO_HEADERS_ORDER, CURLOT_STRING, 0},
+  {"HTTP3_SETTINGS", CURLOPT_HTTP3_SETTINGS, CURLOT_STRING, 0},
   {"HTTPAUTH", CURLOPT_HTTPAUTH, CURLOT_VALUES, 0},
+  {"HTTPBASEHEADER", CURLOPT_HTTPBASEHEADER, CURLOT_SLIST, 0},
   {"HTTPGET", CURLOPT_HTTPGET, CURLOT_LONG, 0},
   {"HTTPHEADER", CURLOPT_HTTPHEADER, CURLOT_SLIST, 0},
   {"HTTPPOST", CURLOPT_HTTPPOST, CURLOT_OBJECT, 0},
@@ -146,6 +155,7 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"INFILE", CURLOPT_READDATA, CURLOT_CBPTR, CURLOT_FLAG_ALIAS},
   {"INFILESIZE", CURLOPT_INFILESIZE, CURLOT_LONG, 0},
   {"INFILESIZE_LARGE", CURLOPT_INFILESIZE_LARGE, CURLOT_OFF_T, 0},
+  {"IMPERSONATE", CURLOPT_IMPERSONATE, CURLOT_STRING, 0},
   {"INTERFACE", CURLOPT_INTERFACE, CURLOT_STRING, 0},
   {"INTERLEAVEDATA", CURLOPT_INTERLEAVEDATA, CURLOT_CBPTR, 0},
   {"INTERLEAVEFUNCTION", CURLOPT_INTERLEAVEFUNCTION, CURLOT_FUNCTION, 0},
@@ -221,6 +231,7 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"PROXY_CAINFO", CURLOPT_PROXY_CAINFO, CURLOT_STRING, 0},
   {"PROXY_CAINFO_BLOB", CURLOPT_PROXY_CAINFO_BLOB, CURLOT_BLOB, 0},
   {"PROXY_CAPATH", CURLOPT_PROXY_CAPATH, CURLOT_STRING, 0},
+  {"PROXY_CREDENTIAL_NO_REUSE", CURLOPT_PROXY_CREDENTIAL_NO_REUSE, CURLOT_LONG, 0},
   {"PROXY_CRLFILE", CURLOPT_PROXY_CRLFILE, CURLOT_STRING, 0},
   {"PROXY_ISSUERCERT", CURLOPT_PROXY_ISSUERCERT, CURLOT_STRING, 0},
   {"PROXY_ISSUERCERT_BLOB", CURLOPT_PROXY_ISSUERCERT_BLOB, CURLOT_BLOB, 0},
@@ -247,6 +258,7 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"PROXY_TRANSFER_MODE", CURLOPT_PROXY_TRANSFER_MODE, CURLOT_LONG, 0},
   {"PUT", CURLOPT_PUT, CURLOT_LONG, 0},
   {"QUICK_EXIT", CURLOPT_QUICK_EXIT, CURLOT_LONG, 0},
+  {"QUIC_TRANSPORT_PARAMETERS", CURLOPT_QUIC_TRANSPORT_PARAMETERS, CURLOT_STRING, 0},
   {"QUOTE", CURLOPT_QUOTE, CURLOT_SLIST, 0},
   {"RANDOM_FILE", CURLOPT_RANDOM_FILE, CURLOT_STRING, 0},
   {"RANGE", CURLOPT_RANGE, CURLOT_STRING, 0},
@@ -284,6 +296,7 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"SOCKS5_AUTH", CURLOPT_SOCKS5_AUTH, CURLOT_LONG, 0},
   {"SOCKS5_GSSAPI_NEC", CURLOPT_SOCKS5_GSSAPI_NEC, CURLOT_LONG, 0},
   {"SOCKS5_GSSAPI_SERVICE", CURLOPT_SOCKS5_GSSAPI_SERVICE, CURLOT_STRING, 0},
+  {"SPLIT_COOKIES", CURLOPT_SPLIT_COOKIES, CURLOT_LONG, 0},
   {"SSH_AUTH_TYPES", CURLOPT_SSH_AUTH_TYPES, CURLOT_VALUES, 0},
   {"SSH_COMPRESSION", CURLOPT_SSH_COMPRESSION, CURLOT_LONG, 0},
   {"SSH_HOSTKEYDATA", CURLOPT_SSH_HOSTKEYDATA, CURLOT_CBPTR, 0},
@@ -308,23 +321,29 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"SSLKEYTYPE", CURLOPT_SSLKEYTYPE, CURLOT_STRING, 0},
   {"SSLKEY_BLOB", CURLOPT_SSLKEY_BLOB, CURLOT_BLOB, 0},
   {"SSLVERSION", CURLOPT_SSLVERSION, CURLOT_VALUES, 0},
+  {"SSL_CERT_COMPRESSION", CURLOPT_SSL_CERT_COMPRESSION, CURLOT_STRING, 0},
   {"SSL_CIPHER_LIST", CURLOPT_SSL_CIPHER_LIST, CURLOT_STRING, 0},
   {"SSL_CTX_DATA", CURLOPT_SSL_CTX_DATA, CURLOT_CBPTR, 0},
   {"SSL_CTX_FUNCTION", CURLOPT_SSL_CTX_FUNCTION, CURLOT_FUNCTION, 0},
   {"SSL_EC_CURVES", CURLOPT_SSL_EC_CURVES, CURLOT_STRING, 0},
   {"SSL_ENABLE_ALPN", CURLOPT_SSL_ENABLE_ALPN, CURLOT_LONG, 0},
+  {"SSL_ENABLE_ALPS", CURLOPT_SSL_ENABLE_ALPS, CURLOT_LONG, 0},
   {"SSL_ENABLE_NPN", CURLOPT_SSL_ENABLE_NPN, CURLOT_LONG, 0},
+  {"SSL_ENABLE_TICKET", CURLOPT_SSL_ENABLE_TICKET, CURLOT_LONG, 0},
   {"SSL_FALSESTART", CURLOPT_SSL_FALSESTART, CURLOT_LONG, 0},
   {"SSL_OPTIONS", CURLOPT_SSL_OPTIONS, CURLOT_VALUES, 0},
+  {"SSL_PERMUTE_EXTENSIONS", CURLOPT_SSL_PERMUTE_EXTENSIONS, CURLOT_LONG, 0},
   {"SSL_SESSIONID_CACHE", CURLOPT_SSL_SESSIONID_CACHE, CURLOT_LONG, 0},
   {"SSL_SIGNATURE_ALGORITHMS", CURLOPT_SSL_SIGNATURE_ALGORITHMS,
    CURLOT_STRING, 0},
+  {"SSL_SIG_HASH_ALGS", CURLOPT_SSL_SIG_HASH_ALGS, CURLOT_STRING, 0},
   {"SSL_VERIFYHOST", CURLOPT_SSL_VERIFYHOST, CURLOT_LONG, 0},
   {"SSL_VERIFYPEER", CURLOPT_SSL_VERIFYPEER, CURLOT_LONG, 0},
   {"SSL_VERIFYSTATUS", CURLOPT_SSL_VERIFYSTATUS, CURLOT_LONG, 0},
   {"STDERR", CURLOPT_STDERR, CURLOT_OBJECT, 0},
   {"STREAM_DEPENDS", CURLOPT_STREAM_DEPENDS, CURLOT_OBJECT, 0},
   {"STREAM_DEPENDS_E", CURLOPT_STREAM_DEPENDS_E, CURLOT_OBJECT, 0},
+  {"STREAM_EXCLUSIVE", CURLOPT_STREAM_EXCLUSIVE, CURLOT_LONG, 0},
   {"STREAM_WEIGHT", CURLOPT_STREAM_WEIGHT, CURLOT_LONG, 0},
   {"SUPPRESS_CONNECT_HEADERS", CURLOPT_SUPPRESS_CONNECT_HEADERS,
    CURLOT_LONG, 0},
@@ -346,6 +365,15 @@ const struct curl_easyoption Curl_easyopts[] = {
   {"TLSAUTH_PASSWORD", CURLOPT_TLSAUTH_PASSWORD, CURLOT_STRING, 0},
   {"TLSAUTH_TYPE", CURLOPT_TLSAUTH_TYPE, CURLOT_STRING, 0},
   {"TLSAUTH_USERNAME", CURLOPT_TLSAUTH_USERNAME, CURLOT_STRING, 0},
+  {"TLS_DELEGATED_CREDENTIALS", CURLOPT_TLS_DELEGATED_CREDENTIALS, CURLOT_STRING, 0},
+  {"TLS_EXTENSION_ORDER", CURLOPT_TLS_EXTENSION_ORDER, CURLOT_STRING, 0},
+  {"TLS_GREASE", CURLOPT_TLS_GREASE, CURLOT_LONG, 0},
+  {"TLS_KEY_SHARES_LIMIT", CURLOPT_TLS_KEY_SHARES_LIMIT, CURLOT_LONG, 0},
+  {"TLS_KEY_USAGE_NO_CHECK", CURLOPT_TLS_KEY_USAGE_NO_CHECK, CURLOT_LONG, 0},
+  {"TLS_RECORD_SIZE_LIMIT", CURLOPT_TLS_RECORD_SIZE_LIMIT, CURLOT_LONG, 0},
+  {"TLS_SIGNED_CERT_TIMESTAMPS", CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS, CURLOT_LONG, 0},
+  {"TLS_STATUS_REQUEST", CURLOPT_TLS_STATUS_REQUEST, CURLOT_LONG, 0},
+  {"TLS_USE_NEW_ALPS_CODEPOINT", CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT, CURLOT_LONG, 0},
   {"TRAILERDATA", CURLOPT_TRAILERDATA, CURLOT_CBPTR, 0},
   {"TRAILERFUNCTION", CURLOPT_TRAILERFUNCTION, CURLOT_FUNCTION, 0},
   {"TRANSFERTEXT", CURLOPT_TRANSFERTEXT, CURLOT_LONG, 0},
@@ -380,6 +408,6 @@ const struct curl_easyoption Curl_easyopts[] = {
  */
 int Curl_easyopts_check(void)
 {
-  return (CURLOPT_LASTENTRY % 10000) != (328 + 1);
+  return ((CURLOPT_LASTENTRY%10000) != (1027 + 1));
 }
 #endif
diff --git a/lib/http.c b/lib/http.c
index e5a0696274..5dda129eaa 100644
--- a/lib/http.c
+++ b/lib/http.c
@@ -85,6 +85,7 @@
 #include "hsts.h"
 #include "ws.h"
 #include "curl_ctype.h"
+#include "slist.h"
 #include "curlx/strparse.h"
 
 /* The last 3 #include files should be in this order */
@@ -1624,6 +1625,15 @@ CURLcode Curl_add_custom_headers(struct Curl_easy *data,
   int numlists = 1; /* by default */
   int i;
 
+  /*
+   * curl-impersonate: Use the merged list of headers if it exists (i.e. when
+   * the CURLOPT_HTTPBASEHEADER option was set.
+   */
+  struct curl_slist *noproxyheaders =
+    (data->state.merged_headers ?
+     data->state.merged_headers :
+     data->set.headers);
+
 #ifndef CURL_DISABLE_PROXY
   enum Curl_proxy_use proxy;
 
@@ -1635,10 +1645,11 @@ CURLcode Curl_add_custom_headers(struct Curl_easy *data,
 
   switch(proxy) {
   case HEADER_SERVER:
-    h[0] = data->set.headers;
+    h[0] = noproxyheaders;
+
     break;
   case HEADER_PROXY:
-    h[0] = data->set.headers;
+    h[0] = noproxyheaders;
     if(data->set.sep_headers) {
       h[1] = data->set.proxyheaders;
       numlists++;
@@ -1648,12 +1659,12 @@ CURLcode Curl_add_custom_headers(struct Curl_easy *data,
     if(data->set.sep_headers)
       h[0] = data->set.proxyheaders;
     else
-      h[0] = data->set.headers;
+      h[0] = noproxyheaders;
     break;
   }
 #else
   (void)is_connect;
-  h[0] = data->set.headers;
+  h[0] = noproxyheaders;
 #endif
 
   /* loop through one or two lists */
@@ -1860,6 +1871,109 @@ void Curl_http_method(struct Curl_easy *data, struct connectdata *conn,
   *reqp = httpreq;
 }
 
+/*
+ * curl-impersonate:
+ * Create a new linked list of headers.
+ * The new list is a merge between the "base" headers and the application given
+ * headers. The "base" headers contain curl-impersonate's list of headers
+ * used by default by the impersonated browser.
+ *
+ * The application given headers will override the "base" headers if supplied.
+ */
+CURLcode Curl_http_merge_headers(struct Curl_easy *data)
+{
+  int i;
+  int ret;
+  struct curl_slist *head;
+  struct curl_slist *dup = NULL;
+  struct curl_slist *new_list = NULL;
+  char *uagent;
+
+  if (!data->state.base_headers)
+    return CURLE_OK;
+
+  /* Duplicate the list for temporary use. */
+  if (data->set.headers) {
+    dup = Curl_slist_duplicate(data->set.headers);
+    if(!dup)
+      return CURLE_OUT_OF_MEMORY;
+  }
+
+  for(head = data->state.base_headers; head; head = head->next) {
+    char *sep;
+    size_t prefix_len;
+    bool found = FALSE;
+    struct curl_slist *head2;
+
+    sep = strchr(head->data, ':');
+    if(!sep)
+      continue;
+
+    prefix_len = sep - head->data;
+
+    /* Check if this header was added by the application. */
+    for(head2 = dup; head2; head2 = head2->next) {
+      if(head2->data &&
+         curl_strnequal(head2->data, head->data, prefix_len) &&
+         Curl_headersep(head2->data[prefix_len]) ) {
+        new_list = curl_slist_append(new_list, head2->data);
+        /* Free and set to NULL to mark that it's been added. */
+        Curl_safefree(head2->data);
+        found = TRUE;
+        break;
+      }
+    }
+
+    /* If the user agent was set with CURLOPT_USERAGENT, but not with
+     * CURLOPT_HTTPHEADER, take it from there instead. */
+    if(!found &&
+       curl_strnequal(head->data, "User-Agent", prefix_len) &&
+       data->set.str[STRING_USERAGENT] &&
+       *data->set.str[STRING_USERAGENT]) {
+      uagent = aprintf("User-Agent: %s", data->set.str[STRING_USERAGENT]);
+      if(!uagent) {
+        ret = CURLE_OUT_OF_MEMORY;
+        goto fail;
+      }
+      new_list = Curl_slist_append_nodup(new_list, uagent);
+      found = TRUE;
+    }
+
+    if (!found) {
+      new_list = curl_slist_append(new_list, head->data);
+    }
+
+    if (!new_list) {
+      ret = CURLE_OUT_OF_MEMORY;
+      goto fail;
+    }
+  }
+
+  /* Now go over any additional application-supplied headers. */
+  for(head = dup; head; head = head->next) {
+    if(head->data) {
+      new_list = curl_slist_append(new_list, head->data);
+      if(!new_list) {
+        ret = CURLE_OUT_OF_MEMORY;
+        goto fail;
+      }
+    }
+  }
+
+  curl_slist_free_all(dup);
+  /* Save the new, merged list separately, so it can be freed later. */
+  curl_slist_free_all(data->state.merged_headers);
+  data->state.merged_headers = new_list;
+
+  return CURLE_OK;
+
+fail:
+  Curl_safefree(dup);
+  curl_slist_free_all(new_list);
+  return ret;
+}
+
+
 static CURLcode http_useragent(struct Curl_easy *data)
 {
   /* The User-Agent string might have been allocated in url.c already, because
@@ -1890,49 +2004,19 @@ static CURLcode http_host(struct Curl_easy *data, struct connectdata *conn)
     data->state.first_remote_protocol = conn->handler->protocol;
   }
   Curl_safefree(aptr->host);
+#ifndef CURL_DISABLE_COOKIES
+  /* Cookies are matched against the URL host, not a custom Host: header. */
+  Curl_safefree(aptr->cookiehost);
+#endif
 
   ptr = Curl_checkheaders(data, STRCONST("Host"));
   if(ptr && (!data->state.this_is_a_follow ||
              curl_strequal(data->state.first_host, conn->host.name))) {
-#if !defined(CURL_DISABLE_COOKIES)
-    /* If we have a given custom Host: header, we extract the hostname in
-       order to possibly use it for cookie reasons later on. We only allow the
-       custom Host: header if this is NOT a redirect, as setting Host: in the
-       redirected request is being out on thin ice. Except if the hostname
-       is the same as the first one! */
-    char *cookiehost = Curl_copy_header_value(ptr);
-    if(!cookiehost)
-      return CURLE_OUT_OF_MEMORY;
-    if(!*cookiehost)
-      /* ignore empty data */
-      free(cookiehost);
-    else {
-      /* If the host begins with '[', we start searching for the port after
-         the bracket has been closed */
-      if(*cookiehost == '[') {
-        char *closingbracket;
-        /* since the 'cookiehost' is an allocated memory area that will be
-           freed later we cannot simply increment the pointer */
-        memmove(cookiehost, cookiehost + 1, strlen(cookiehost) - 1);
-        closingbracket = strchr(cookiehost, ']');
-        if(closingbracket)
-          *closingbracket = 0;
-      }
-      else {
-        int startsearch = 0;
-        char *colon = strchr(cookiehost + startsearch, ':');
-        if(colon)
-          *colon = 0; /* The host must not include an embedded port number */
-      }
-      free(aptr->cookiehost);
-      aptr->cookiehost = cookiehost;
-    }
-#endif
-
     if(!curl_strequal("Host:", ptr)) {
-      aptr->host = aprintf("Host:%s\r\n", &ptr[5]);
-      if(!aptr->host)
-        return CURLE_OUT_OF_MEMORY;
+      /* Keep custom Host: in the user header list path so it is emitted
+         in the same relative order as other user-provided headers.
+         Cookie matching follows the URL host. */
+      aptr->host = NULL;
     }
   }
   else {
@@ -2451,47 +2535,110 @@ static CURLcode http_cookies(struct Curl_easy *data,
                                secure_context, &list);
       Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
     }
-    if(!rc) {
-      struct Curl_llist_node *n;
-      size_t clen = 8; /* hold the size of the generated Cookie: header */
-
-      /* loop through all cookies that matched */
-      for(n = Curl_llist_head(&list); n; n = Curl_node_next(n)) {
-        struct Cookie *co = Curl_node_elem(n);
-        if(co->value) {
-          size_t add;
-          if(!count) {
-            result = curlx_dyn_addn(r, STRCONST("Cookie: "));
+    if(!data->set.split_cookies) {
+      if(!rc) {
+        struct Curl_llist_node *n;
+        size_t clen = 8; /* hold the size of the generated Cookie: header */
+
+        /* loop through all cookies that matched */
+        for(n = Curl_llist_head(&list); n; n = Curl_node_next(n)) {
+          struct Cookie *co = Curl_node_elem(n);
+          if(co->value) {
+            size_t add;
+            if(!count) {
+              result = curlx_dyn_addn(r, STRCONST("Cookie: "));
+              if(result)
+                break;
+            }
+            add = strlen(co->name) + strlen(co->value) + 1;
+            if(clen + add >= MAX_COOKIE_HEADER_LEN) {
+              infof(data, "Restricted outgoing cookies due to header size, "
+                    "'%s' not sent", co->name);
+              linecap = TRUE;
+              break;
+            }
+            result = curlx_dyn_addf(r, "%s%s=%s", count ? "; " : "",
+                                    co->name, co->value);
             if(result)
               break;
+            clen += add + (count ? 2 : 0);
+            count++;
           }
-          add = strlen(co->name) + strlen(co->value) + 1;
-          if(clen + add >= MAX_COOKIE_HEADER_LEN) {
+        }
+        Curl_llist_destroy(&list, NULL);
+      }
+      if(addcookies && !result && !linecap) {
+        if(!count)
+          result = curlx_dyn_addn(r, STRCONST("Cookie: "));
+        if(!result) {
+          result = curlx_dyn_addf(r, "%s%s", count ? "; " : "", addcookies);
+          count++;
+        }
+      }
+      if(count && !result)
+        result = curlx_dyn_addn(r, STRCONST("\r\n"));
+    }
+    else {
+      if(!rc) {
+        struct Curl_llist_node *n;
+
+        /* one cookie per header line */
+        for(n = Curl_llist_head(&list); n; n = Curl_node_next(n)) {
+          struct Cookie *co = Curl_node_elem(n);
+          if(co->value) {
+            size_t add = strlen(co->name) + strlen(co->value) + 1;
+            if(add + 8 >= MAX_COOKIE_HEADER_LEN) {
+              infof(data, "Restricted outgoing cookies due to header size, "
+                    "'%s' not sent", co->name);
+              linecap = TRUE;
+              break;
+            }
+            result = curlx_dyn_addf(r, "Cookie: %s=%s\r\n", co->name,
+                                    co->value);
+            if(result)
+              break;
+            count++;
+          }
+        }
+        Curl_llist_destroy(&list, NULL);
+      }
+      if(addcookies && !result && !linecap) {
+        const char *p = addcookies;
+
+        while(*p) {
+          const char *start;
+          const char *end;
+          size_t add;
+
+          while(ISBLANK(*p) || (*p == ';'))
+            p++;
+          if(!*p)
+            break;
+          start = p;
+          while(*p && (*p != ';'))
+            p++;
+          end = p;
+          while((end > start) && ISBLANK(end[-1]))
+            end--;
+
+          if(end == start)
+            continue;
+
+          add = (size_t)(end - start);
+          if(add + 8 >= MAX_COOKIE_HEADER_LEN) {
             infof(data, "Restricted outgoing cookies due to header size, "
-                  "'%s' not sent", co->name);
+                  "'%.*s' not sent", (int)add, start);
             linecap = TRUE;
             break;
           }
-          result = curlx_dyn_addf(r, "%s%s=%s", count ? "; " : "",
-                                  co->name, co->value);
+
+          result = curlx_dyn_addf(r, "Cookie: %.*s\r\n", (int)add, start);
           if(result)
             break;
-          clen += add + (count ? 2 : 0);
           count++;
         }
       }
-      Curl_llist_destroy(&list, NULL);
-    }
-    if(addcookies && !result && !linecap) {
-      if(!count)
-        result = curlx_dyn_addn(r, STRCONST("Cookie: "));
-      if(!result) {
-        result = curlx_dyn_addf(r, "%s%s", count ? "; " : "", addcookies);
-        count++;
-      }
     }
-    if(count && !result)
-      result = curlx_dyn_addn(r, STRCONST("\r\n"));
 
     if(result)
       return result;
@@ -2669,7 +2816,6 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
   const char *httpstring;
   struct dynbuf req;
   char *altused = NULL;
-  const char *p_accept;      /* Accept: string */
   unsigned char httpversion;
 
   /* Always consider the DO phase done after this function call, even if there
@@ -2715,6 +2861,11 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
   if(result)
     goto fail;
 
+  /* curl-impersonate: Add HTTP headers to impersonate real browsers. */
+  result = Curl_http_merge_headers(data);
+  if(result)
+    goto fail;
+
   result = http_host(data, conn);
   if(result)
     goto fail;
@@ -2772,9 +2923,6 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
   if(result)
     goto fail;
 
-  p_accept = Curl_checkheaders(data,
-                               STRCONST("Accept")) ? NULL : "Accept: */*\r\n";
-
   result = http_range(data, httpreq);
   if(result)
     goto fail;
@@ -2837,7 +2985,7 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
                     *data->set.str[STRING_USERAGENT] &&
                     data->state.aptr.uagent) ?
                    data->state.aptr.uagent : "",
-                   p_accept ? p_accept : "",
+                   "", // Accept
                    data->state.aptr.te ? data->state.aptr.te : "",
                    (data->set.str[STRING_ENCODING] &&
                     *data->set.str[STRING_ENCODING] &&
@@ -4620,6 +4768,29 @@ static bool http_TE_has_token(const char *fvalue, const char *token)
   return FALSE;
 }
 
+/*
+ * curl-impersonate:
+ * Determine the position of HTTP/2 pseudo headers.
+ * The pseudo headers ":method", ":path", ":scheme", ":authority"
+ * are sent in different order by different browsers. An important part of the
+ * impersonation is ordering them like the browser does.
+ */
+static CURLcode h2_check_pseudo_header_order(const char *order)
+{
+  if(strlen(order) != 4)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  // All pseudo-headers must be present
+  if(!strchr(order, 'm') ||
+     !strchr(order, 'a') ||
+     !strchr(order, 's') ||
+     !strchr(order, 'p'))
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  return CURLE_OK;
+}
+
+
 CURLcode Curl_http_req_to_h2(struct dynhds *h2_headers,
                              struct httpreq *req, struct Curl_easy *data)
 {
@@ -4628,6 +4799,10 @@ CURLcode Curl_http_req_to_h2(struct dynhds *h2_headers,
   size_t i;
   CURLcode result;
 
+  // curl-impersonate: Use the Chrome ordering by default:
+  // :method, :authority, :scheme, :path
+  char *order = "masp";
+
   DEBUGASSERT(req);
   DEBUGASSERT(h2_headers);
 
@@ -4658,20 +4833,46 @@ CURLcode Curl_http_req_to_h2(struct dynhds *h2_headers,
 
   Curl_dynhds_reset(h2_headers);
   Curl_dynhds_set_opts(h2_headers, DYNHDS_OPT_LOWERCASE);
-  result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_METHOD),
-                           req->method, strlen(req->method));
-  if(!result && scheme) {
-    result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_SCHEME),
-                             scheme, strlen(scheme));
+
+  /* curl-impersonate: order of pseudo headers is different from the default */
+  if(data->conn && data->conn->alpn == CURL_HTTP_VERSION_3 &&
+     data->set.str[STRING_HTTP3_PSEUDO_HEADERS_ORDER]) {
+    order = data->set.str[STRING_HTTP3_PSEUDO_HEADERS_ORDER];
   }
-  if(!result && authority) {
-    result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_AUTHORITY),
-                             authority, strlen(authority));
+  else if(data->set.str[STRING_HTTP2_PSEUDO_HEADERS_ORDER]) {
+    order = data->set.str[STRING_HTTP2_PSEUDO_HEADERS_ORDER];
   }
-  if(!result && req->path) {
-    result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_PATH),
-                             req->path, strlen(req->path));
+
+  result = h2_check_pseudo_header_order(order);
+
+  /* curl-impersonate: add http2 pseudo headers according to the specified order. */
+  for(i = 0; !result && i < 4; ++i) {
+    switch(order[i]) {
+      case 'm':
+        result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_METHOD),
+                                 req->method, strlen(req->method));
+        break;
+      case 'a':
+        if(authority) {
+          result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_AUTHORITY),
+                                   authority, strlen(authority));
+        }
+        break;
+      case 's':
+        if(scheme) {
+          result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_SCHEME),
+                                   scheme, strlen(scheme));
+        }
+        break;
+      case 'p':
+        if(req->path) {
+          result = Curl_dynhds_add(h2_headers, STRCONST(HTTP_PSEUDO_PATH),
+                                   req->path, strlen(req->path));
+        }
+        break;
+    }
   }
+
   for(i = 0; !result && i < Curl_dynhds_count(&req->headers); ++i) {
     e = Curl_dynhds_getn(&req->headers, i);
     /* "TE" is special in that it is only permissible when it
@@ -4684,6 +4885,8 @@ CURLcode Curl_http_req_to_h2(struct dynhds *h2_headers,
     else if(h2_permissible_field(e)) {
       result = Curl_dynhds_add(h2_headers, e->name, e->namelen,
                                e->value, e->valuelen);
+      /* curl-impersonate: delete the option */
+      Curl_dynhds_del_opt(h2_headers, DYNHDS_OPT_LOWERCASE_VAL);
     }
   }
 
diff --git a/lib/http2.c b/lib/http2.c
index 36dca426de..7207e1d7be 100644
--- a/lib/http2.c
+++ b/lib/http2.c
@@ -51,6 +51,7 @@
 #include "curl_printf.h"
 #include "curl_memory.h"
 #include "memdebug.h"
+#include "rand.h"
 
 #if (NGHTTP2_VERSION_NUM < 0x010c00)
 #error too old nghttp2 version, upgrade!
@@ -75,11 +76,13 @@
 /* on send into TLS, we just want to accumulate small frames */
 #define H2_NW_SEND_CHUNKS       1
 /* this is how much we want "in flight" for a stream, unthrottled  */
-#define H2_STREAM_WINDOW_SIZE_MAX   (10 * 1024 * 1024)
+/* curl-impersonate: match Chrome window size. */
+#define H2_STREAM_WINDOW_SIZE_MAX   (1024 * 1024)
 /* this is how much we want "in flight" for a stream, initially, IFF
  * nghttp2 allows us to tweak the local window size. */
 #if NGHTTP2_HAS_SET_LOCAL_WINDOW_SIZE
-#define H2_STREAM_WINDOW_SIZE_INITIAL  (64 * 1024)
+/* curl-impersonate: match Chrome window size. */
+#define H2_STREAM_WINDOW_SIZE_INITIAL  (1024 * 1024)
 #else
 #define H2_STREAM_WINDOW_SIZE_INITIAL H2_STREAM_WINDOW_SIZE_MAX
 #endif
@@ -93,24 +96,95 @@
  * the overall connection. Streams might become PAUSED which will block their
  * received QUOTA in the connection window. If we run out of space, the server
  * is blocked from sending us any data. See #10988 for an issue with this. */
-#define HTTP2_HUGE_WINDOW_SIZE (100 * H2_STREAM_WINDOW_SIZE_MAX)
+/* curl-impersonate: match Chrome window size. */
+#define HTTP2_HUGE_WINDOW_SIZE (15 * H2_STREAM_WINDOW_SIZE_MAX)
 
-#define H2_SETTINGS_IV_LEN  3
+#define H2_SETTINGS_IV_LEN  8
 #define H2_BINSETTINGS_LEN 80
 
 static size_t populate_settings(nghttp2_settings_entry *iv,
                                 struct Curl_easy *data)
 {
-  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;
-  iv[0].value = Curl_multi_max_concurrent_streams(data->multi);
+  // curl-impersonate:
+  // Setting http2 settings frame based on user instruction.
+  // https://httpwg.org/specs/rfc7540.html#SETTINGS
+  // Format example: 1:65536;2:0;4:6291456;6:262144
+
+  // TODO check if the http2 settings is valid
+  int i = 0;
+  char *delimiter = ";";
 
-  iv[1].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;
-  iv[1].value = H2_STREAM_WINDOW_SIZE_INITIAL;
+  // Use chrome's settings as default
+  char *http2_settings = "1:65536;2:0;4:6291456;6:262144";
+  if(data->set.str[STRING_HTTP2_SETTINGS]) {
+    http2_settings = data->set.str[STRING_HTTP2_SETTINGS];
+  }
 
-  iv[2].settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;
-  iv[2].value = data->multi->push_cb != NULL;
+  // printf("USING settings %s\n", http2_settings);
 
-  return 3;
+  char *tmp = strdup(http2_settings);
+  char *setting = strtok(tmp, delimiter);
+
+  // loop through the string to extract all other tokens
+  while(setting != NULL) {
+    // deal with each setting
+    switch(setting[0]) {
+      case '1':
+        iv[i].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '2':
+        iv[i].settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '3':
+        // FIXME We also need to notify curl_multi about this setting
+        iv[i].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '4':
+        iv[i].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '5':
+        iv[i].settings_id = NGHTTP2_SETTINGS_MAX_FRAME_SIZE;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      case '6':
+        iv[i].settings_id = NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      // https://tools.ietf.org/html/rfc8441
+      case '8':
+        iv[i].settings_id = NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+      // https://tools.ietf.org/html/rfc9218
+      case '9':
+        iv[i].settings_id = NGHTTP2_SETTINGS_NO_RFC7540_PRIORITIES;
+        iv[i].value = atoi(setting + 2);
+        i++;
+        break;
+    }
+    setting = strtok(NULL, delimiter);
+  }
+  free(tmp);
+
+  // curl-impersonate:
+  // Up until Chrome 98, there was a randomly chosen setting number in the
+  // HTTP2 SETTINGS frame. This might be something similar to TLS GREASE.
+  // However, it seems to have been removed since.
+  // Curl_rand(data, (unsigned char *)&iv[4].settings_id, sizeof(iv[4].settings_id));
+  // Curl_rand(data, (unsigned char *)&iv[4].value, sizeof(iv[4].value));
+
+  return i;
 }
 
 static ssize_t populate_binsettings(uint8_t *binsettings,
@@ -204,6 +278,77 @@ static void cf_h2_ctx_close(struct cf_h2_ctx *ctx)
   }
 }
 
+// XXX: this function should be deprecated
+static CURLcode http2_set_stream_priority(struct Curl_cfilter *cf,
+                                          struct Curl_easy *data,
+                                          int32_t stream_id,
+                                          int32_t dep_stream_id,
+                                          int32_t weight,
+                                          int exclusive
+                                          )
+{
+  int rv;
+  struct cf_h2_ctx *ctx = cf->ctx;
+  nghttp2_priority_spec pri_spec;
+
+  nghttp2_priority_spec_init(&pri_spec, dep_stream_id, weight, exclusive);
+  rv = nghttp2_submit_priority(ctx->h2, NGHTTP2_FLAG_NONE,
+                               stream_id, &pri_spec);
+  if(rv) {
+    failf(data, "nghttp2_submit_priority() failed: %s(%d)",
+          nghttp2_strerror(rv), rv);
+    return CURLE_HTTP2;
+  }
+
+  return CURLE_OK;
+}
+
+/*
+ * curl-impersonate: Firefox uses an elaborate scheme of http/2 streams to
+ * split the load for html/js/css/images. It builds a tree of streams with
+ * different weights (priorities) by default and communicates this to the
+ * server. Imitate that behavior.
+ * XXX: This has been deprecated in the RFC
+ */
+static CURLcode http2_set_stream_priorities(struct Curl_cfilter *cf,
+                                            struct Curl_easy *data)
+{
+  CURLcode result;
+  char *stream_delimiter = ",";
+  char *value_delimiter = ":";
+
+  if(!data->set.str[STRING_HTTP2_STREAMS])
+    return CURLE_OK;
+
+  char *tmp1 = strdup(data->set.str[STRING_HTTP2_STREAMS]);
+  char *end1;
+  char *stream = strtok_r(tmp1, stream_delimiter, &end1);
+
+  while(stream != NULL) {
+
+    char *tmp2 = strdup(stream);
+    char *end2;
+
+    int32_t stream_id = atoi(strtok_r(tmp2, value_delimiter, &end2));
+    int exclusive = atoi(strtok_r(NULL, value_delimiter, &end2));
+    int32_t dep_stream_id = atoi(strtok_r(NULL, value_delimiter, &end2));
+    int32_t weight = atoi(strtok_r(NULL, value_delimiter, &end2));
+
+    free(tmp2);
+
+    result = http2_set_stream_priority(cf, data, stream_id, dep_stream_id, weight, exclusive);
+    if(result) {
+      free(tmp1);
+      return result;
+    }
+
+    stream = strtok_r(NULL, stream_delimiter, &end1);
+  }
+
+  free(tmp1);
+  return CURLE_OK;
+}
+
 static CURLcode nw_out_flush(struct Curl_cfilter *cf,
                              struct Curl_easy *data);
 
@@ -348,8 +493,6 @@ static CURLcode cf_h2_update_local_win(struct Curl_cfilter *cf,
                   stream->id, dwsize - wsize);
     }
     else {
-      rv = nghttp2_session_set_local_window_size(ctx->h2, NGHTTP2_FLAG_NONE,
-                                                 stream->id, dwsize);
       if(rv) {
         failf(data, "[%d] nghttp2_session_set_local_window_size() failed: "
               "%s(%d)", stream->id, nghttp2_strerror(rv), rv);
@@ -588,9 +731,21 @@ static CURLcode cf_h2_ctx_open(struct Curl_cfilter *cf,
       goto out;
     }
   }
+  
+  // curl-impersonate:
+  // Directly changing the initial window update using users' settings.
+  int current_window_size = nghttp2_session_get_local_window_size(ctx->h2);
+
+  // Use chrome's value as default
+  int window_update = 15663105;
+  if(data->set.http2_window_update) {
+    window_update = data->set.http2_window_update;
+  }
+
+  rc = nghttp2_session_set_local_window_size(
+      ctx->h2, NGHTTP2_FLAG_NONE, 0,
+      current_window_size + window_update);
 
-  rc = nghttp2_session_set_local_window_size(ctx->h2, NGHTTP2_FLAG_NONE, 0,
-                                             HTTP2_HUGE_WINDOW_SIZE);
   if(rc) {
     failf(data, "nghttp2_session_set_local_window_size() failed: %s(%d)",
           nghttp2_strerror(rc), rc);
@@ -598,6 +753,16 @@ static CURLcode cf_h2_ctx_open(struct Curl_cfilter *cf,
     goto out;
   }
 
+  // curl-impersonate: set stream priorities
+  // No popular browsers are doing this, so it's disabled.
+  // result = http2_set_stream_priorities(cf, data);
+  // if(result)
+  //   goto out;
+
+  // #define FIREFOX_DEFAULT_STREAM_ID   (15)
+  // nghttp2_session_set_next_stream_id(ctx->h2, FIREFOX_DEFAULT_STREAM_ID);
+
+
   /* all set, traffic will be send on connect */
   result = CURLE_OK;
   CURL_TRC_CF(data, cf, "[0] created h2 session%s",
@@ -1911,11 +2076,19 @@ out:
   return result;
 }
 
+/*
+ * curl-impersonate: Use Chrome's default HTTP/2 stream weight
+ * instead of NGINX default stream weight.
+ */
+#define CHROME_DEFAULT_STREAM_WEIGHT    (256)
+#define SAFARI_DEFAULT_STREAM_WEIGHT    (255)
+#define FIREFOX_DEFAULT_STREAM_WEIGHT   (42)
+
 static int sweight_wanted(const struct Curl_easy *data)
 {
   /* 0 weight is not set by user and we take the nghttp2 default one */
   return data->set.priority.weight ?
-    data->set.priority.weight : NGHTTP2_DEFAULT_WEIGHT;
+    data->set.priority.weight : CHROME_DEFAULT_STREAM_WEIGHT;
 }
 
 static int sweight_in_effect(const struct Curl_easy *data)
@@ -1930,6 +2103,12 @@ static int sweight_in_effect(const struct Curl_easy *data)
  * and dependency to the peer. It also stores the updated values in the state
  * struct.
  */
+/*
+ * curl-impersonate: By default Firefox uses stream 13 as the "parent" of the
+ * stream that fetches the main html resource of the web page.
+ */
+#define FIREFOX_DEFAULT_STREAM_DEP  (13)
+
 
 static void h2_pri_spec(struct cf_h2_ctx *ctx,
                         struct Curl_easy *data,
@@ -1938,6 +2117,11 @@ static void h2_pri_spec(struct cf_h2_ctx *ctx,
   struct Curl_data_priority *prio = &data->set.priority;
   struct h2_stream_ctx *depstream = H2_STREAM_CTX(ctx, prio->parent);
   int32_t depstream_id = depstream ? depstream->id : 0;
+  // int32_t depstream_id = depstream? depstream->id:FIREFOX_DEFAULT_STREAM_DEP;
+
+  /* curl-impersonate: Set stream exclusive flag based on user option.
+   * Use data->set, not data->state.
+   */
   nghttp2_priority_spec_init(pri_spec, depstream_id,
                              sweight_wanted(data),
                              data->set.priority.exclusive);
@@ -1957,20 +2141,25 @@ static CURLcode h2_progress_egress(struct Curl_cfilter *cf,
   struct h2_stream_ctx *stream = H2_STREAM_CTX(ctx, data);
   int rv = 0;
 
+  /* curl-impersonate: Check if stream exclusive flag is true. */
   if(stream && stream->id > 0 &&
      ((sweight_wanted(data) != sweight_in_effect(data)) ||
-      (data->set.priority.exclusive != data->state.priority.exclusive) ||
+     (data->set.priority.exclusive != 1) ||
       (data->set.priority.parent != data->state.priority.parent)) ) {
     /* send new weight and/or dependency */
     nghttp2_priority_spec pri_spec;
 
+    // XXX: http2 priority has been deprecated, and not browser sends this frame.
     h2_pri_spec(ctx, data, &pri_spec);
-    CURL_TRC_CF(data, cf, "[%d] Queuing PRIORITY", stream->id);
-    DEBUGASSERT(stream->id != -1);
-    rv = nghttp2_submit_priority(ctx->h2, NGHTTP2_FLAG_NONE,
-                                 stream->id, &pri_spec);
-    if(rv)
-      goto out;
+    /* curl-impersonate: Don't send PRIORITY frames for main stream. */
+    if(stream->id != 1) {
+      CURL_TRC_CF(data, cf, "[%d] Queuing PRIORITY", stream->id);
+      DEBUGASSERT(stream->id != -1);
+      rv = nghttp2_submit_priority(ctx->h2, NGHTTP2_FLAG_NONE,
+                                   stream->id, &pri_spec);
+      if(rv)
+        goto out;
+    }
   }
 
   ctx->nw_out_blocked = 0;
@@ -2267,11 +2456,15 @@ static CURLcode h2_submit(struct h2_stream_ctx **pstream,
   case HTTPREQ_PUT:
     data_prd.read_callback = req_body_read_callback;
     data_prd.source.ptr = NULL;
-    stream_id = nghttp2_submit_request(ctx->h2, &pri_spec, nva, nheader,
+    stream_id = nghttp2_submit_request(ctx->h2,
+                                       data->set.http2_no_priority ? NULL : &pri_spec,
+                                       nva, nheader,
                                        &data_prd, data);
     break;
   default:
-    stream_id = nghttp2_submit_request(ctx->h2, &pri_spec, nva, nheader,
+    stream_id = nghttp2_submit_request(ctx->h2,
+                                       data->set.http2_no_priority ? NULL : &pri_spec,
+                                       nva, nheader,
                                        NULL, data);
   }
 
diff --git a/lib/http2.h b/lib/http2.h
index 93cc2d44f2..52e80ce9c1 100644
--- a/lib/http2.h
+++ b/lib/http2.h
@@ -31,7 +31,8 @@
 
 /* value for MAX_CONCURRENT_STREAMS we use until we get an updated setting
    from the peer */
-#define DEFAULT_MAX_CONCURRENT_STREAMS 100
+/* curl-impersonate: Use 1000 concurrent streams like Chrome. */
+#define DEFAULT_MAX_CONCURRENT_STREAMS 1000
 
 /*
  * Store nghttp2 version info in this buffer.
diff --git a/lib/impersonate.c b/lib/impersonate.c
new file mode 100644
index 0000000000..ab8e4d1a8b
--- /dev/null
+++ b/lib/impersonate.c
@@ -0,0 +1,2176 @@
+#include "curl_setup.h"
+#include <curl/curl.h>
+#include "impersonate.h"
+
+const struct impersonate_opts impersonations[] = {
+  {
+    .target = "chrome100",
+    .alias = "chrome100",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"100\", \"Google Chrome\";v=\"100\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome101",
+    .alias = "chrome101",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"101\", \"Google Chrome\";v=\"101\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome104",
+    .alias = "chrome104",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome107",
+    .alias = "chrome107",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"107\", \"Chromium\";v=\"107\", \"Not=A?Brand\";v=\"24\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome110",
+    .alias = "chrome110",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"110\", \"Not A(Brand\";v=\"24\", \"Google Chrome\";v=\"110\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome116",
+    .alias = "chrome116",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"116\", \"Not)A;Brand\";v=\"24\", \"Google Chrome\";v=\"116\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome119",
+    .alias = "chrome119",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"119\", \"Chromium\";v=\"119\", \"Not?A_Brand\";v=\"24\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome120",
+    .alias = "chrome120",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Google Chrome\";v=\"120\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome123",
+    .alias = "chrome123",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"123\", \"Not:A-Brand\";v=\"8\", \"Chromium\";v=\"123\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome124",
+    .alias = "chrome124",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519Kyber768Draft00:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"124\", \"Google Chrome\";v=\"124\", \"Not-A.Brand\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome131",
+    .alias = "chrome131",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"131\", \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome131_android",
+    .alias = "chrome131_android",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Google Chrome\";v=\"131\", \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Android\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Mobile Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome133a",
+    .alias = "chrome133a",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Not(A:Brand\";v=\"99\", \"Google Chrome\";v=\"133\", \"Chromium\";v=\"133\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = true,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome136",
+    .alias = "chrome136",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", \"Not.A/Brand\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = true,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome142",
+    .alias = "chrome142",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Chromium\";v=\"142\", \"Google Chrome\";v=\"142\", \"Not_A Brand\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = true,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome145",
+    .alias = "chrome145",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_permute_extensions = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \"Not:A-Brand\";v=\"99\", \"Google Chrome\";v=\"145\", \"Chromium\";v=\"145\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"macOS\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/145.0.0.0 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Accept-Language: en-US,en;q=0.9",
+      "Priority: u=0, i"
+    },
+    .http2_settings = "1:65536;2:0;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .http3_settings = "1:65536;6:262144;7:100;51:1;GREASE",
+    .http3_pseudo_headers_order = "masp",
+    .quic_transport_parameters = "1:30000;3:1472;4:15728640;5:6291456;6:6291456;7:6291456;8:100;9:103;15:;17:1@1,GREASE;32:65536;12583:AUTO;18258:1;GREASE",
+    .http3_tls_extension_order = "0-10-13-16-27-43-45-51-57-17613-65037",
+    .ech = "true",
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = true,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome99",
+    .alias = "chrome99",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"99\", \"Google Chrome\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "chrome99_android",
+    .alias = "chrome99_android",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"99\", \"Google Chrome\";v=\"99\"",
+      "sec-ch-ua-mobile: ?1",
+      "sec-ch-ua-platform: \"Android\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Linux; Android 12; Pixel 6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.58 Mobile Safari/537.36",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "edge101",
+    .alias = "edge101",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"101\", \"Microsoft Edge\";v=\"101\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36 Edg/101.0.1210.47",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "edge99",
+    .alias = "edge99",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "ECDHE-ECDSA-AES128-GCM-SHA256:"
+      "ECDHE-RSA-AES128-GCM-SHA256:"
+      "ECDHE-ECDSA-AES256-GCM-SHA384:"
+      "ECDHE-RSA-AES256-GCM-SHA384:"
+      "ECDHE-ECDSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-CHACHA20-POLY1305:"
+      "ECDHE-RSA-AES128-SHA:"
+      "ECDHE-RSA-AES256-SHA:"
+      "AES128-GCM-SHA256:"
+      "AES256-GCM-SHA384:"
+      "AES128-SHA:"
+      "AES256-SHA",
+    .npn = false,
+    .alpn = true,
+    .alps = true,
+    .tls_session_ticket = true,
+    .cert_compression = "brotli",
+    .http_headers = {
+      "sec-ch-ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"99\", \"Microsoft Edge\";v=\"99\"",
+      "sec-ch-ua-mobile: ?0",
+      "sec-ch-ua-platform: \"Windows\"",
+      "Upgrade-Insecure-Requests: 1",
+      "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36 Edg/99.0.1150.30",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-User: ?1",
+      "Sec-Fetch-Dest: document",
+      "Accept-Encoding: gzip, deflate, br",
+      "Accept-Language: en-US,en;q=0.9"
+    },
+    .http2_settings = "1:65536;3:1000;4:6291456;6:262144",
+    .http2_window_update = 15663105,
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 1,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "firefox133",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:133.0) Gecko/20100101 Firefox/133.0",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-US,en;q=0.5",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Upgrade-Insecure-Requests: 1",
+      "Sec-Fetch-Dest: document",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-User: ?1",
+      "Priority: u=0, i",
+      "Te: trailers"
+    },
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521:ffdhe2048:ffdhe3072",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_secp521r1_sha512:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha256:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pkcs1_sha512:"
+      "ecdsa_sha1:"
+      "rsa_pkcs1_sha1",
+    .alpn = true,
+    .http2_settings = "1:65536;2:0;4:131072;5:16384",
+    .http2_window_update = 12517377,
+    .http2_pseudo_headers_order = "mpas",
+    .http2_stream_exclusive = 0,
+    .cert_compression = "zlib,brotli,zstd",
+    .ech = "true",
+    .tls_session_ticket = true,
+    .tls_extension_order = "0-23-65281-10-11-35-16-5-34-51-43-13-45-28-27-65037",
+    .tls_delegated_credentials = "ecdsa_secp256r1_sha256:ecdsa_secp384r1_sha384:ecdsa_secp521r1_sha512:ecdsa_sha1",
+    .tls_record_size_limit = 4001,
+    .tls_grease = false,
+    .tls_signed_cert_timestamps = false,
+    .tls_key_shares_limit = 3,
+    .split_cookies = true,
+    .form_boundary = "firefox",
+  },
+  {
+    .target = "firefox135",
+    .alias = "firefox135",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/135.0",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-US,en;q=0.5",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Upgrade-Insecure-Requests: 1",
+      "Sec-Fetch-Dest: document",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-User: ?1",
+      "Priority: u=0, i",
+      "Te: trailers"
+    },
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521:ffdhe2048:ffdhe3072",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_secp521r1_sha512:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha256:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pkcs1_sha512:"
+      "ecdsa_sha1:"
+      "rsa_pkcs1_sha1",
+    .alpn = true,
+    .http2_settings = "1:65536;2:0;4:131072;5:16384",
+    .http2_window_update = 12517377,
+    .http2_pseudo_headers_order = "mpas",
+    .http2_stream_exclusive = 0,
+    .cert_compression = "zlib,brotli,zstd",
+    .ech = "true",
+    .tls_session_ticket = true,
+    .tls_extension_order = "0-23-65281-10-11-35-16-5-34-18-51-43-13-45-28-27-65037",
+    .tls_delegated_credentials = "ecdsa_secp256r1_sha256:ecdsa_secp384r1_sha384:ecdsa_secp521r1_sha512:ecdsa_sha1",
+    .tls_record_size_limit = 4001,
+    .tls_grease = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_key_shares_limit = 3,
+    .split_cookies = true,
+    .form_boundary = "firefox",
+  },
+  {
+    .target = "firefox144",
+    .alias = "firefox144",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/144.0",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-US,en;q=0.5",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Upgrade-Insecure-Requests: 1",
+      "Sec-Fetch-Dest: document",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-User: ?1",
+      "Priority: u=0, i",
+      "Te: trailers"
+    },
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521:ffdhe2048:ffdhe3072",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_secp521r1_sha512:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha256:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pkcs1_sha512:"
+      "ecdsa_sha1:"
+      "rsa_pkcs1_sha1",
+    .alpn = true,
+    .http2_settings = "1:65536;2:0;4:131072;5:16384",
+    .http2_window_update = 12517377,
+    .http2_pseudo_headers_order = "mpas",
+    .http2_stream_exclusive = 0,
+    .http2_stream_weight = 42,
+    .cert_compression = "zlib,brotli,zstd",
+    .ech = "true",
+    .tls_session_ticket = true,
+    .tls_extension_order = "0-23-65281-10-11-35-16-5-34-18-51-43-13-45-28-27-65037",
+    .tls_delegated_credentials = "ecdsa_secp256r1_sha256:ecdsa_secp384r1_sha384:ecdsa_secp521r1_sha512:ecdsa_sha1",
+    .tls_record_size_limit = 4001,
+    .tls_grease = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_key_shares_limit = 3,
+    .split_cookies = true,
+    .form_boundary = "firefox",
+  },
+  {
+    .target = "firefox147",
+    .alias = "firefox147",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:135.0) Gecko/20100101 Firefox/147.0",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-US,en;q=0.9",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Upgrade-Insecure-Requests: 1",
+      "Sec-Fetch-Dest: document",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-User: ?1",
+      "Priority: u=0, i",
+      "Te: trailers"
+    },
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521:ffdhe2048:ffdhe3072",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_secp521r1_sha512:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha256:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pkcs1_sha512:"
+      "ecdsa_sha1:"
+      "rsa_pkcs1_sha1",
+    .alpn = true,
+    .http2_settings = "1:65536;2:0;4:131072;5:16384",
+    .http2_window_update = 12517377,
+    .http2_pseudo_headers_order = "mpas",
+    .http2_stream_exclusive = 0,
+    .http2_stream_weight = 42,
+    .http3_settings = "1:65536;7:20;727725890:0;16765559:1;51:1;8:1",
+    .http3_pseudo_headers_order = "msap",
+    .quic_transport_parameters = "1:30000;4:25165824;5:12582912;6:1048576;7:1048576;8:100;9:100;11:20;14:8;15:AUTO;17:1@GREASE,1;GREASE;32:65535",
+    .http3_tls_extension_order = "28-51-27-13-34-10-45-16-65281-23-5-0-43-57-65037",
+    .cert_compression = "zlib,brotli,zstd",
+    .ech = "true",
+    .tls_session_ticket = true,
+    .tls_extension_order = "0-23-65281-10-11-35-16-5-34-18-51-43-13-45-28-27-65037",
+    .tls_delegated_credentials = "ecdsa_secp256r1_sha256:ecdsa_secp384r1_sha384:ecdsa_secp521r1_sha512:ecdsa_sha1",
+    .tls_record_size_limit = 4001,
+    .tls_grease = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_key_shares_limit = 3,
+    .split_cookies = true,
+    .form_boundary = "firefox",
+  },
+  {
+    .target = "okhttp4_android",
+    .alias = "okhttp4", /* not working */
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Sec-Fetch-Site: none",
+      "Accept-Encoding: gzip, deflate, br",
+      "Sec-Fetch-Mode: navigate",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
+      "Accept-Language: en-US,en;q=0.9",
+      "Sec-Fetch-Dest: document"
+    },
+    .http2_settings = "2:0;4:4194304;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+  },
+  {
+    .target = "safari153",
+    .alias = "safari15_3",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA256:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA,",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.3 Safari/605.1.15",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-us",
+      "Accept-Encoding: gzip, deflate, br"
+    },
+    .http2_settings = "4:4194304;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari155",
+    .alias = "safari15_5",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Safari/605.1.15",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-GB,en-US;q=0.9,en;q=0.8",
+      "Accept-Encoding: gzip, deflate, br"
+    },
+    .http2_settings = "4:4194304;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari170",
+    .alias = "safari17_0",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Sec-Fetch-Site: none",
+      "Accept-Encoding: gzip, deflate, br",
+      "Sec-Fetch-Mode: navigate",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
+      "Accept-Language: en-US,en;q=0.9",
+      "Sec-Fetch-Dest: document"
+    },
+    .http2_settings = "2:0;4:4194304;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari172_ios",
+    .alias = "safari17_2_ios",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_sha1:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Sec-Fetch-Site: none",
+      "Accept-Encoding: gzip, deflate, br",
+      "Sec-Fetch-Mode: navigate",
+      "User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1",
+      "Accept-Language: en-US,en;q=0.9",
+      "Sec-Fetch-Dest: document"
+    },
+    .http2_settings = "2:0;4:2097152;3:100",
+    .http2_window_update = 10485760,
+    .http2_pseudo_headers_order = "mspa",
+    .http2_stream_weight = 255,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari180",
+    .alias = "safari18_0",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Safari/605.1.15",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;8:1;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari180_ios",
+    .alias = "safari18_0_ios",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 18_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;8:1;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari184",
+    .alias = "safari18_4",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Safari/605.1.15",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari184_ios",
+    .alias = "safari18_4_ios",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .tls_session_ticket = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 18_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Mobile/15E148 Safari/604.1",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_stream_weight = 256,
+    .http2_stream_exclusive = 0,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari260",
+    .alias = "safari26_0",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Safari/605.1.15",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br, zstd"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_no_priority = true,
+    .tls_session_ticket = true,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari2601",
+    .alias = "safari26_0_1",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519MLKEM768:X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0.1 Safari/605.1.15",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_no_priority = true,
+    .tls_session_ticket = false,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "safari260_ios",
+    .alias = "safari26_0_ios",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:"
+      "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
+    .curves = "X25519:P-256:P-384:P-521",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pkcs1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha512:"
+      "rsa_pkcs1_sha1",
+    .npn = false,
+    .alpn = true,
+    .alps = false,
+    .cert_compression = "zlib",
+    .http_headers = {
+      "sec-fetch-dest: document",
+      "user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 26_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1",
+      "accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "sec-fetch-site: none",
+      "sec-fetch-mode: navigate",
+      "accept-language: en-US,en;q=0.9",
+      "priority: u=0, i",
+      "accept-encoding: gzip, deflate, br, zstd"
+    },
+    .http2_settings = "2:0;3:100;4:2097152;9:1",
+    .http2_window_update = 10420225,
+    .http2_pseudo_headers_order = "msap",
+    .http2_no_priority = true,
+    .tls_session_ticket = true,
+    .tls_extension_order = NULL,
+    .tls_use_new_alps_codepoint = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_grease = true,
+    .split_cookies = true,
+    .form_boundary = "webkit",
+  },
+  {
+    .target = "tor145",  // tor 14.5, based on firefox 128
+    .alias = "tor145",
+    .httpversion = CURL_HTTP_VERSION_2_0,
+    .ssl_version = CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_DEFAULT,
+    .ciphers =
+      "TLS_AES_128_GCM_SHA256:"
+      "TLS_CHACHA20_POLY1305_SHA256:"
+      "TLS_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:"
+      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:"
+      "TLS_RSA_WITH_AES_128_GCM_SHA256:"
+      "TLS_RSA_WITH_AES_256_GCM_SHA384:"
+      "TLS_RSA_WITH_AES_128_CBC_SHA:"
+      "TLS_RSA_WITH_AES_256_CBC_SHA",
+    .http_headers = {
+      "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:128.0) Gecko/20100101 Firefox/128.0",
+      "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
+      "Accept-Language: en-US,en;q=0.5",
+      "Accept-Encoding: gzip, deflate, br, zstd",
+      "Sec-GPC: 1",
+      "Upgrade-Insecure-Requests: 1",
+      "Sec-Fetch-Dest: document",
+      "Sec-Fetch-Mode: navigate",
+      "Sec-Fetch-Site: none",
+      "Sec-Fetch-User: ?1",
+      "Priority: u=0, i",
+      "Te: trailers"
+    },
+    .curves = "X25519:P-256:P-384:P-521:ffdhe2048:ffdhe3072",
+    .sig_hash_algs =
+      "ecdsa_secp256r1_sha256:"
+      "ecdsa_secp384r1_sha384:"
+      "ecdsa_secp521r1_sha512:"
+      "rsa_pss_rsae_sha256:"
+      "rsa_pss_rsae_sha384:"
+      "rsa_pss_rsae_sha512:"
+      "rsa_pkcs1_sha256:"
+      "rsa_pkcs1_sha384:"
+      "rsa_pkcs1_sha512:"
+      "ecdsa_sha1:"
+      "rsa_pkcs1_sha1",
+    .alpn = true,
+    .http2_settings = "1:65536;2:0;4:131072;5:16384",
+    .http2_window_update = 12517377,
+    .http2_pseudo_headers_order = "mpas",
+    .http2_stream_exclusive = 0,
+    .cert_compression = "zlib,brotli,zstd",
+    .ech = "true",
+    .tls_session_ticket = true,
+    .tls_extension_order = "0-23-65281-10-11-16-5-34-51-43-13-28-65037",
+    .tls_delegated_credentials = "ecdsa_secp256r1_sha256:ecdsa_secp384r1_sha384:ecdsa_secp521r1_sha512:ecdsa_sha1",
+    .tls_record_size_limit = 16385,
+    .tls_grease = false,
+    .tls_signed_cert_timestamps = true,
+    .tls_key_shares_limit = 2,
+    .split_cookies = true,
+    .form_boundary = "firefox",
+  }
+};
+
+const size_t num_impersonations = sizeof(impersonations) / sizeof(impersonations[0]);
diff --git a/lib/impersonate.h b/lib/impersonate.h
new file mode 100644
index 0000000000..a3b2370d11
--- /dev/null
+++ b/lib/impersonate.h
@@ -0,0 +1,68 @@
+#ifndef HEADER_CURL_IMPERSONATE_H
+#define HEADER_CURL_IMPERSONATE_H
+
+#define IMPERSONATE_MAX_HEADERS 32
+
+/*
+ * curl-impersonate: Options to be set for each supported target browser.
+ */
+struct impersonate_opts {
+  const char *target;
+  const char *alias;
+  int httpversion;
+  int ssl_version;
+  const char *ciphers;
+  /* Elliptic curves (TLS extension 10).
+   * Passed to CURLOPT_SSL_EC_CURVES */
+  const char *curves;
+  /* Signature hash algorithms (TLS extension 13).
+   * Passed to CURLOPT_SSL_SIG_HASH_ALGS */
+  const char *sig_hash_algs;
+  /* Enable TLS NPN extension. */
+  bool npn;
+  /* Enable TLS ALPN extension. */
+  bool alpn;
+  /* Enable TLS ALPS extension. */
+  bool alps;
+  /* Enable TLS session ticket extension. */
+  bool tls_session_ticket;
+  /* TLS certificate compression algorithms.
+   * (TLS extension 27) */
+  const char *cert_compression;
+  const char *http_headers[IMPERSONATE_MAX_HEADERS];
+  const char *http2_pseudo_headers_order;
+  const char *http2_settings;
+  int http2_window_update;
+  const char *http2_streams;
+  const char *http3_pseudo_headers_order;
+  const char *http3_settings;
+  const char *quic_transport_parameters;
+  bool tls_permute_extensions;
+  bool tls_use_new_alps_codepoint;
+  bool tls_signed_cert_timestamps;
+  const char *ech;
+  const char *tls_extension_order;
+  const char *http3_tls_extension_order;
+  const char *tls_delegated_credentials;
+  int tls_record_size_limit;
+  int tls_key_shares_limit;  // for firefox key_shares extension
+  bool tls_grease;
+  int http2_stream_weight;
+  int http2_stream_exclusive;
+  bool http2_no_priority;  // disable http2 priority in header frame
+  bool proxy_credential_no_reuse;  // do not reuse TLS sessions or connections from different proxy credentials
+  bool split_cookies;  // split cookies into one Cookie header per pair
+  const char *form_boundary;
+
+  /* Other TLS options will come here in the future once they are
+   * configurable through curl_easy_setopt() */
+};
+
+/*
+ * curl-impersonate: Global array of supported browsers and their
+ * impersonation options.
+ */
+extern const struct impersonate_opts impersonations[];
+extern const size_t num_impersonations;
+
+#endif /* HEADER_CURL_IMPERSONATE_H */
diff --git a/lib/libcurl.def b/lib/libcurl.def
index 43e26f655c..8537a108e5 100644
--- a/lib/libcurl.def
+++ b/lib/libcurl.def
@@ -5,6 +5,7 @@ curl_easy_escape
 curl_easy_getinfo
 curl_easy_header
 curl_easy_init
+curl_easy_impersonate
 curl_easy_nextheader
 curl_easy_option_by_id
 curl_easy_option_by_name
diff --git a/lib/mime.c b/lib/mime.c
index 06cd221abf..2e2e723f9b 100644
--- a/lib/mime.c
+++ b/lib/mime.c
@@ -79,6 +79,62 @@ static size_t encoder_qp_read(char *buffer, size_t size, bool ateof,
 static curl_off_t encoder_qp_size(curl_mimepart *part);
 static curl_off_t mime_size(curl_mimepart *part);
 
+static CURLcode mime_set_boundary(struct Curl_easy *easy, curl_mime *mime)
+{
+  const char *form_boundary = NULL;
+
+  if(easy)
+    form_boundary = easy->set.str[STRING_FORM_BOUNDARY];
+
+  if(form_boundary && curl_strequal(form_boundary, "webkit")) {
+    memcpy(mime->boundary, MIME_WEBKIT_BOUNDARY_PREFIX,
+           sizeof(MIME_WEBKIT_BOUNDARY_PREFIX) - 1);
+    return Curl_rand_alnum(easy,
+                           (unsigned char *)
+                           &mime->boundary[sizeof(MIME_WEBKIT_BOUNDARY_PREFIX)
+                                           - 1],
+                           MIME_WEBKIT_BOUNDARY_CHARS + 1);
+  }
+  if(form_boundary && curl_strequal(form_boundary, "firefox")) {
+    memcpy(mime->boundary, MIME_FIREFOX_BOUNDARY_PREFIX,
+           sizeof(MIME_FIREFOX_BOUNDARY_PREFIX) - 1);
+    return Curl_rand_hex(easy,
+                         (unsigned char *)
+                         &mime->boundary[sizeof(MIME_FIREFOX_BOUNDARY_PREFIX)
+                                         - 1],
+                         MIME_FIREFOX_BOUNDARY_CHARS + 1);
+  }
+
+  memset(mime->boundary, '-', MIME_BOUNDARY_DASHES);
+  return Curl_rand_alnum(easy,
+                         (unsigned char *)
+                         &mime->boundary[MIME_BOUNDARY_DASHES],
+                         MIME_RAND_BOUNDARY_CHARS + 1);
+}
+
+CURLcode Curl_mime_set_form_boundary(struct Curl_easy *easy, curl_mime *mime)
+{
+  CURLcode result;
+  curl_mimepart *part;
+
+  if(!mime)
+    return CURLE_OK;
+
+  result = mime_set_boundary(easy, mime);
+  if(result)
+    return result;
+
+  for(part = mime->firstpart; part; part = part->nextpart) {
+    if(part->kind == MIMEKIND_MULTIPART) {
+      result = Curl_mime_set_form_boundary(easy, (curl_mime *) part->arg);
+      if(result)
+        return result;
+    }
+  }
+
+  return CURLE_OK;
+}
+
 static const struct mime_encoder encoders[] = {
   {"binary", encoder_nop_read, encoder_nop_size},
   {"8bit", encoder_nop_read, encoder_nop_size},
@@ -999,6 +1055,7 @@ static size_t mime_subparts_read(char *buffer, size_t size, size_t nitems,
                                  void *instream, bool *hasread)
 {
   curl_mime *mime = (curl_mime *) instream;
+  size_t boundarylen = strlen(mime->boundary);
   size_t cursize = 0;
   (void) size;   /* Always 1. */
 
@@ -1023,10 +1080,10 @@ static size_t mime_subparts_read(char *buffer, size_t size, size_t nitems,
     case MIMESTATE_BOUNDARY2:
       if(part)
         sz = readback_bytes(&mime->state, buffer, nitems, mime->boundary,
-                            MIME_BOUNDARY_LEN, STRCONST("\r\n"));
+                            boundarylen, STRCONST("\r\n"));
       else
         sz = readback_bytes(&mime->state, buffer, nitems, mime->boundary,
-                            MIME_BOUNDARY_LEN, STRCONST("--\r\n"));
+                            boundarylen, STRCONST("--\r\n"));
       if(!sz) {
         mimesetstate(&mime->state, MIMESTATE_CONTENT, part);
       }
@@ -1280,6 +1337,7 @@ CURLcode Curl_mime_duppart(struct Curl_easy *data,
 /* Create a mime handle. */
 curl_mime *curl_mime_init(void *easy)
 {
+  struct Curl_easy *data = (struct Curl_easy *) easy;
   curl_mime *mime;
 
   mime = (curl_mime *) malloc(sizeof(*mime));
@@ -1289,10 +1347,7 @@ curl_mime *curl_mime_init(void *easy)
     mime->firstpart = NULL;
     mime->lastpart = NULL;
 
-    memset(mime->boundary, '-', MIME_BOUNDARY_DASHES);
-    if(Curl_rand_alnum(easy,
-                       (unsigned char *) &mime->boundary[MIME_BOUNDARY_DASHES],
-                       MIME_RAND_BOUNDARY_CHARS + 1)) {
+    if(Curl_mime_set_form_boundary(data, mime)) {
       /* failed to get random separator, bail out */
       free(mime);
       return NULL;
@@ -1640,7 +1695,7 @@ static curl_off_t multipart_size(curl_mime *mime)
   if(!mime)
     return 0;           /* Not present -> empty. */
 
-  boundarysize = 4 + MIME_BOUNDARY_LEN + 2;
+  boundarysize = 4 + (curl_off_t) strlen(mime->boundary) + 2;
   size = boundarysize;  /* Final boundary - CRLF after headers. */
 
   for(part = mime->firstpart; part; part = part->nextpart) {
diff --git a/lib/mime.h b/lib/mime.h
index 5073a38f70..f5fe2b499f 100644
--- a/lib/mime.h
+++ b/lib/mime.h
@@ -28,6 +28,10 @@
 
 #define MIME_BOUNDARY_DASHES            24  /* leading boundary dashes */
 #define MIME_RAND_BOUNDARY_CHARS        22  /* Nb. of random boundary chars. */
+#define MIME_WEBKIT_BOUNDARY_PREFIX "------WebKitFormBoundary"
+#define MIME_WEBKIT_BOUNDARY_CHARS      16
+#define MIME_FIREFOX_BOUNDARY_PREFIX "------geckoformboundary"
+#define MIME_FIREFOX_BOUNDARY_CHARS     32
 #define MAX_ENCODED_LINE_LENGTH         76  /* Maximum encoded line length. */
 #define ENCODING_BUFFER_SIZE            256 /* Encoding temp buffers size. */
 
@@ -95,7 +99,8 @@ struct mime_state {
 };
 
 /* Boundary string length. */
-#define MIME_BOUNDARY_LEN (MIME_BOUNDARY_DASHES + MIME_RAND_BOUNDARY_CHARS)
+#define MIME_BOUNDARY_LEN (sizeof(MIME_FIREFOX_BOUNDARY_PREFIX) - 1 + \
+                           MIME_FIREFOX_BOUNDARY_CHARS)
 
 /* A mime multipart. */
 struct curl_mime {
@@ -151,6 +156,7 @@ CURLcode Curl_mime_prepare_headers(struct Curl_easy *data,
                                    const char *contenttype,
                                    const char *disposition,
                                    enum mimestrategy strategy);
+CURLcode Curl_mime_set_form_boundary(struct Curl_easy *easy, curl_mime *mime);
 size_t Curl_mime_read(char *buffer, size_t size, size_t nitems,
                       void *instream);
 const char *Curl_mime_contenttype(const char *filename);
@@ -168,6 +174,7 @@ CURLcode Curl_creader_set_mime(struct Curl_easy *data, curl_mimepart *part);
 #define Curl_mime_duppart(x,y,z) CURLE_OK /* Nothing to duplicate. Succeed */
 #define Curl_mime_set_subparts(a,b,c) CURLE_NOT_BUILT_IN
 #define Curl_mime_prepare_headers(a,b,c,d,e) CURLE_NOT_BUILT_IN
+#define Curl_mime_set_form_boundary(a,b) CURLE_NOT_BUILT_IN
 #define Curl_mime_read NULL
 #define Curl_creader_set_mime(x,y) ((void)x, CURLE_NOT_BUILT_IN)
 #endif
diff --git a/lib/multi.c b/lib/multi.c
index b3a7938e33..5da6f894e7 100644
--- a/lib/multi.c
+++ b/lib/multi.c
@@ -243,7 +243,8 @@ struct Curl_multi *Curl_multi_handle(unsigned int xfer_table_size,
   Curl_llist_init(&multi->msglist, NULL);
 
   multi->multiplexing = TRUE;
-  multi->max_concurrent_streams = 100;
+  /* curl-impersonate: Use 1000 concurrent streams like Chrome. */
+  multi->max_concurrent_streams = 1000;
   multi->last_timeout_ms = -1;
 
   if(Curl_uint_bset_resize(&multi->process, xfer_table_size) ||
diff --git a/lib/setopt.c b/lib/setopt.c
index 1380c33db6..964442f12c 100644
--- a/lib/setopt.c
+++ b/lib/setopt.c
@@ -52,6 +52,7 @@
 #include "altsvc.h"
 #include "hsts.h"
 #include "tftp.h"
+#include "slist.h"
 #include "strdup.h"
 #include "escape.h"
 
@@ -108,6 +109,12 @@ CURLcode Curl_setstropt(char **charp, const char *s)
   return CURLE_OK;
 }
 
+static bool setopt_valid_form_boundary(const char *value)
+{
+  return curl_strequal(value, "webkit") ||
+         curl_strequal(value, "firefox");
+}
+
 CURLcode Curl_setblobopt(struct curl_blob **blobp,
                          const struct curl_blob *blob)
 {
@@ -658,6 +665,9 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
      */
     data->set.cookiesession = enabled;
     break;
+  case CURLOPT_SPLIT_COOKIES:
+    data->set.split_cookies = enabled;
+    break;
 #endif
   case CURLOPT_AUTOREFERER:
     /*
@@ -747,6 +757,12 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
   case CURLOPT_HTTP_VERSION:
     return setopt_HTTP_VERSION(data, arg);
 
+#ifdef USE_HTTP2
+  case CURLOPT_STREAM_EXCLUSIVE:
+    data->set.priority.exclusive = (int)arg;
+    break;
+#endif
+
   case CURLOPT_EXPECT_100_TIMEOUT_MS:
     /*
      * Time to wait for a response to an HTTP request containing an
@@ -834,6 +850,9 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
     /* Update the current connection proxy_ssl_config. */
     Curl_ssl_conn_config_update(data, TRUE);
     break;
+  case CURLOPT_PROXY_CREDENTIAL_NO_REUSE:
+    data->set.proxy_credential_no_reuse = enabled;
+    break;
 #endif /* ! CURL_DISABLE_PROXY */
 
 #if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
@@ -1334,6 +1353,38 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
   case CURLOPT_SSL_ENABLE_ALPN:
     data->set.ssl_enable_alpn = enabled;
     break;
+  case CURLOPT_SSL_ENABLE_ALPS:
+    data->set.ssl_enable_alps = enabled;
+    break;
+  case CURLOPT_SSL_ENABLE_TICKET:
+    data->set.ssl_enable_ticket = enabled;
+    break;
+  case CURLOPT_SSL_PERMUTE_EXTENSIONS:
+    data->set.ssl_permute_extensions = enabled;
+    break;
+  case CURLOPT_TLS_GREASE:
+    data->set.tls_grease = enabled;
+    break;
+  case CURLOPT_TLS_KEY_USAGE_NO_CHECK:
+    data->set.tls_key_usage_no_check = enabled;
+    break;
+  case CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS:
+    data->set.tls_signed_cert_timestamps = enabled;
+    break;
+  case CURLOPT_TLS_STATUS_REQUEST:
+    data->set.tls_status_request = enabled;
+    break;
+
+#ifdef USE_HTTP2
+  case CURLOPT_HTTP2_WINDOW_UPDATE:
+    if(arg < -1)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    data->set.http2_window_update = arg;
+    break;
+  case CURLOPT_HTTP2_NO_PRIORITY:
+    data->set.http2_no_priority = arg;
+    break;
+#endif
   case CURLOPT_PATH_AS_IS:
     data->set.path_as_is = enabled;
     break;
@@ -1370,9 +1421,17 @@ static CURLcode setopt_long(struct Curl_easy *data, CURLoption option,
     break;
   case CURLOPT_MAXAGE_CONN:
     return setopt_set_timeout_sec(&data->set.conn_max_idle_ms, arg);
-
   case CURLOPT_MAXLIFETIME_CONN:
     return setopt_set_timeout_sec(&data->set.conn_max_age_ms, arg);
+  case CURLOPT_TLS_RECORD_SIZE_LIMIT:
+    data->set.tls_record_size_limit = arg;
+    break;
+  case CURLOPT_TLS_KEY_SHARES_LIMIT:
+    data->set.tls_key_shares_limit = arg;
+    break;
+  case CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT:
+    data->set.tls_use_new_alps_codepoint = enabled;
+    break;
 
 #ifndef CURL_DISABLE_HSTS
   case CURLOPT_HSTS_CTRL:
@@ -1500,6 +1559,21 @@ static CURLcode setopt_slist(struct Curl_easy *data, CURLoption option,
      */
     data->set.headers = slist;
     break;
+  case CURLOPT_HTTPBASEHEADER:
+    /*
+     * curl-impersonate:
+     * Set a list of "base" headers. These will be merged with any headers
+     * set by CURLOPT_HTTPHEADER. curl-impersonate uses this option in order
+     * to set a list of default browser headers.
+     *
+     * Unlike CURLOPT_HTTPHEADER,
+     * the list is copied and can be immediately freed by the user.
+     */
+    curl_slist_free_all(data->state.base_headers);
+    data->state.base_headers = Curl_slist_duplicate(slist);
+    if (!data->state.base_headers)
+      result = CURLE_OUT_OF_MEMORY;
+    break;
 #endif
 #ifndef CURL_DISABLE_TELNET
   case CURLOPT_TELNETOPTIONS:
@@ -1555,6 +1629,9 @@ static CURLcode setopt_pointers(struct Curl_easy *data, CURLoption option,
     result = Curl_mime_set_subparts(&data->set.mimepost,
                                     va_arg(param, curl_mime *),
                                     FALSE);
+    if(!result && data->set.str[STRING_FORM_BOUNDARY]) {
+      result = Curl_mime_set_form_boundary(data, (curl_mime *) data->set.mimepost.arg);
+    }
     if(!result) {
       data->set.method = HTTPREQ_POST_MIME;
       data->set.opt_no_body = FALSE; /* this is implied */
@@ -1689,6 +1766,63 @@ static CURLcode setopt_cptr(struct Curl_easy *data, CURLoption option,
     }
     else
       return CURLE_NOT_BUILT_IN;
+  // curl-impersonate
+  case CURLOPT_IMPERSONATE:
+    result = Curl_setstropt(&data->set.str[STRING_IMPERSONATE], ptr);
+    if(result)
+      return result;
+    // for the master option, we simply call the easy_impersonate method here.
+    return curl_easy_impersonate(data, data->set.str[STRING_IMPERSONATE], true);
+    break;
+  case CURLOPT_FORM_BOUNDARY:
+    if(ptr && !setopt_valid_form_boundary(ptr))
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    result = Curl_setstropt(&data->set.str[STRING_FORM_BOUNDARY], ptr);
+    if(result)
+      return result;
+    return Curl_mime_set_form_boundary(data, (curl_mime *) data->set.mimepost.arg);
+    break;
+  case CURLOPT_TLS_EXTENSION_ORDER:
+    return Curl_setstropt(&data->set.str[STRING_TLS_EXTENSION_ORDER], ptr);
+    break;
+  case CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER:
+    return Curl_setstropt(&data->set.str[STRING_HTTP2_PSEUDO_HEADERS_ORDER], ptr);
+    break;
+  case CURLOPT_HTTP2_SETTINGS:
+    return Curl_setstropt(&data->set.str[STRING_HTTP2_SETTINGS], ptr);
+    break;
+  case CURLOPT_HTTP3_PSEUDO_HEADERS_ORDER:
+    return Curl_setstropt(&data->set.str[STRING_HTTP3_PSEUDO_HEADERS_ORDER], ptr);
+    break;
+  case CURLOPT_HTTP3_SETTINGS:
+    return Curl_setstropt(&data->set.str[STRING_HTTP3_SETTINGS], ptr);
+    break;
+  case CURLOPT_QUIC_TRANSPORT_PARAMETERS:
+    return Curl_setstropt(&data->set.str[STRING_QUIC_TRANSPORT_PARAMETERS], ptr);
+    break;
+  case CURLOPT_HTTP2_STREAMS:
+    return Curl_setstropt(&data->set.str[STRING_HTTP2_STREAMS], ptr);
+    break;
+  case CURLOPT_SSL_SIG_HASH_ALGS:
+    /*
+     * Set the list of hash algorithms we want to use in the SSL connection.
+     * Specify comma-delimited list of algorithms to use.
+     */
+    return Curl_setstropt(&data->set.str[STRING_SSL_SIG_HASH_ALGS], ptr);
+    break;
+  case CURLOPT_SSL_CERT_COMPRESSION:
+    /*
+     * Set the list of ceritifcate compression algorithms we support in the TLS
+     * connection.
+     * Specify comma-delimited list of algorithms to use. Options are "zlib"
+     * and "brotli".
+     */
+    return Curl_setstropt(&data->set.str[STRING_SSL_CERT_COMPRESSION], ptr);
+    break;
+  case CURLOPT_TLS_DELEGATED_CREDENTIALS:
+    return Curl_setstropt(&data->set.str[STRING_TLS_DELEGATED_CREDENTIALS], ptr);
+    break;
+
 #ifndef CURL_DISABLE_PROXY
   case CURLOPT_PROXY_TLS13_CIPHERS:
     if(Curl_ssl_supports(data, SSLSUPP_TLS13_CIPHERSUITES))
@@ -3039,6 +3173,7 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption option, va_list param)
        way than being listed explicitly */
     switch(option) {
     case CURLOPT_HTTPHEADER:
+    case CURLOPT_HTTPBASEHEADER:
     case CURLOPT_QUOTE:
     case CURLOPT_POSTQUOTE:
     case CURLOPT_TELNETOPTIONS:
diff --git a/lib/socks.c b/lib/socks.c
index 7d25ef5208..fa3fe86f19 100644
--- a/lib/socks.c
+++ b/lib/socks.c
@@ -38,10 +38,16 @@
 #include "select.h"
 #include "cfilters.h"
 #include "connect.h"
+#include "cf-socket.h"
+#if defined(USE_NGTCP2) && defined(USE_NGHTTP3)
+#include "vquic/curl_ngtcp2.h"
+#endif
 #include "curlx/timeval.h"
 #include "socks.h"
 #include "multiif.h" /* for getsock macros */
+#include "curl_addrinfo.h"
 #include "curlx/inet_pton.h"
+#include "curlx/inet_ntop.h"
 #include "url.h"
 
 /* The last 3 #include files should be in this order */
@@ -71,6 +77,17 @@ enum connect_t {
   CONNECT_DONE /* 17 connected fine to the remote or the SOCKS proxy */
 };
 
+enum socks5_atyp {
+  SOCKS5_ATYP_IPV4 = 1,
+  SOCKS5_ATYP_DOMAIN = 3,
+  SOCKS5_ATYP_IPV6 = 4
+};
+
+#define SOCKS5_REPLY_HEADER_LEN 4
+#define SOCKS5_PORT_LEN 2
+#define SOCKS5_IPV4_ADDR_LEN 4
+#define SOCKS5_IPV6_ADDR_LEN 16
+
 #define CURL_SOCKS_BUF_SIZE 600
 
 /* make sure we configure it not too low */
@@ -89,6 +106,25 @@ struct socks_state {
   int remote_port;
   const char *proxy_user;
   const char *proxy_password;
+
+  // See more in RFC 1928
+  size_t replylen;                  /* SOCKS5 reply length to read after fixed header */
+  struct Curl_cfilter *tcp_cf;      /* TCP control channel to the SOCKS proxy for UDP */
+  struct Curl_cfilter *udp_cf;      /* UDP data relay channel to the SOCKS proxy */
+
+  unsigned char udp_relay_addr[16]; /* relay address, port and family */
+  int udp_relay_port;
+  int udp_relay_family;
+  int udp_dest_atyp;                /* SOCKS5 ATYP for UDP destination */
+  unsigned char udp_dest_addr[16];  /* QUIC destination address, port and family */
+  int udp_dest_port;
+  int udp_dest_family;
+  unsigned char udp_dest_domain[256];
+  size_t udp_dest_domain_len;
+  struct Curl_sockaddr_ex udp_peer_addr;
+  BIT(udp_peer_set);
+  BIT(udp_associate);               /* use SOCKS5 UDP ASSOCIATE instead of CONNECT */
+  BIT(udp_dest_set);                /* QUIC destination cached for UDP headers */
 };
 
 #if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
@@ -257,6 +293,61 @@ static CURLproxycode socks_state_recv(struct Curl_cfilter *cf,
   return CURLPX_OK;
 }
 
+/* curl-impersonate: set up udp relay
+ * Parse the address in reply and store the relay address/port in socks_state.
+ */
+static CURLproxycode socks5_set_udp_relay(struct socks_state *sx,
+                                          struct Curl_easy *data)
+{
+  const unsigned char *socksreq = sx->buffer;
+  const unsigned char *addrp =
+    &socksreq[SOCKS5_REPLY_HEADER_LEN]; /* First bytes are VER, REP, RSV, ATYP */
+  size_t addrlen;
+  int atyp = socksreq[3]; /* ATYP from SOCKS5 reply */
+
+  if(sx->replylen < (SOCKS5_REPLY_HEADER_LEN + SOCKS5_PORT_LEN)) {
+    failf(data, "SOCKS5 UDP associate reply too short");
+    return CURLPX_BAD_ADDRESS_TYPE;
+  }
+
+  switch(atyp) {
+    case SOCKS5_ATYP_IPV4:
+      addrlen = SOCKS5_IPV4_ADDR_LEN;
+      sx->udp_relay_family = AF_INET;
+      break;
+#ifdef USE_IPV6
+    case SOCKS5_ATYP_IPV6:
+      addrlen = SOCKS5_IPV6_ADDR_LEN;
+      sx->udp_relay_family = AF_INET6;
+      break;
+#endif
+    case SOCKS5_ATYP_DOMAIN:
+    default:
+      failf(data, "SOCKS5 UDP associate reply has wrong address type.");
+      return CURLPX_BAD_ADDRESS_TYPE;
+  }
+
+  if(SOCKS5_REPLY_HEADER_LEN + addrlen + SOCKS5_PORT_LEN > sx->replylen) {
+    failf(data, "SOCKS5 UDP associate reply truncated");
+    return CURLPX_BAD_ADDRESS_TYPE;
+  }
+
+  memcpy(sx->udp_relay_addr, addrp, addrlen);
+  /* Port is in network byte order in the last two bytes. */
+  sx->udp_relay_port = (int)((addrp[addrlen] << 8) | addrp[addrlen + 1]);
+
+  /* Log the udp relay info */
+  {
+    char addrstr[MAX_IPADR_LEN] = "";
+    if(!curlx_inet_ntop(sx->udp_relay_family, sx->udp_relay_addr,
+                        addrstr, sizeof(addrstr)))
+      strcpy(addrstr, "unknown");
+    infof(data, "SOCKS5 UDP relay reply ATYP=%d BND.ADDR=%s BND.PORT=%d",
+          atyp, addrstr, sx->udp_relay_port);
+  }
+  return CURLPX_OK;
+}
+
 /*
 * This function logs in to a SOCKS4 proxy and sends the specifics to the final
 * destination server.
@@ -769,6 +860,22 @@ CONNECT_AUTH_INIT:
     FALLTHROUGH();
   case CONNECT_REQ_INIT:
 CONNECT_REQ_INIT:
+    /* curl-impersonate: init the UDP associate req by resolving DNS */
+    if(sx->udp_associate) {
+      if(!socks5_resolve_local)
+        goto CONNECT_RESOLVE_REMOTE;
+      result = Curl_resolv(data, sx->hostname, sx->remote_port,
+                           cf->conn->ip_version, TRUE, &dns);
+
+      if(result == CURLE_AGAIN) {
+        sxstate(sx, data, CONNECT_RESOLVING);
+        return CURLPX_OK;
+      }
+      else if(result)
+        return CURLPX_RESOLVE_HOST;
+      sxstate(sx, data, CONNECT_RESOLVED);
+      goto CONNECT_RESOLVED;
+    }
     if(socks5_resolve_local) {
       result = Curl_resolv(data, sx->hostname, sx->remote_port,
                            cf->conn->ip_version, TRUE, &dns);
@@ -819,12 +926,86 @@ CONNECT_RESOLVED:
 
     len = 0;
     socksreq[len++] = 5; /* version (SOCKS5) */
-    socksreq[len++] = 1; /* connect */
+    socksreq[len++] = sx->udp_associate ? 3 : 1; /* associate: 0x03, connect: 0x01 */
     socksreq[len++] = 0; /* must be zero */
+    if(sx->udp_associate) {
+      if(hp->ai_family == AF_INET) {
+        struct sockaddr_in *saddr_in;
+        saddr_in = (struct sockaddr_in *)(void *)hp->ai_addr;
+        memcpy(sx->udp_dest_addr, &saddr_in->sin_addr, sizeof(struct in_addr));
+        sx->udp_dest_family = AF_INET;
+        sx->udp_dest_atyp = SOCKS5_ATYP_IPV4;
+      }
+#ifdef USE_IPV6
+      else if(hp->ai_family == AF_INET6) {
+        struct sockaddr_in6 *saddr_in6;
+        saddr_in6 = (struct sockaddr_in6 *)(void *)hp->ai_addr;
+        memcpy(sx->udp_dest_addr, &saddr_in6->sin6_addr,
+               sizeof(struct in6_addr));
+        sx->udp_dest_family = AF_INET6;
+        sx->udp_dest_atyp = SOCKS5_ATYP_IPV6;
+      }
+#endif
+      else {
+        failf(data, "SOCKS5 UDP associate to %s not supported", dest);
+        return CURLPX_BAD_ADDRESS_TYPE;
+      }
+      sx->udp_dest_port = sx->remote_port;
+      sx->udp_dest_set = TRUE;
+      if(sx->udp_dest_atyp == SOCKS5_ATYP_IPV4 ||
+         sx->udp_dest_atyp == SOCKS5_ATYP_IPV6) {
+        memset(&sx->udp_peer_addr, 0, sizeof(sx->udp_peer_addr));
+        if(sx->udp_dest_atyp == SOCKS5_ATYP_IPV4) {
+          struct sockaddr_in *sa =
+            (struct sockaddr_in *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+          sa->sin_family = AF_INET;
+          memcpy(&sa->sin_addr, sx->udp_dest_addr, sizeof(struct in_addr));
+          sa->sin_port = htons((unsigned short)sx->udp_dest_port);
+          sx->udp_peer_addr.family = AF_INET;
+          sx->udp_peer_addr.socktype = SOCK_DGRAM;
+          sx->udp_peer_addr.protocol = IPPROTO_UDP;
+          sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in);
+          sx->udp_peer_set = TRUE;
+        }
+#ifdef USE_IPV6
+        else {
+          struct sockaddr_in6 *sa6 =
+            (struct sockaddr_in6 *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+          sa6->sin6_family = AF_INET6;
+          memcpy(&sa6->sin6_addr, sx->udp_dest_addr, sizeof(struct in6_addr));
+          sa6->sin6_port = htons((unsigned short)sx->udp_dest_port);
+          sx->udp_peer_addr.family = AF_INET6;
+          sx->udp_peer_addr.socktype = SOCK_DGRAM;
+          sx->udp_peer_addr.protocol = IPPROTO_UDP;
+          sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in6);
+          sx->udp_peer_set = TRUE;
+        }
+#endif
+      }
+
+      infof(data, "SOCKS5 UDP associate storing target %s:%d for UDP header",
+            dest, sx->udp_dest_port);
+
+      if(sx->udp_dest_family == AF_INET6) {
+        socksreq[len++] = SOCKS5_ATYP_IPV6;
+        memset(&socksreq[len], 0, SOCKS5_IPV6_ADDR_LEN);
+        len += SOCKS5_IPV6_ADDR_LEN;
+      }
+      else {
+        socksreq[len++] = SOCKS5_ATYP_IPV4;
+        memset(&socksreq[len], 0, SOCKS5_IPV4_ADDR_LEN);
+        len += SOCKS5_IPV4_ADDR_LEN;
+      }
+
+      infof(data, "SOCKS5 UDP associate to %s:%d (locally resolved)", dest,
+            sx->remote_port);
+      Curl_resolv_unlink(data, &dns); /* not used anymore from now on */
+      goto CONNECT_REQ_SEND;
+    }
     if(hp->ai_family == AF_INET) {
       int i;
       struct sockaddr_in *saddr_in;
-      socksreq[len++] = 1; /* ATYP: IPv4 = 1 */
+      socksreq[len++] = SOCKS5_ATYP_IPV4;
 
       saddr_in = (struct sockaddr_in *)(void *)hp->ai_addr;
       for(i = 0; i < 4; i++) {
@@ -838,7 +1019,7 @@ CONNECT_RESOLVED:
     else if(hp->ai_family == AF_INET6) {
       int i;
       struct sockaddr_in6 *saddr_in6;
-      socksreq[len++] = 4; /* ATYP: IPv6 = 4 */
+      socksreq[len++] = SOCKS5_ATYP_IPV6;
 
       saddr_in6 = (struct sockaddr_in6 *)(void *)hp->ai_addr;
       for(i = 0; i < 16; i++) {
@@ -863,9 +1044,82 @@ CONNECT_RESOLVE_REMOTE:
     /* Authentication is complete, now specify destination to the proxy */
     len = 0;
     socksreq[len++] = 5; /* version (SOCKS5) */
-    socksreq[len++] = 1; /* connect */
+    socksreq[len++] = sx->udp_associate ? 3 : 1; /* associate: 0x03, connect: 0x01 */
     socksreq[len++] = 0; /* must be zero */
 
+    if(sx->udp_associate) {
+      unsigned char ip4[4];
+#ifdef USE_IPV6
+      char ip6[16];
+#endif
+      if(hostname_len > 255) {
+        failf(data, "SOCKS5: the destination hostname is too long to be "
+              "resolved remotely by the proxy.");
+        return CURLPX_LONG_HOSTNAME;
+      }
+      /* Cache target port up front so cached peer info uses the right value. */
+      sx->udp_dest_port = sx->remote_port;
+      if(1 == curlx_inet_pton(AF_INET, sx->hostname, ip4)) {
+        memcpy(sx->udp_dest_addr, ip4, sizeof(ip4));
+        sx->udp_dest_family = AF_INET;
+        sx->udp_dest_atyp = SOCKS5_ATYP_IPV4;
+        memset(&sx->udp_peer_addr, 0, sizeof(sx->udp_peer_addr));
+        {
+          struct sockaddr_in *sa =
+            (struct sockaddr_in *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+          sa->sin_family = AF_INET;
+          memcpy(&sa->sin_addr, sx->udp_dest_addr, sizeof(struct in_addr));
+          sa->sin_port = htons((unsigned short)sx->udp_dest_port);
+          sx->udp_peer_addr.family = AF_INET;
+          sx->udp_peer_addr.socktype = SOCK_DGRAM;
+          sx->udp_peer_addr.protocol = IPPROTO_UDP;
+          sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in);
+          sx->udp_peer_set = TRUE;
+        }
+      }
+#ifdef USE_IPV6
+      else if(1 == curlx_inet_pton(AF_INET6, sx->hostname, ip6)) {
+        memcpy(sx->udp_dest_addr, ip6, sizeof(ip6));
+        sx->udp_dest_family = AF_INET6;
+        sx->udp_dest_atyp = SOCKS5_ATYP_IPV6;
+        memset(&sx->udp_peer_addr, 0, sizeof(sx->udp_peer_addr));
+        {
+          struct sockaddr_in6 *sa6 =
+            (struct sockaddr_in6 *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+          sa6->sin6_family = AF_INET6;
+          memcpy(&sa6->sin6_addr, sx->udp_dest_addr, sizeof(struct in6_addr));
+          sa6->sin6_port = htons((unsigned short)sx->udp_dest_port);
+          sx->udp_peer_addr.family = AF_INET6;
+          sx->udp_peer_addr.socktype = SOCK_DGRAM;
+          sx->udp_peer_addr.protocol = IPPROTO_UDP;
+          sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in6);
+          sx->udp_peer_set = TRUE;
+        }
+      }
+#endif
+      else {
+        sx->udp_dest_atyp = SOCKS5_ATYP_DOMAIN;
+        memcpy(sx->udp_dest_domain, sx->hostname, hostname_len);
+        sx->udp_dest_domain_len = hostname_len;
+      }
+      sx->udp_dest_set = TRUE;
+
+      if(data->set.ipver == CURL_IPRESOLVE_V6) {
+        socksreq[len++] = SOCKS5_ATYP_IPV6;
+        memset(&socksreq[len], 0, 16);
+        len += 16;
+      }
+      else {
+        socksreq[len++] = SOCKS5_ATYP_IPV4;
+        memset(&socksreq[len], 0, 4);
+        len += 4;
+      }
+
+      infof(data, "SOCKS5 UDP associate to %s:%d (remotely resolved)",
+            sx->hostname, sx->remote_port);
+      goto CONNECT_REQ_SEND;
+    }
+
     if(!socks5_resolve_local) {
       /* ATYP: domain name = 3,
          IPv6 == 4,
@@ -876,19 +1130,19 @@ CONNECT_RESOLVE_REMOTE:
         char ip6[16];
         if(1 != curlx_inet_pton(AF_INET6, sx->hostname, ip6))
           return CURLPX_BAD_ADDRESS_TYPE;
-        socksreq[len++] = 4;
+        socksreq[len++] = SOCKS5_ATYP_IPV6;
         memcpy(&socksreq[len], ip6, sizeof(ip6));
         len += sizeof(ip6);
       }
       else
 #endif
       if(1 == curlx_inet_pton(AF_INET, sx->hostname, ip4)) {
-        socksreq[len++] = 1;
+        socksreq[len++] = SOCKS5_ATYP_IPV4;
         memcpy(&socksreq[len], ip4, sizeof(ip4));
         len += sizeof(ip4);
       }
       else {
-        socksreq[len++] = 3;
+        socksreq[len++] = SOCKS5_ATYP_DOMAIN;
         socksreq[len++] = (unsigned char) hostname_len; /* one byte length */
         memcpy(&socksreq[len], sx->hostname, hostname_len); /* w/o NULL */
         len += hostname_len;
@@ -900,10 +1154,15 @@ CONNECT_RESOLVE_REMOTE:
 
   case CONNECT_REQ_SEND:
 CONNECT_REQ_SEND:
-    /* PORT MSB */
-    socksreq[len++] = (unsigned char)((sx->remote_port >> 8) & 0xff);
-    /* PORT LSB */
-    socksreq[len++] = (unsigned char)(sx->remote_port & 0xff);
+    {
+      int reqport = sx->udp_associate ? 0 : sx->remote_port;
+      if(sx->udp_associate)
+        infof(data, "SOCKS5 UDP associate request uses port 0 per RFC");
+      /* PORT MSB */
+      socksreq[len++] = (unsigned char)((reqport >> 8) & 0xff);
+      /* PORT LSB */
+      socksreq[len++] = (unsigned char)(reqport & 0xff);
+    }
 
 #if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
     if(conn->socks5_gssapi_enctype) {
@@ -1005,6 +1264,8 @@ CONNECT_REQ_SEND:
       failf(data, "SOCKS5 reply has wrong address type.");
       return CURLPX_BAD_ADDRESS_TYPE;
     }
+    // curl-impersonate: useful for udp only
+    sx->replylen = len;
 
     /* At this point we already read first 10 bytes */
 #if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
@@ -1036,11 +1297,98 @@ CONNECT_REQ_SEND:
     }
     sxstate(sx, data, CONNECT_DONE);
   }
+  if(sx->udp_associate && !sx->udp_relay_family) {
+    presult = socks5_set_udp_relay(sx, data);
+    if(CURLPX_OK != presult)
+      return presult;
+    infof(data, "SOCKS5 UDP associate relay established");
+  }
   infof(data, "SOCKS5 request granted.");
 
   return CURLPX_OK; /* Proxy was successful! */
 }
 
+static void socks_proxy_discard_tcp(struct socks_state *sx,
+                                    struct Curl_easy *data)
+{
+  if(sx && sx->tcp_cf) {
+    sx->tcp_cf->cft->do_close(sx->tcp_cf, data);
+    Curl_conn_cf_discard_chain(&sx->tcp_cf, data);
+  }
+}
+
+static CURLcode socks_proxy_cf_udp_create(struct Curl_cfilter *cf,
+                                          struct socks_state *sx,
+                                          struct Curl_easy *data)
+{
+  struct Curl_cfilter *udp_cf = NULL;
+  struct Curl_cfilter *tcp_cf = sx->tcp_cf ? sx->tcp_cf : cf->next;
+  struct Curl_addrinfo *ai = NULL;
+  CURLcode result;
+  char addrbuf[MAX_IPADR_LEN];
+  /* QUIC needs a connected UDP socket when using UDP ASSOCIATE. */
+  int transport = sx->udp_associate ? TRNSPRT_QUIC : TRNSPRT_UDP;
+  size_t addrlen;
+  bool relay_zero = TRUE;
+
+  if(!sx->udp_relay_family || !sx->udp_relay_port)
+    return CURLE_FAILED_INIT;
+  infof(data, "SOCKS5 UDP associate relay port=%d family=%s",
+        sx->udp_relay_port,
+        (sx->udp_relay_family == AF_INET6) ? "IPv6" : "IPv4");
+  addrlen = (sx->udp_relay_family == AF_INET6) ? 16 : 4;
+  for(size_t i = 0; i < addrlen; ++i) {
+    if(sx->udp_relay_addr[i]) {
+      relay_zero = FALSE;
+      break;
+    }
+  }
+  /* If the relay address is 0.0.0.0/::, reuse the proxy's TCP peer. */
+  if(relay_zero && tcp_cf) {
+    const struct Curl_sockaddr_ex *peer_addr = NULL;
+    if(!Curl_cf_socket_peek(tcp_cf, data, NULL, &peer_addr, NULL) &&
+       peer_addr) {
+      if(peer_addr->family == AF_INET) {
+        struct sockaddr_in *saddr_in =
+          (struct sockaddr_in *)(void *)&peer_addr->curl_sa_addr;
+        memcpy(sx->udp_relay_addr, &saddr_in->sin_addr,
+               sizeof(struct in_addr));
+        sx->udp_relay_family = AF_INET;
+      }
+#ifdef USE_IPV6
+      else if(peer_addr->family == AF_INET6) {
+        struct sockaddr_in6 *saddr_in6 =
+          (struct sockaddr_in6 *)(void *)&peer_addr->curl_sa_addr;
+        memcpy(sx->udp_relay_addr, &saddr_in6->sin6_addr,
+               sizeof(struct in6_addr));
+        sx->udp_relay_family = AF_INET6;
+      }
+#endif
+    }
+    infof(data, "SOCKS5 UDP relay address was zero; using proxy host address");
+  }
+  if(!curlx_inet_ntop(sx->udp_relay_family, sx->udp_relay_addr,
+                      addrbuf, sizeof(addrbuf)))
+    return CURLE_FAILED_INIT;
+
+  ai = Curl_ip2addr(sx->udp_relay_family, sx->udp_relay_addr,
+                    addrbuf, sx->udp_relay_port);
+  if(!ai)
+    return CURLE_OUT_OF_MEMORY;
+
+  result = Curl_cf_udp_create(&udp_cf, data, cf->conn, ai, transport);
+  Curl_freeaddrinfo(ai);
+  if(result)
+    return result;
+
+  udp_cf->conn = cf->conn;
+  udp_cf->sockindex = cf->sockindex;
+  sx->udp_cf = udp_cf;
+  infof(data, "SOCKS5 UDP relay socket prepared for %s:%d",
+        addrbuf, sx->udp_relay_port);
+  return CURLE_OK;
+}
+
 static CURLcode connect_SOCKS(struct Curl_cfilter *cf,
                               struct socks_state *sxstate,
                               struct Curl_easy *data)
@@ -1049,6 +1397,14 @@ static CURLcode connect_SOCKS(struct Curl_cfilter *cf,
   CURLproxycode pxresult = CURLPX_OK;
   struct connectdata *conn = cf->conn;
 
+  if(sxstate->udp_associate &&
+     conn->socks_proxy.proxytype != CURLPROXY_SOCKS5 &&
+     conn->socks_proxy.proxytype != CURLPROXY_SOCKS5_HOSTNAME) {
+    failf(data, "SOCKS: UDP associate only supported with SOCKS5");
+    data->info.pxcode = CURLPX_REPLY_COMMAND_NOT_SUPPORTED;
+    return CURLE_PROXY;
+  }
+
   switch(conn->socks_proxy.proxytype) {
   case CURLPROXY_SOCKS5:
   case CURLPROXY_SOCKS5_HOSTNAME:
@@ -1072,10 +1428,12 @@ static CURLcode connect_SOCKS(struct Curl_cfilter *cf,
   return result;
 }
 
-static void socks_proxy_cf_free(struct Curl_cfilter *cf)
+static void socks_proxy_cf_free(struct Curl_cfilter *cf,
+                                struct Curl_easy *data)
 {
   struct socks_state *sxstate = cf->ctx;
   if(sxstate) {
+    socks_proxy_discard_tcp(sxstate, data);
     free(sxstate);
     cf->ctx = NULL;
   }
@@ -1096,13 +1454,19 @@ static CURLcode socks_proxy_cf_connect(struct Curl_cfilter *cf,
   struct connectdata *conn = cf->conn;
   int sockindex = cf->sockindex;
   struct socks_state *sx = cf->ctx;
+  struct Curl_cfilter *tcp_cf = NULL;
 
   if(cf->connected) {
     *done = TRUE;
     return CURLE_OK;
   }
 
-  result = cf->next->cft->do_connect(cf->next, data, done);
+  if(sx && sx->tcp_cf)
+    tcp_cf = sx->tcp_cf;
+  else
+    tcp_cf = cf->next;
+
+  result = tcp_cf->cft->do_connect(tcp_cf, data, done);
   if(result || !*done)
     return result;
 
@@ -1132,19 +1496,250 @@ static CURLcode socks_proxy_cf_connect(struct Curl_cfilter *cf,
       conn->remote_port;
     sx->proxy_user = conn->socks_proxy.user;
     sx->proxy_password = conn->socks_proxy.passwd;
+    /* Use UDP associate for explicit HTTP/3-only or QUIC transport. */
+    sx->udp_associate =
+      (conn->transport_wanted == TRNSPRT_QUIC) ||
+      (data->state.http_neg.wanted == CURL_HTTP_V3x);
+    if(sx->udp_associate)
+      infof(data, "SOCKS5 UDP associate starting for HTTP/3 target");
   }
 
   result = connect_SOCKS(cf, sx, data);
   if(!result && sx->state == CONNECT_DONE) {
+    if(sx->udp_associate) {
+      if(!sx->udp_cf) {
+        result = socks_proxy_cf_udp_create(cf, sx, data);
+        if(result)
+          return result;
+        /* Keep TCP control channel and switch data path to UDP relay. */
+        sx->tcp_cf = cf->next;
+        cf->next = sx->udp_cf;
+        infof(data, "SOCKS5 UDP associate switching to UDP relay socket");
+      }
+      result = sx->udp_cf->cft->do_connect(sx->udp_cf, data, done);
+      if(result || !*done)
+        return result;
+    }
     cf->connected = TRUE;
     Curl_verboseconnect(data, conn, cf->sockindex);
-    socks_proxy_cf_free(cf);
+    if(!sx->udp_associate)
+      socks_proxy_cf_free(cf, data);
   }
 
   *done = cf->connected;
   return result;
 }
 
+static CURLcode socks_proxy_cf_send(struct Curl_cfilter *cf,
+                                    struct Curl_easy *data,
+                                    const void *buf, size_t len, bool eos,
+                                    size_t *pnwritten)
+{
+  struct socks_state *sx = cf->ctx;
+
+  if(sx && sx->udp_associate && sx->udp_cf) {
+    /* Wrap outgoing QUIC datagrams in SOCKS5 UDP headers. */
+    size_t header_len;
+    size_t addrlen;
+    size_t nwritten = 0;
+    unsigned char atyp;
+    unsigned char *packet;
+    CURLcode result;
+
+    *pnwritten = 0;
+    if(!sx->udp_dest_set)
+      return CURLE_SEND_ERROR;
+
+    switch(sx->udp_dest_atyp) {
+    case SOCKS5_ATYP_IPV6:
+      addrlen = SOCKS5_IPV6_ADDR_LEN;
+      atyp = SOCKS5_ATYP_IPV6;
+      break;
+    case SOCKS5_ATYP_DOMAIN:
+      if(!sx->udp_dest_domain_len)
+        return CURLE_SEND_ERROR;
+      addrlen = 1 + sx->udp_dest_domain_len;
+      atyp = SOCKS5_ATYP_DOMAIN;
+      break;
+    case SOCKS5_ATYP_IPV4:
+    default:
+      addrlen = SOCKS5_IPV4_ADDR_LEN;
+      atyp = SOCKS5_ATYP_IPV4;
+      break;
+    }
+
+    header_len = SOCKS5_REPLY_HEADER_LEN + addrlen + SOCKS5_PORT_LEN;
+    packet = malloc(header_len + len);
+    if(!packet)
+      return CURLE_OUT_OF_MEMORY;
+
+    packet[0] = 0;
+    packet[1] = 0;
+    packet[2] = 0;
+    packet[SOCKS5_REPLY_HEADER_LEN - 1] = atyp;
+    if(atyp == SOCKS5_ATYP_DOMAIN) {
+      packet[SOCKS5_REPLY_HEADER_LEN] =
+        (unsigned char)sx->udp_dest_domain_len;
+      memcpy(&packet[SOCKS5_REPLY_HEADER_LEN + 1], sx->udp_dest_domain,
+             sx->udp_dest_domain_len);
+    }
+    else
+      memcpy(&packet[SOCKS5_REPLY_HEADER_LEN], sx->udp_dest_addr, addrlen);
+    packet[SOCKS5_REPLY_HEADER_LEN + addrlen] =
+      (unsigned char)((sx->udp_dest_port >> 8) & 0xff);
+    packet[SOCKS5_REPLY_HEADER_LEN + addrlen + 1] =
+      (unsigned char)(sx->udp_dest_port & 0xff);
+    memcpy(&packet[header_len], buf, len);
+
+    infof(data, "SOCKS5 UDP send: payload=%zu header=%zu atyp=%d",
+          len, header_len, atyp);
+    if(atyp == SOCKS5_ATYP_DOMAIN) {
+      infof(data, "SOCKS5 UDP header: domain_len=%zu domain=%.*s port=%d",
+            sx->udp_dest_domain_len,
+            (int)sx->udp_dest_domain_len, sx->udp_dest_domain,
+            sx->udp_dest_port);
+    }
+    result = cf->next->cft->do_send(cf->next, data, packet,
+                                    header_len + len, eos, &nwritten);
+    free(packet);
+    if(result) {
+      if(result == CURLE_AGAIN)
+        *pnwritten = 0;
+      return result;
+    }
+
+    if(nwritten != (header_len + len))
+      return CURLE_SEND_ERROR;
+
+    *pnwritten = len;
+    return CURLE_OK;
+  }
+
+  return Curl_cf_def_send(cf, data, buf, len, eos, pnwritten);
+}
+
+static CURLcode socks_proxy_cf_recv(struct Curl_cfilter *cf,
+                                    struct Curl_easy *data,
+                                    char *buf, size_t len, size_t *pnread)
+{
+  struct socks_state *sx = cf->ctx;
+
+  if(sx && sx->udp_associate && sx->udp_cf) {
+    /* Strip SOCKS5 UDP headers before passing QUIC payload upward. */
+    size_t maxhdr =
+      SOCKS5_REPLY_HEADER_LEN + 1 + 255 + SOCKS5_PORT_LEN;
+    size_t pktlen = len + maxhdr;
+    unsigned char *packet = malloc(pktlen);
+    size_t nread = 0;
+    CURLcode result;
+
+    *pnread = 0;
+    if(!packet)
+      return CURLE_OUT_OF_MEMORY;
+
+    result = cf->next->cft->do_recv(cf->next, data, (char *)packet,
+                                    pktlen, &nread);
+    if(result) {
+      free(packet);
+      return result;
+    }
+
+    if(nread < SOCKS5_REPLY_HEADER_LEN) {
+      free(packet);
+      return CURLE_RECV_ERROR;
+    }
+    if(packet[0] || packet[1] || packet[2]) {
+      free(packet);
+      return CURLE_RECV_ERROR;
+    }
+    {
+      size_t addrlen;
+      size_t off = SOCKS5_REPLY_HEADER_LEN;
+      switch(packet[SOCKS5_REPLY_HEADER_LEN - 1]) {
+      case SOCKS5_ATYP_IPV4:
+        addrlen = SOCKS5_IPV4_ADDR_LEN;
+        break;
+      case SOCKS5_ATYP_IPV6:
+        addrlen = SOCKS5_IPV6_ADDR_LEN;
+        break;
+      case SOCKS5_ATYP_DOMAIN:
+        if(nread < (SOCKS5_REPLY_HEADER_LEN + 1)) {
+          free(packet);
+          return CURLE_RECV_ERROR;
+        }
+        addrlen = 1 + packet[SOCKS5_REPLY_HEADER_LEN];
+        break;
+      default:
+        free(packet);
+        return CURLE_RECV_ERROR;
+      }
+    if(nread < off + addrlen + SOCKS5_PORT_LEN) {
+      free(packet);
+      return CURLE_RECV_ERROR;
+    }
+    /* For socks5h:// with domain names (udp_dest_atyp == SOCKS5_ATYP_DOMAIN),
+     * do NOT set udp_peer_set from received packets. This ensures that
+     * CF_QUERY_REMOTE_ADDR consistently returns the relay address throughout
+     * the connection. The relay address is what QUIC should use as the "peer"
+     * since that's what we're actually communicating with on the network.
+     * TLS verification uses the hostname (not IP) for SNI/certificate checks.
+     * For socks5:// (local DNS) or IP literals, udp_peer_set is already TRUE
+     * from initialization, so we can update udp_peer_addr here. */
+    if((packet[SOCKS5_REPLY_HEADER_LEN - 1] == SOCKS5_ATYP_IPV4 ||
+        packet[SOCKS5_REPLY_HEADER_LEN - 1] == SOCKS5_ATYP_IPV6) &&
+       sx->udp_dest_atyp != SOCKS5_ATYP_DOMAIN) {
+      const unsigned char *addrbytes = &packet[SOCKS5_REPLY_HEADER_LEN];
+      int port = (int)((packet[SOCKS5_REPLY_HEADER_LEN + addrlen] << 8) |
+                       packet[SOCKS5_REPLY_HEADER_LEN + addrlen +
+                              (SOCKS5_PORT_LEN - 1)]);
+      memset(&sx->udp_peer_addr, 0, sizeof(sx->udp_peer_addr));
+      if(packet[SOCKS5_REPLY_HEADER_LEN - 1] == SOCKS5_ATYP_IPV4) {
+        struct sockaddr_in *sa =
+          (struct sockaddr_in *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+        sa->sin_family = AF_INET;
+        memcpy(&sa->sin_addr, addrbytes, sizeof(struct in_addr));
+        sa->sin_port = htons((unsigned short)port);
+        sx->udp_peer_addr.family = AF_INET;
+        sx->udp_peer_addr.socktype = SOCK_DGRAM;
+        sx->udp_peer_addr.protocol = IPPROTO_UDP;
+        sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in);
+        sx->udp_peer_set = TRUE;
+      }
+#ifdef USE_IPV6
+      else {
+        struct sockaddr_in6 *sa6 =
+          (struct sockaddr_in6 *)(void *)&sx->udp_peer_addr.curl_sa_addr;
+        sa6->sin6_family = AF_INET6;
+        memcpy(&sa6->sin6_addr, addrbytes, sizeof(struct in6_addr));
+        sa6->sin6_port = htons((unsigned short)port);
+        sx->udp_peer_addr.family = AF_INET6;
+        sx->udp_peer_addr.socktype = SOCK_DGRAM;
+        sx->udp_peer_addr.protocol = IPPROTO_UDP;
+        sx->udp_peer_addr.addrlen = sizeof(struct sockaddr_in6);
+        sx->udp_peer_set = TRUE;
+      }
+#endif
+    }
+    off += addrlen + SOCKS5_PORT_LEN;
+      if(nread > off) {
+        size_t payload = nread - off;
+        if(payload > len)
+          payload = len;
+        memcpy(buf, &packet[off], payload);
+        *pnread = payload;
+        infof(data, "SOCKS5 UDP recv: payload=%zu header=%zu",
+              payload, off);
+      }
+      else
+        *pnread = 0;
+    }
+    free(packet);
+    return CURLE_OK;
+  }
+
+  return Curl_cf_def_recv(cf, data, buf, len, pnread);
+}
+
 static void socks_cf_adjust_pollset(struct Curl_cfilter *cf,
                                     struct Curl_easy *data,
                                     struct easy_pollset *ps)
@@ -1176,15 +1771,14 @@ static void socks_proxy_cf_close(struct Curl_cfilter *cf,
 
   DEBUGASSERT(cf->next);
   cf->connected = FALSE;
-  socks_proxy_cf_free(cf);
+  socks_proxy_cf_free(cf, data);
   cf->next->cft->do_close(cf->next, data);
 }
 
 static void socks_proxy_cf_destroy(struct Curl_cfilter *cf,
                                    struct Curl_easy *data)
 {
-  (void)data;
-  socks_proxy_cf_free(cf);
+  socks_proxy_cf_free(cf, data);
 }
 
 static CURLcode socks_cf_query(struct Curl_cfilter *cf,
@@ -1195,6 +1789,12 @@ static CURLcode socks_cf_query(struct Curl_cfilter *cf,
 
   if(sx) {
     switch(query) {
+    case CF_QUERY_REMOTE_ADDR:
+      if(sx->udp_associate && sx->udp_peer_set) {
+        *((const struct Curl_sockaddr_ex **)pres2) = &sx->udp_peer_addr;
+        return CURLE_OK;
+      }
+      break;
     case CF_QUERY_HOST_PORT:
       *pres1 = sx->remote_port;
       *((const char **)pres2) = sx->hostname;
@@ -1218,14 +1818,25 @@ struct Curl_cftype Curl_cft_socks_proxy = {
   Curl_cf_def_shutdown,
   socks_cf_adjust_pollset,
   Curl_cf_def_data_pending,
-  Curl_cf_def_send,
-  Curl_cf_def_recv,
+  socks_proxy_cf_send,
+  socks_proxy_cf_recv,
   Curl_cf_def_cntrl,
   Curl_cf_def_conn_is_alive,
   Curl_cf_def_conn_keep_alive,
   socks_cf_query,
 };
 
+bool Curl_cf_socks_proxy_is_udp_associate(struct Curl_cfilter *cf)
+{
+  for(; cf; cf = cf->next) {
+    if(cf->cft == &Curl_cft_socks_proxy) {
+      struct socks_state *sx = cf->ctx;
+      return sx && sx->udp_associate;
+    }
+  }
+  return FALSE;
+}
+
 CURLcode Curl_cf_socks_proxy_insert_after(struct Curl_cfilter *cf_at,
                                           struct Curl_easy *data)
 {
diff --git a/lib/socks.h b/lib/socks.h
index d60796316f..648a193e21 100644
--- a/lib/socks.h
+++ b/lib/socks.h
@@ -30,7 +30,9 @@
 #define Curl_SOCKS4(a,b,c,d,e) CURLE_NOT_BUILT_IN
 #define Curl_SOCKS5(a,b,c,d,e,f) CURLE_NOT_BUILT_IN
 #define Curl_SOCKS_getsock(x,y,z) 0
+#define Curl_cf_socks_proxy_is_udp_associate(x) FALSE
 #else
+struct Curl_cfilter;
 /*
  * Helper read-from-socket functions. Does the same as Curl_read() but it
  * blocks until all bytes amount of buffersize will be read. No more, no less.
@@ -54,6 +56,9 @@ CURLcode Curl_SOCKS5_gssapi_negotiate(struct Curl_cfilter *cf,
 CURLcode Curl_cf_socks_proxy_insert_after(struct Curl_cfilter *cf_at,
                                           struct Curl_easy *data);
 
+/* Query if a SOCKS filter in the chain is using UDP ASSOCIATE. */
+bool Curl_cf_socks_proxy_is_udp_associate(struct Curl_cfilter *cf);
+
 extern struct Curl_cftype Curl_cft_socks_proxy;
 
 #endif /* CURL_DISABLE_PROXY */
diff --git a/lib/transfer.c b/lib/transfer.c
index 15a61f6997..df4c721a1c 100644
--- a/lib/transfer.c
+++ b/lib/transfer.c
@@ -104,7 +104,15 @@ char *Curl_checkheaders(const struct Curl_easy *data,
   DEBUGASSERT(thislen);
   DEBUGASSERT(thisheader[thislen-1] != ':');
 
-  for(head = data->set.headers; head; head = head->next) {
+  /*
+   * curl-impersonate:
+   * Check if we have overriden the user-supplied list of headers.
+   */
+  head = data->set.headers;
+  if (data->state.merged_headers)
+    head = data->state.merged_headers;
+
+  for(; head; head = head->next) {
     if(curl_strnequal(head->data, thisheader, thislen) &&
        Curl_headersep(head->data[thislen]) )
       return head->data;
diff --git a/lib/url.c b/lib/url.c
index e4f250f54a..8ab233a130 100644
--- a/lib/url.c
+++ b/lib/url.c
@@ -333,6 +333,10 @@ CURLcode Curl_close(struct Curl_easy **datap)
   Curl_safefree(data->state.aptr.proxyuser);
   Curl_safefree(data->state.aptr.proxypasswd);
 #endif
+  /* curl-impersonate: Free the list set by CURLOPT_HTTPBASEHEADER. */
+  curl_slist_free_all(data->state.base_headers);
+  /* curl-impersonate: Free the dynamic list of headers. */
+  curl_slist_free_all(data->state.merged_headers);
 
 #if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_FORM_API)
   Curl_mime_cleanpart(data->state.formp);
@@ -468,8 +472,14 @@ CURLcode Curl_init_userdefined(struct Curl_easy *data)
   set->tcp_fastopen = FALSE;
   set->tcp_nodelay = TRUE;
   set->ssl_enable_alpn = TRUE;
+  set->ssl_enable_ticket = TRUE;
+  set->tls_grease = FALSE;
+  set->tls_use_new_alps_codepoint = FALSE;
   set->expect_100_timeout = 1000L; /* Wait for a second by default. */
   set->sep_headers = TRUE; /* separated header lists by default */
+#ifndef CURL_DISABLE_COOKIES
+  set->split_cookies = FALSE; /* use a single Cookie header by default */
+#endif
   set->buffer_size = READBUFFER_SIZE;
   set->upload_buffer_size = UPLOADBUFFER_DEFAULT;
   set->happy_eyeballs_timeout = CURL_HET_DEFAULT;
@@ -648,6 +658,17 @@ proxy_info_matches(const struct proxy_info *data,
 
   return FALSE;
 }
+/* curl-impersonate: redefine function in case main curl function is modified in upcoming releases */
+static bool proxy_credential_matches(const struct proxy_info *data,
+                                     const struct proxy_info *needle)
+{
+  if(Curl_timestrcmp(data->user, needle->user) ||
+     Curl_timestrcmp(data->passwd, needle->passwd)) {
+      return FALSE;
+  }
+
+  return TRUE;
+}
 
 static bool
 socks_proxy_info_matches(const struct proxy_info *data,
@@ -994,6 +1015,15 @@ static bool url_match_proxy_use(struct connectdata *conn,
     if(!proxy_info_matches(&m->needle->http_proxy, &conn->http_proxy))
       return FALSE;
 
+    if(m->data->set.proxy_credential_no_reuse &&
+       !proxy_credential_matches(&m->needle->http_proxy, &conn->http_proxy)) {
+      DEBUGF(infof(m->data,
+                   "Connection #%" FMT_OFF_T
+                   " has different proxy credentials, cannot reuse",
+                   conn->connection_id));
+      return FALSE;
+    }
+
     if(IS_HTTPS_PROXY(m->needle->http_proxy.proxytype)) {
       /* https proxies come in different types, http/1.1, h2, ... */
       if(m->needle->http_proxy.proxytype != conn->http_proxy.proxytype)
@@ -1456,6 +1486,7 @@ static struct connectdata *allocate_conn(struct Curl_easy *data)
 
   conn->bits.proxy_user_passwd = !!data->state.aptr.proxyuser;
   conn->bits.tunnel_proxy = data->set.tunnel_thru_httpproxy;
+  conn->bits.proxy_credential_no_reuse = data->set.proxy_credential_no_reuse;
 #endif /* CURL_DISABLE_PROXY */
 
 #ifndef CURL_DISABLE_FTP
@@ -3741,6 +3772,11 @@ static CURLcode create_conn(struct Curl_easy *data,
          (default) */
       if(data->set.ssl_enable_alpn)
         conn->bits.tls_enable_alpn = TRUE;
+
+      /* curl-impersonate: Turn on ALPS if ALPN is enabled and the bit is
+       * enabled. */
+      if(data->set.ssl_enable_alps)
+        conn->bits.tls_enable_alps = TRUE;
     }
 
     if(waitpipe) {
diff --git a/lib/urldata.h b/lib/urldata.h
index e54721dd98..7d67d60585 100644
--- a/lib/urldata.h
+++ b/lib/urldata.h
@@ -275,6 +275,8 @@ struct ssl_primary_config {
   char *password; /* TLS password (for, e.g., SRP) */
 #endif
   char *curves;          /* list of curves to use */
+  char *sig_hash_algs;   /* List of signature hash algorithms to use */
+  char *cert_compression;  /* List of certificate compression algorithms. */
   unsigned int version_max; /* max supported version the client wants to use */
   unsigned char ssl_options;  /* the CURLOPT_SSL_OPTIONS bitmask */
   unsigned char version;    /* what version the client wants to use */
@@ -375,6 +377,7 @@ struct ConnectBits {
                          proxies, but can also be enabled explicitly by
                          apps */
   BIT(proxy); /* if set, this transfer is done through a proxy - any type */
+  BIT(proxy_credential_no_reuse); /* no reuse of SSL sessions/connections via different proxy credentials */
 #endif
   /* always modify bits.close with the connclose() and connkeep() macros! */
   BIT(close); /* if set, we close the connection after this request */
@@ -412,6 +415,11 @@ struct ConnectBits {
   BIT(multiplex); /* connection is multiplexed */
   BIT(tcp_fastopen); /* use TCP Fast Open */
   BIT(tls_enable_alpn); /* TLS ALPN extension? */
+  BIT(tls_enable_alps); /* TLS ALPS extension? */
+  BIT(tls_enable_ticket); /* TLS session ticket extension? */
+  BIT(tls_permute_extensions); /* TLS extension permutations */
+  BIT(tls_use_new_alps_codepoint); /* TLS ALPS new codepoint */
+  BIT(tls_grease);  /* TLS grease? */
 #ifndef CURL_DISABLE_DOH
   BIT(doh);
 #endif
@@ -1119,6 +1127,19 @@ struct UrlState {
                                     curl_easy_setopt(COOKIEFILE) calls */
 #endif
 
+  /*
+   * curl-impersonate:
+   * List of "base" headers set by CURLOPT_HTTPBASEHEADER.
+   */
+  struct curl_slist *base_headers;
+  /*
+   * curl-impersonate:
+   * Dynamically-constructed list of HTTP headers.
+   * This list is a merge of the default HTTP headers needed to impersonate a
+   * browser, together with any user-supplied headers.
+   */
+  struct curl_slist *merged_headers;
+
 #ifndef CURL_DISABLE_VERBOSE_STRINGS
   struct curl_trc_feat *feat; /* opt. trace feature transfer is part of */
 #endif
@@ -1225,6 +1246,8 @@ enum dupstring {
   STRING_SSL_CRLFILE,     /* crl file to check certificate */
   STRING_SSL_ISSUERCERT, /* issuer cert file to check certificate */
   STRING_SERVICE_NAME,    /* Service name */
+  STRING_IMPERSONATE,     /* curl-impersonate */
+  STRING_FORM_BOUNDARY,   /* CURLOPT_FORM_BOUNDARY */
 #ifndef CURL_DISABLE_PROXY
   STRING_CERT_PROXY,      /* client certificate filename */
   STRING_CERT_TYPE_PROXY, /* format for certificate (default: PEM)*/
@@ -1334,6 +1357,16 @@ enum dupstring {
 #endif
   STRING_ECH_CONFIG,            /* CURLOPT_ECH_CONFIG */
   STRING_ECH_PUBLIC,            /* CURLOPT_ECH_PUBLIC */
+  STRING_SSL_SIG_HASH_ALGS,
+  STRING_SSL_CERT_COMPRESSION,
+  STRING_HTTP2_PSEUDO_HEADERS_ORDER,
+  STRING_HTTP2_SETTINGS,
+  STRING_HTTP2_STREAMS,
+  STRING_HTTP3_PSEUDO_HEADERS_ORDER,
+  STRING_HTTP3_SETTINGS,
+  STRING_QUIC_TRANSPORT_PARAMETERS,
+  STRING_TLS_EXTENSION_ORDER,
+  STRING_TLS_DELEGATED_CREDENTIALS,
   STRING_SSL_SIGNATURE_ALGORITHMS, /* CURLOPT_SSL_SIGNATURE_ALGORITHMS */
 
   /* -- end of null-terminated strings -- */
@@ -1579,6 +1612,7 @@ struct UserDefined {
   BIT(sep_headers);     /* handle host and proxy headers separately */
 #ifndef CURL_DISABLE_COOKIES
   BIT(cookiesession);   /* new cookie session? */
+  BIT(split_cookies);   /* split cookies into one Cookie header per pair */
 #endif
   BIT(crlf);            /* convert crlf on ftp upload(?) */
 #ifdef USE_SSH
@@ -1595,6 +1629,7 @@ struct UserDefined {
   BIT(get_filetime);     /* get the time and get of the remote file */
 #ifndef CURL_DISABLE_PROXY
   BIT(tunnel_thru_httpproxy); /* use CONNECT through an HTTP proxy */
+  BIT(proxy_credential_no_reuse); /* no reuse of SSL sessions/connections via different proxy credentials */
 #endif
   BIT(prefer_ascii);     /* ASCII rather than binary */
   BIT(remote_append);    /* append, not overwrite, on upload */
@@ -1641,6 +1676,14 @@ struct UserDefined {
   BIT(tcp_keepalive);  /* use TCP keepalives */
   BIT(tcp_fastopen);   /* use TCP Fast Open */
   BIT(ssl_enable_alpn);/* TLS ALPN extension? */
+  BIT(ssl_enable_alps);/* TLS ALPS extension? */
+  BIT(ssl_enable_ticket); /* TLS session ticket extension */
+  BIT(ssl_permute_extensions); /* TLS Permute extensions */
+  BIT(tls_grease);  /* TLS grease? */
+  BIT(tls_key_usage_no_check);  /* TLS key_usage_check? */
+  BIT(tls_signed_cert_timestamps);  /* TLS signed cert timestamps? */
+  BIT(tls_status_request);  /* TLS status request */
+  BIT(tls_use_new_alps_codepoint); /* TLS use new alps codepoint */
   BIT(path_as_is);     /* allow dotdots? */
   BIT(pipewait);       /* wait for multiplex status before starting a new
                           connection */
@@ -1662,10 +1705,15 @@ struct UserDefined {
   BIT(doh_verifystatus);   /* DoH certificate status verification */
 #endif
   BIT(http09_allowed); /* allow HTTP/0.9 responses */
+// BIT(grease);           /* grease enabled? */
 #ifndef CURL_DISABLE_WEBSOCKETS
   BIT(ws_raw_mode);
   BIT(ws_no_auto_pong);
 #endif
+  int http2_window_update;
+  int tls_record_size_limit;
+  int tls_key_shares_limit;
+  BIT(http2_no_priority);
 };
 
 #ifndef CURL_DISABLE_MIME
diff --git a/lib/vquic/curl_ngtcp2.c b/lib/vquic/curl_ngtcp2.c
index 69d54ecce2..5ff86c4a0c 100644
--- a/lib/vquic/curl_ngtcp2.c
+++ b/lib/vquic/curl_ngtcp2.c
@@ -56,8 +56,10 @@
 #include "../cfilters.h"
 #include "../cf-socket.h"
 #include "../connect.h"
+#include "../socks.h"
 #include "../progress.h"
 #include "../strerror.h"
+#include "../strcase.h"
 #include "../curlx/dynbuf.h"
 #include "../http1.h"
 #include "../select.h"
@@ -88,6 +90,43 @@
  * when we take things out of the buffer.
  * Chunk size is large enough to take a full DATA frame */
 #define H3_STREAM_WINDOW_SIZE (128 * 1024)
+
+static const struct alpn_spec ALPN_SPEC_H3 = {
+  { "h3" }, 1
+};
+
+/* Walk the filter chain to find the active socket for QUIC logging. */
+static CURLcode cf_ngtcp2_peek_socket(struct Curl_cfilter *cf,
+                                      struct Curl_easy *data,
+                                      curl_socket_t *psock,
+                                      const struct Curl_sockaddr_ex **paddr,
+                                      struct ip_quadruple *pip)
+{
+  bool got_sock = FALSE;
+  bool got_addr = FALSE;
+  bool got_ip = FALSE;
+  int dummy = 0;
+
+  for(; cf; cf = cf->next) {
+    if(!got_sock && (psock || pip)) {
+      if(!Curl_cf_socket_peek(cf, data, psock, NULL, pip)) {
+        got_sock = (psock != NULL);
+        got_ip = (pip != NULL);
+      }
+    }
+    if(paddr && !got_addr) {
+      const struct Curl_sockaddr_ex *addr = NULL;
+      if(!cf->cft->query(cf, data, CF_QUERY_REMOTE_ADDR, &dummy, &addr) &&
+         addr) {
+        *paddr = addr;
+        got_addr = TRUE;
+      }
+    }
+    if((!psock || got_sock) && (!paddr || got_addr) && (!pip || got_ip))
+      return CURLE_OK;
+  }
+  return CURLE_FAILED_INIT;
+}
 #define H3_STREAM_CHUNK_SIZE   (16 * 1024)
 #if H3_STREAM_CHUNK_SIZE < NGTCP2_MAX_UDP_PAYLOAD_SIZE
 #error H3_STREAM_CHUNK_SIZE smaller than NGTCP2_MAX_UDP_PAYLOAD_SIZE
@@ -142,6 +181,7 @@ struct cf_ngtcp2_ctx {
   struct curltime handshake_at;      /* time connect handshake finished */
   struct bufc_pool stream_bufcp;     /* chunk pool for streams */
   struct dynbuf scratch;             /* temp buffer for header construction */
+  struct dynbuf tp_raw;              /* serialized local QUIC TP bytes */
   struct uint_hash streams;          /* hash `data->mid` to `h3_stream_ctx` */
   size_t max_stream_window;          /* max flow window for one stream */
   uint64_t used_bidi_streams;        /* bidi streams we have opened */
@@ -175,6 +215,7 @@ static void cf_ngtcp2_ctx_init(struct cf_ngtcp2_ctx *ctx)
   Curl_bufcp_init(&ctx->stream_bufcp, H3_STREAM_CHUNK_SIZE,
                   H3_STREAM_POOL_SPARES);
   curlx_dyn_init(&ctx->scratch, CURL_MAX_HTTP_HEADER);
+  curlx_dyn_init(&ctx->tp_raw, CURL_MAX_INPUT_LENGTH);
   Curl_uint_hash_init(&ctx->streams, 63, h3_stream_hash_free);
   ctx->initialized = TRUE;
 }
@@ -186,6 +227,7 @@ static void cf_ngtcp2_ctx_free(struct cf_ngtcp2_ctx *ctx)
     vquic_ctx_free(&ctx->q);
     Curl_bufcp_free(&ctx->stream_bufcp);
     curlx_dyn_free(&ctx->scratch);
+    curlx_dyn_free(&ctx->tp_raw);
     Curl_uint_hash_destroy(&ctx->streams);
     Curl_ssl_peer_cleanup(&ctx->peer);
   }
@@ -416,12 +458,19 @@ static void qlog_callback(void *user_data, uint32_t flags,
 
 }
 
-static void quic_settings(struct cf_ngtcp2_ctx *ctx,
-                          struct Curl_easy *data,
-                          struct pkt_io_ctx *pktx)
+static CURLcode quic_transport_params_from_string(ngtcp2_transport_params *t,
+                                                  struct dynbuf *raw,
+                                                  const ngtcp2_cid *scid,
+                                                  struct Curl_easy *data);
+static bool quic_has_empty_initial_scid(const char *params);
+
+static CURLcode quic_settings(struct cf_ngtcp2_ctx *ctx,
+                              struct Curl_easy *data,
+                              struct pkt_io_ctx *pktx)
 {
   ngtcp2_settings *s = &ctx->settings;
   ngtcp2_transport_params *t = &ctx->transport_params;
+  CURLcode result;
 
   ngtcp2_settings_default(s);
   ngtcp2_transport_params_default(t);
@@ -431,7 +480,6 @@ static void quic_settings(struct cf_ngtcp2_ctx *ctx,
   s->log_printf = NULL;
 #endif
 
-  (void)data;
   s->initial_ts = pktx->ts;
   s->handshake_timeout = QUIC_HANDSHAKE_TIMEOUT;
   s->max_window = 100 * ctx->max_stream_window;
@@ -447,6 +495,822 @@ static void quic_settings(struct cf_ngtcp2_ctx *ctx,
   if(ctx->qlogfd != -1) {
     s->qlog_write = qlog_callback;
   }
+  curlx_dyn_reset(&ctx->tp_raw);
+  result = quic_transport_params_from_string(t, &ctx->tp_raw, &ctx->scid,
+                                             data);
+  if(result)
+    return result;
+
+  return CURLE_OK;
+}
+
+static bool quic_has_empty_initial_scid(const char *params)
+{
+  const char *p = params;
+
+  if(!p || !*p)
+    return FALSE;
+
+  while(*p) {
+    const char *end;
+    size_t len;
+
+    while(*p == ';')
+      ++p;
+    if(!*p)
+      break;
+
+    end = strchr(p, ';');
+    len = end ? (size_t)(end - p) : strlen(p);
+    if((len == 3) && (p[0] == '1') && (p[1] == '5') && (p[2] == ':'))
+      return TRUE;
+
+    p = end ? (end + 1) : (p + len);
+  }
+
+  return FALSE;
+}
+
+// https://www.iana.org/assignments/quic/quic.xhtml
+static CURLcode quic_apply_transport_param(ngtcp2_transport_params *t,
+                                           uint64_t id,
+                                           uint64_t value,
+                                           bool has_value,
+                                           struct Curl_easy *data)
+{
+  switch(id) {
+  case 0x00: /* original_destination_connection_id (server only) */
+  case 0x02: /* stateless_reset_token (server only) */
+  case 0x0d: /* preferred_address (server only) */
+  case 0x10: /* retry_source_connection_id (server only) */
+  case 0x11: /* version_information (server only) */
+    failf(data, "QUIC transport param %" FMT_PRIu64 " is server-only",
+          (curl_uint64_t)id);
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+  case 0x0f: /* initial_source_connection_id (set by library) */
+    failf(data, "QUIC transport param %" FMT_PRIu64
+          " is managed by the library", (curl_uint64_t)id);
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+  case 0x01: /* max_idle_timeout (milliseconds) */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->max_idle_timeout = (ngtcp2_duration)value * NGTCP2_MILLISECONDS;
+    break;
+  case 0x03: /* max_udp_payload_size */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->max_udp_payload_size = value;
+    break;
+  case 0x04: /* initial_max_data */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->initial_max_data = value;
+    break;
+  case 0x05: /* initial_max_stream_data_bidi_local */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->initial_max_stream_data_bidi_local = value;
+    break;
+  case 0x06: /* initial_max_stream_data_bidi_remote */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->initial_max_stream_data_bidi_remote = value;
+    break;
+  case 0x07: /* initial_max_stream_data_uni */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->initial_max_stream_data_uni = value;
+    break;
+  case 0x08: /* initial_max_streams_bidi */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->initial_max_streams_bidi = value;
+    break;
+  case 0x09: /* initial_max_streams_uni */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->initial_max_streams_uni = value;
+    break;
+  case 0x0a: /* ack_delay_exponent */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->ack_delay_exponent = value;
+    break;
+  case 0x0b: /* max_ack_delay (milliseconds) */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->max_ack_delay = (ngtcp2_duration)value * NGTCP2_MILLISECONDS;
+    break;
+  case 0x0c: /* disable_active_migration */
+    t->disable_active_migration = (uint8_t)(!has_value || value);
+    break;
+  case 0x0e: /* active_connection_id_limit */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->active_connection_id_limit = value;
+    break;
+  case 0x20: /* max_datagram_frame_size */
+    if(!has_value)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    t->max_datagram_frame_size = value;
+    break;
+  case 0x2ab2: /* grease_quic_bit */
+    t->grease_quic_bit = (uint8_t)(!has_value || value);
+    break;
+  default:
+    infof(data, "QUIC transport param %" FMT_PRIu64
+          " is not mapped to ngtcp2_transport_params",
+          (curl_uint64_t)id);
+    break;
+  }
+
+  return CURLE_OK;
+}
+
+#define QUIC_VARINT_MAX UINT64_C(0x3fffffffffffffff)
+#define QUIC_TP_INITIAL_SOURCE_CONNECTION_ID UINT64_C(0x0f)
+#define QUIC_TP_VERSION_INFORMATION          UINT64_C(0x11)
+#define QUIC_TP_INITIAL_RTT                  UINT64_C(0x3127)
+#define QUIC_TP_GOOGLE_VERSION               UINT64_C(0x4752)
+#define QUIC_TP_GREASE_ID_BASE              UINT64_C(27)
+#define QUIC_TP_GREASE_ID_STEP              UINT64_C(31)
+#define QUIC_TP_GREASE_VALUE_MAXLEN         8
+#define QUIC_INITIAL_RTT_US_BASE             UINT64_C(333000)
+#define QUIC_INITIAL_RTT_US_JITTER           UINT64_C(50000)
+
+static uint64_t quic_initial_rtt_auto_us(struct Curl_easy *data)
+{
+  /* Use RFC9002 default initial RTT with moderate jitter for
+   * fingerprinting. */
+  uint64_t value = QUIC_INITIAL_RTT_US_BASE;
+  unsigned char rnd[2];
+  uint64_t span;
+  uint64_t off;
+
+  if(Curl_rand(data, rnd, sizeof(rnd)))
+    return value;
+
+  span = (QUIC_INITIAL_RTT_US_JITTER * 2) + 1;
+  off = ((((uint64_t)rnd[0]) << 8) | rnd[1]) % span;
+  value = (QUIC_INITIAL_RTT_US_BASE - QUIC_INITIAL_RTT_US_JITTER) + off;
+  return value;
+}
+
+static uint32_t quic_version_grease(struct Curl_easy *data)
+{
+  unsigned char rnd[4];
+  uint32_t v = 0x0a0a0a0aU;
+
+  if(Curl_rand(data, rnd, sizeof(rnd)))
+    return v;
+
+  v = (uint32_t)(((rnd[0] & 0xf0U) | 0x0aU) << 24);
+  v |= (uint32_t)(((rnd[1] & 0xf0U) | 0x0aU) << 16);
+  v |= (uint32_t)(((rnd[2] & 0xf0U) | 0x0aU) << 8);
+  v |= (uint32_t)((rnd[3] & 0xf0U) | 0x0aU);
+  return v;
+}
+
+static CURLcode quic_rand_u64(struct Curl_easy *data, uint64_t *val)
+{
+  unsigned char rnd[sizeof(uint64_t)];
+  CURLcode result;
+  size_t i;
+
+  result = Curl_rand(data, rnd, sizeof(rnd));
+  if(result)
+    return result;
+
+  *val = 0;
+  for(i = 0; i < sizeof(rnd); ++i)
+    *val = (*val << 8) | rnd[i];
+
+  return CURLE_OK;
+}
+
+static CURLcode quic_generate_grease_tp(struct Curl_easy *data,
+                                        uint64_t *pid,
+                                        unsigned char *value,
+                                        size_t *vlen)
+{
+  uint64_t n;
+  uint64_t max_n = (QUIC_VARINT_MAX - QUIC_TP_GREASE_ID_BASE) /
+                   QUIC_TP_GREASE_ID_STEP;
+  unsigned char lenrnd;
+  CURLcode result;
+
+  result = quic_rand_u64(data, &n);
+  if(result)
+    return result;
+
+  *pid = (QUIC_TP_GREASE_ID_STEP * (n % (max_n + 1))) +
+         QUIC_TP_GREASE_ID_BASE;
+
+  result = Curl_rand(data, &lenrnd, sizeof(lenrnd));
+  if(result)
+    return result;
+
+  *vlen = (size_t)(lenrnd % QUIC_TP_GREASE_VALUE_MAXLEN) + 1;
+  return Curl_rand(data, value, *vlen);
+}
+
+static CURLcode quic_permute_token_order(char **tokens, size_t ntokens,
+                                         struct Curl_easy *data)
+{
+  size_t i;
+
+  DEBUGASSERT(ntokens > 1);
+  for(i = ntokens - 1; i > 0; --i) {
+    uint64_t r;
+    size_t j;
+    char *tmp;
+    CURLcode result = quic_rand_u64(data, &r);
+    if(result)
+      return result;
+    j = (size_t)(r % (i + 1));
+    if(i == j)
+      continue;
+    tmp = tokens[i];
+    tokens[i] = tokens[j];
+    tokens[j] = tmp;
+  }
+
+  return CURLE_OK;
+}
+
+static size_t quic_varint_encode(uint8_t *buf, uint64_t value)
+{
+  if(value <= UINT64_C(0x3f)) {
+    buf[0] = (uint8_t)value;
+    return 1;
+  }
+  if(value <= UINT64_C(0x3fff)) {
+    buf[0] = (uint8_t)(0x40 | (value >> 8));
+    buf[1] = (uint8_t)value;
+    return 2;
+  }
+  if(value <= UINT64_C(0x3fffffff)) {
+    buf[0] = (uint8_t)(0x80 | (value >> 24));
+    buf[1] = (uint8_t)(value >> 16);
+    buf[2] = (uint8_t)(value >> 8);
+    buf[3] = (uint8_t)value;
+    return 4;
+  }
+  if(value <= QUIC_VARINT_MAX) {
+    buf[0] = (uint8_t)(0xc0 | (value >> 56));
+    buf[1] = (uint8_t)(value >> 48);
+    buf[2] = (uint8_t)(value >> 40);
+    buf[3] = (uint8_t)(value >> 32);
+    buf[4] = (uint8_t)(value >> 24);
+    buf[5] = (uint8_t)(value >> 16);
+    buf[6] = (uint8_t)(value >> 8);
+    buf[7] = (uint8_t)value;
+    return 8;
+  }
+  return 0;
+}
+
+static CURLcode quic_raw_append_param(struct dynbuf *raw,
+                                      uint64_t id,
+                                      uint64_t value,
+                                      bool has_value)
+{
+  uint8_t idbuf[8];
+  uint8_t lenbuf[8];
+  uint8_t valbuf[8];
+  size_t idlen;
+  size_t vlen = 0;
+  size_t lenlen;
+  CURLcode result;
+
+  idlen = quic_varint_encode(idbuf, id);
+  if(!idlen)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  if(has_value) {
+    vlen = quic_varint_encode(valbuf, value);
+    if(!vlen)
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+  }
+
+  lenlen = quic_varint_encode(lenbuf, (uint64_t)vlen);
+  if(!lenlen)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  result = curlx_dyn_addn(raw, (const char *)idbuf, idlen);
+  if(result)
+    return result;
+  result = curlx_dyn_addn(raw, (const char *)lenbuf, lenlen);
+  if(result)
+    return result;
+  if(vlen) {
+    result = curlx_dyn_addn(raw, (const char *)valbuf, vlen);
+    if(result)
+      return result;
+  }
+
+  return CURLE_OK;
+}
+
+static CURLcode quic_raw_append_param_bytes(struct dynbuf *raw,
+                                            uint64_t id,
+                                            const uint8_t *value,
+                                            size_t vlen)
+{
+  uint8_t idbuf[8];
+  uint8_t lenbuf[8];
+  size_t idlen;
+  size_t lenlen;
+  CURLcode result;
+
+  if(vlen && !value)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  idlen = quic_varint_encode(idbuf, id);
+  if(!idlen)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  lenlen = quic_varint_encode(lenbuf, (uint64_t)vlen);
+  if(!lenlen)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  result = curlx_dyn_addn(raw, (const char *)idbuf, idlen);
+  if(result)
+    return result;
+  result = curlx_dyn_addn(raw, (const char *)lenbuf, lenlen);
+  if(result)
+    return result;
+  if(vlen) {
+    result = curlx_dyn_addn(raw, (const char *)value, vlen);
+    if(result)
+      return result;
+  }
+
+  return CURLE_OK;
+}
+
+static CURLcode quic_dyn_add_u32be(struct dynbuf *db, uint32_t value)
+{
+  unsigned char b[4];
+  b[0] = (unsigned char)(value >> 24);
+  b[1] = (unsigned char)(value >> 16);
+  b[2] = (unsigned char)(value >> 8);
+  b[3] = (unsigned char)value;
+  return curlx_dyn_addn(db, (const char *)b, sizeof(b));
+}
+
+static CURLcode quic_parse_version_token(const char *tok,
+                                         bool allow_grease,
+                                         struct Curl_easy *data,
+                                         uint32_t *pver)
+{
+  unsigned long long v;
+  char *end = NULL;
+
+  if(allow_grease && curl_strequal(tok, "GREASE")) {
+    *pver = quic_version_grease(data);
+    return CURLE_OK;
+  }
+
+  v = strtoull(tok, &end, 0);
+  if(!*tok || (end && *end) || (v > 0xffffffffULL))
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  *pver = (uint32_t)v;
+  return CURLE_OK;
+}
+
+static CURLcode quic_append_version_information(struct dynbuf *raw,
+                                                const char *value_str,
+                                                struct Curl_easy *data)
+{
+  struct dynbuf vb;
+  CURLcode result = CURLE_OK;
+  char *tmp;
+  char *chosen_tok;
+  char *available_list;
+  char *p;
+  char *sep;
+  size_t available_count = 0;
+  uint32_t ver;
+
+  if(!value_str || !*value_str)
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+
+  tmp = strdup(value_str);
+  if(!tmp)
+    return CURLE_OUT_OF_MEMORY;
+
+  sep = strchr(tmp, '@');
+  if(!sep || !*tmp || !*(sep + 1)) {
+    free(tmp);
+    return CURLE_BAD_FUNCTION_ARGUMENT;
+  }
+  *sep = '\0';
+  chosen_tok = tmp;
+  available_list = sep + 1;
+
+  curlx_dyn_init(&vb, 64);
+  result = quic_parse_version_token(chosen_tok, FALSE, data, &ver);
+  if(result)
+    goto out;
+  result = quic_dyn_add_u32be(&vb, ver);
+  if(result)
+    goto out;
+
+  p = available_list;
+  while(*p) {
+    char *comma = strchr(p, ',');
+    if(comma)
+      *comma = '\0';
+    result = quic_parse_version_token(p, TRUE, data, &ver);
+    if(result)
+      goto out;
+    result = quic_dyn_add_u32be(&vb, ver);
+    if(result)
+      goto out;
+    ++available_count;
+    if(!comma)
+      break;
+    if(!*(comma + 1)) {
+      result = CURLE_BAD_FUNCTION_ARGUMENT;
+      goto out;
+    }
+    p = comma + 1;
+  }
+
+  if(!available_count) {
+    result = CURLE_BAD_FUNCTION_ARGUMENT;
+    goto out;
+  }
+
+  result = quic_raw_append_param_bytes(raw, QUIC_TP_VERSION_INFORMATION,
+                                       (const uint8_t *)curlx_dyn_ptr(&vb),
+                                       curlx_dyn_len(&vb));
+
+out:
+  free(tmp);
+  curlx_dyn_free(&vb);
+  return result;
+}
+
+static CURLcode quic_transport_params_from_string(ngtcp2_transport_params *t,
+                                                  struct dynbuf *raw,
+                                                  const ngtcp2_cid *scid,
+                                                  struct Curl_easy *data)
+{
+  const char *params = data->set.str[STRING_QUIC_TRANSPORT_PARAMETERS];
+  bool permute = data->set.ssl_permute_extensions;
+  char *tmp;
+  char *p;
+  char **tokens = NULL;
+  size_t ntokens = 0;
+  size_t talloc = 0;
+  size_t i;
+  char *setting;
+  CURLcode result = CURLE_OK;
+
+  if(!params || !*params)
+    return CURLE_OK;
+
+  tmp = strdup(params);
+  if(!tmp)
+    return CURLE_OUT_OF_MEMORY;
+
+  p = tmp;
+  while(*p) {
+    char **newtokens;
+    size_t newalloc;
+
+    while(*p == ';')
+      ++p;
+    if(!*p)
+      break;
+
+    if(ntokens == talloc) {
+      newalloc = talloc ? (talloc * 2) : 8;
+      newtokens = realloc(tokens, newalloc * sizeof(*tokens));
+      if(!newtokens) {
+        result = CURLE_OUT_OF_MEMORY;
+        goto out;
+      }
+      tokens = newtokens;
+      talloc = newalloc;
+    }
+
+    tokens[ntokens++] = p;
+    while(*p && (*p != ';'))
+      ++p;
+    if(*p) {
+      *p = '\0';
+      ++p;
+    }
+  }
+
+  if(permute && (ntokens > 1)) {
+    result = quic_permute_token_order(tokens, ntokens, data);
+    if(result)
+      goto out;
+  }
+
+  for(i = 0; i < ntokens; ++i) {
+    char *colon;
+    char *value_str = NULL;
+    char *end = NULL;
+    uint64_t id;
+    uint64_t value = 0;
+    bool has_value = FALSE;
+    bool value_is_auto = FALSE;
+    bool value_is_empty_initial_scid = FALSE;
+    bool value_is_initial_rtt_auto = FALSE;
+
+    setting = tokens[i];
+    colon = strchr(setting, ':');
+
+    if(curl_strequal(setting, "GREASE")) {
+      unsigned char grease_value[QUIC_TP_GREASE_VALUE_MAXLEN];
+      size_t grease_vlen;
+
+      result = quic_generate_grease_tp(data, &id, grease_value,
+                                        &grease_vlen);
+      if(result)
+        goto out;
+      result = quic_raw_append_param_bytes(raw, id, grease_value,
+                                            grease_vlen);
+      if(result)
+        goto out;
+      continue;
+    }
+
+    if(colon) {
+      *colon = '\0';
+      has_value = TRUE;
+      value_str = colon + 1;
+    }
+
+    id = strtoull(setting, &end, 10);
+    if(!*setting || (end && *end)) {
+      result = CURLE_BAD_FUNCTION_ARGUMENT;
+      goto out;
+    }
+    if(has_value) {
+      if(id == QUIC_TP_INITIAL_SOURCE_CONNECTION_ID &&
+         curl_strequal(value_str, "AUTO"))
+        value_is_auto = TRUE;
+      else if(id == QUIC_TP_INITIAL_SOURCE_CONNECTION_ID && !*value_str)
+        value_is_empty_initial_scid = TRUE;
+      else if(id == QUIC_TP_INITIAL_RTT &&
+              (curl_strequal(value_str, "AUTO") ||
+               curl_strequal(value_str, "RANDOM")))
+        value_is_initial_rtt_auto = TRUE;
+      else if(id == QUIC_TP_VERSION_INFORMATION) {
+        /* Parsed by dedicated handler below. */
+      }
+      else {
+        value = strtoull(value_str, &end, 10);
+        if(!*value_str || (end && *end)) {
+          result = CURLE_BAD_FUNCTION_ARGUMENT;
+          goto out;
+        }
+      }
+    }
+
+    if(has_value && id == QUIC_TP_VERSION_INFORMATION) {
+      result = quic_append_version_information(raw, value_str, data);
+      if(result)
+        goto out;
+      continue;
+    }
+    if(id == QUIC_TP_GOOGLE_VERSION) {
+      unsigned char ver[4];
+
+      if(!has_value || (value > UINT_MAX)) {
+        failf(data, "QUIC transport param %" FMT_PRIu64
+              " requires a 32-bit version value", (curl_uint64_t)id);
+        result = CURLE_BAD_FUNCTION_ARGUMENT;
+        goto out;
+      }
+      ver[0] = (unsigned char)(value >> 24);
+      ver[1] = (unsigned char)(value >> 16);
+      ver[2] = (unsigned char)(value >> 8);
+      ver[3] = (unsigned char)value;
+      result = quic_apply_transport_param(t, id, value, has_value, data);
+      if(result)
+        goto out;
+      result = quic_raw_append_param_bytes(raw, id, ver, sizeof(ver));
+      if(result)
+        goto out;
+      continue;
+    }
+
+    if(value_is_auto) {
+      if(!scid) {
+        failf(data, "QUIC transport param 15:AUTO has no local SCID pointer");
+        result = CURLE_BAD_FUNCTION_ARGUMENT;
+        goto out;
+      }
+      result = quic_raw_append_param_bytes(raw, id,
+                                           (const uint8_t *)scid->data,
+                                           scid->datalen);
+      if(result)
+        goto out;
+      continue;
+    }
+    if(value_is_empty_initial_scid) {
+      result = quic_raw_append_param_bytes(raw, id, NULL, 0);
+      if(result)
+        goto out;
+      continue;
+    }
+    if(value_is_initial_rtt_auto)
+      value = quic_initial_rtt_auto_us(data);
+
+    if(id > QUIC_VARINT_MAX || (has_value && value > QUIC_VARINT_MAX)) {
+      failf(data, "QUIC transport param value exceeds varint range");
+      result = CURLE_BAD_FUNCTION_ARGUMENT;
+      goto out;
+    }
+
+    result = quic_apply_transport_param(t, id, value, has_value, data);
+    if(result)
+      goto out;
+    result = quic_raw_append_param(raw, id, value, has_value);
+    if(result)
+      goto out;
+  }
+
+out:
+  free(tokens);
+  free(tmp);
+  return result;
+}
+
+static void h3_apply_setting(nghttp3_settings *settings,
+                             unsigned long id, uint64_t value)
+{
+  switch(id) {
+  case 1: /* SETTINGS_QPACK_MAX_TABLE_CAPACITY */
+    if(value > SIZE_T_MAX)
+      value = SIZE_T_MAX;
+    settings->qpack_max_dtable_capacity = (size_t)value;
+    settings->qpack_encoder_max_dtable_capacity = (size_t)value;
+    break;
+  case 6: /* SETTINGS_MAX_FIELD_SECTION_SIZE */
+    settings->max_field_section_size = value;
+    break;
+  case 7: /* SETTINGS_QPACK_BLOCKED_STREAMS */
+    if(value > SIZE_T_MAX)
+      value = SIZE_T_MAX;
+    settings->qpack_blocked_streams = (size_t)value;
+    break;
+  case 8: /* SETTINGS_ENABLE_CONNECT_PROTOCOL */
+    settings->enable_connect_protocol = (uint8_t)(value ? 1 : 0);
+    break;
+  case 51: /* SETTINGS_H3_DATAGRAM */
+    settings->h3_datagram = (uint8_t)(value ? 1 : 0);
+    break;
+  default:
+    break;
+  }
+}
+
+static bool h3_setting_supported(unsigned long id)
+{
+  switch(id) {
+  case 1:
+  case 6:
+  case 7:
+  case 8:
+  case 51:
+  case 727725890:
+  case 16765559:
+    return TRUE;
+  default:
+    return FALSE;
+  }
+}
+
+/* HTTP/3 GREASE setting identifiers follow: 0x1f * N + 0x21 */
+#define H3_SETTINGS_GREASE_ID_BASE  UINT64_C(0x21)
+#define H3_SETTINGS_GREASE_ID_STEP  UINT64_C(0x1f)
+#define H3_VARINT_MAX               UINT64_C(0x3fffffffffffffff)
+
+static bool h3_rand_u64(struct Curl_easy *data, uint64_t *val)
+{
+  unsigned char rnd[sizeof(uint64_t)];
+  CURLcode result;
+  size_t i;
+
+  result = Curl_rand(data, rnd, sizeof(rnd));
+  if(result)
+    return FALSE;
+
+  *val = 0;
+  for(i = 0; i < sizeof(rnd); ++i)
+    *val = (*val << 8) | rnd[i];
+
+  return TRUE;
+}
+
+static bool h3_generate_grease_setting(struct Curl_easy *data,
+                                       nghttp3_settings_entry *iv)
+{
+  uint64_t n;
+  uint64_t value;
+  uint64_t max_n = (H3_VARINT_MAX - H3_SETTINGS_GREASE_ID_BASE) /
+                   H3_SETTINGS_GREASE_ID_STEP;
+
+  if(!h3_rand_u64(data, &n) || !h3_rand_u64(data, &value))
+    return FALSE;
+
+  n %= (max_n + 1);
+  iv->id = H3_SETTINGS_GREASE_ID_STEP * n + H3_SETTINGS_GREASE_ID_BASE;
+  iv->value = value & H3_VARINT_MAX;
+  return TRUE;
+}
+
+static size_t h3_settings_count(const char *h3_settings)
+{
+  size_t count = 0;
+
+  if(h3_settings && *h3_settings) {
+    const char *p;
+
+    count = 1;
+    for(p = h3_settings; *p; ++p) {
+      if(*p == ';')
+        ++count;
+    }
+  }
+
+  return count;
+}
+
+static size_t populate_h3_settings(nghttp3_settings_entry *iv,
+                                   size_t ivlen,
+                                   nghttp3_settings *settings,
+                                   struct Curl_easy *data)
+{
+  const char *h3_settings = data->set.str[STRING_HTTP3_SETTINGS];
+  char *tmp;
+  char *setting;
+  size_t i = 0;
+
+  if(!h3_settings || !*h3_settings)
+    return 0;
+
+  tmp = strdup(h3_settings);
+  if(!tmp)
+    return 0;
+
+  setting = strtok(tmp, ";");
+  while(setting) {
+    char *colon = strchr(setting, ':');
+    char *end = NULL;
+    unsigned long id;
+    unsigned long long value;
+
+    if(curl_strequal(setting, "GREASE")) {
+      if(iv && (i < ivlen)) {
+        if(h3_generate_grease_setting(data, &iv[i]))
+          ++i;
+      }
+      setting = strtok(NULL, ";");
+      continue;
+    }
+
+    if(!colon) {
+      setting = strtok(NULL, ";");
+      continue;
+    }
+    *colon = '\0';
+    id = strtoul(setting, &end, 10);
+    if(!*setting || (end && *end)) {
+      setting = strtok(NULL, ";");
+      continue;
+    }
+    value = strtoull(colon + 1, &end, 10);
+    if(!*(colon + 1) || (end && *end)) {
+      setting = strtok(NULL, ";");
+      continue;
+    }
+
+    if(!h3_setting_supported(id)) {
+      setting = strtok(NULL, ";");
+      continue;
+    }
+
+    h3_apply_setting(settings, id, (uint64_t)value);
+    if(iv && (i < ivlen)) {
+      iv[i].id = id;
+      iv[i].value = (uint64_t)value;
+      ++i;
+    }
+    setting = strtok(NULL, ";");
+  }
+
+  free(tmp);
+  return i;
 }
 
 static CURLcode init_ngh3_conn(struct Curl_cfilter *cf,
@@ -1190,6 +2054,10 @@ static CURLcode init_ngh3_conn(struct Curl_cfilter *cf,
 {
   struct cf_ngtcp2_ctx *ctx = cf->ctx;
   int64_t ctrl_stream_id, qpack_enc_stream_id, qpack_dec_stream_id;
+  const char *h3_settings = data->set.str[STRING_HTTP3_SETTINGS];
+  nghttp3_settings_entry *h3iv = NULL;
+  size_t h3ivalloc = 0;
+  size_t h3ivlen = 0;
   int rc;
 
   if(ngtcp2_conn_get_streams_uni_left(ctx->qconn) < 3) {
@@ -1197,7 +2065,15 @@ static CURLcode init_ngh3_conn(struct Curl_cfilter *cf,
     return CURLE_QUIC_CONNECT_ERROR;
   }
 
+  h3ivalloc = h3_settings_count(h3_settings);
+  if(h3ivalloc) {
+    h3iv = malloc(h3ivalloc * sizeof(*h3iv));
+    if(!h3iv)
+      return CURLE_OUT_OF_MEMORY;
+  }
+
   nghttp3_settings_default(&ctx->h3settings);
+  h3ivlen = populate_h3_settings(h3iv, h3ivalloc, &ctx->h3settings, data);
 
   rc = nghttp3_conn_client_new(&ctx->h3conn,
                                &ngh3_callbacks,
@@ -1205,10 +2081,23 @@ static CURLcode init_ngh3_conn(struct Curl_cfilter *cf,
                                nghttp3_mem_default(),
                                cf);
   if(rc) {
+    free(h3iv);
     failf(data, "error creating nghttp3 connection instance");
     return CURLE_OUT_OF_MEMORY;
   }
 
+  if(h3ivlen) {
+    rc = nghttp3_conn_submit_settings(ctx->h3conn, 0, h3iv, h3ivlen);
+    free(h3iv);
+    if(rc) {
+      failf(data, "error submitting HTTP/3 settings: %s",
+            nghttp3_strerror(rc));
+      return CURLE_QUIC_CONNECT_ERROR;
+    }
+  }
+  else
+    free(h3iv);
+
   rc = ngtcp2_conn_open_uni_stream(ctx->qconn, &ctrl_stream_id, NULL);
   if(rc) {
     failf(data, "error creating HTTP/3 control stream: %s",
@@ -2420,9 +3309,6 @@ static CURLcode cf_connect_start(struct Curl_cfilter *cf,
   CURLcode result;
   const struct Curl_sockaddr_ex *sockaddr = NULL;
   int qfd;
-static const struct alpn_spec ALPN_SPEC_H3 = {
-  { "h3", "h3-29" }, 2
-};
 
   DEBUGASSERT(ctx->initialized);
   ctx->dcid.datalen = NGTCP2_MAX_CIDLEN;
@@ -2431,19 +3317,27 @@ static const struct alpn_spec ALPN_SPEC_H3 = {
     return result;
 
   ctx->scid.datalen = NGTCP2_MAX_CIDLEN;
-  result = Curl_rand(data, ctx->scid.data, NGTCP2_MAX_CIDLEN);
-  if(result)
-    return result;
+  if(quic_has_empty_initial_scid(
+       data->set.str[STRING_QUIC_TRANSPORT_PARAMETERS])) {
+    ctx->scid.datalen = 0;
+  }
+  else {
+    result = Curl_rand(data, ctx->scid.data, ctx->scid.datalen);
+    if(result)
+      return result;
+  }
 
-  (void)Curl_qlogdir(data, ctx->scid.data, NGTCP2_MAX_CIDLEN, &qfd);
+  (void)Curl_qlogdir(data, ctx->scid.data, ctx->scid.datalen, &qfd);
   ctx->qlogfd = qfd; /* -1 if failure above */
-  quic_settings(ctx, data, pktx);
+  result = quic_settings(ctx, data, pktx);
+  if(result)
+    return result;
 
   result = vquic_ctx_init(&ctx->q);
   if(result)
     return result;
 
-  Curl_cf_socket_peek(cf->next, data, &ctx->q.sockfd, &sockaddr, NULL);
+  cf_ngtcp2_peek_socket(cf->next, data, &ctx->q.sockfd, &sockaddr, NULL);
   if(!sockaddr)
     return CURLE_QUIC_CONNECT_ERROR;
   ctx->q.local_addrlen = sizeof(ctx->q.local_addr);
@@ -2466,6 +3360,19 @@ static const struct alpn_spec ALPN_SPEC_H3 = {
   if(rc)
     return CURLE_QUIC_CONNECT_ERROR;
 
+  if(curlx_dyn_len(&ctx->tp_raw)) {
+    ngtcp2_transport_params_raw raw = {
+      (const uint8_t *)curlx_dyn_ptr(&ctx->tp_raw),
+      curlx_dyn_len(&ctx->tp_raw)
+    };
+    rc = ngtcp2_conn_set_local_transport_params_raw(ctx->qconn, &raw);
+    if(rc) {
+      failf(data, "error setting local QUIC transport params: %s",
+            ngtcp2_strerror(rc));
+      return CURLE_QUIC_CONNECT_ERROR;
+    }
+  }
+
   ctx->conn_ref.get_conn = get_conn;
   ctx->conn_ref.user_data = cf;
 
@@ -2578,7 +3485,7 @@ out:
   if(result) {
     struct ip_quadruple ip;
 
-    Curl_cf_socket_peek(cf->next, data, NULL, NULL, &ip);
+    cf_ngtcp2_peek_socket(cf->next, data, NULL, NULL, &ip);
     infof(data, "QUIC connect to %s port %u failed: %s",
           ip.remote_ip, ip.remote_port, curl_easy_strerror(result));
   }
@@ -2732,7 +3639,10 @@ CURLcode Curl_cf_ngtcp2_create(struct Curl_cfilter **pcf,
                                const struct Curl_addrinfo *ai)
 {
   struct cf_ngtcp2_ctx *ctx = NULL;
-  struct Curl_cfilter *cf = NULL, *udp_cf = NULL;
+  struct Curl_cfilter *cf = NULL;
+  struct Curl_cfilter *udp_cf = NULL;
+  struct Curl_cfilter *socks_cf = NULL;
+  struct Curl_cfilter *tcp_cf = NULL;
   CURLcode result;
 
   (void)data;
@@ -2747,20 +3657,41 @@ CURLcode Curl_cf_ngtcp2_create(struct Curl_cfilter **pcf,
   if(result)
     goto out;
 
-  result = Curl_cf_udp_create(&udp_cf, data, conn, ai, TRNSPRT_QUIC);
-  if(result)
-    goto out;
-
   cf->conn = conn;
-  udp_cf->conn = cf->conn;
-  udp_cf->sockindex = cf->sockindex;
-  cf->next = udp_cf;
+  if(conn->bits.socksproxy) {
+    /* Build SOCKS->TCP chain for the proxy control channel. */
+    result = Curl_cf_create(&socks_cf, &Curl_cft_socks_proxy, NULL);
+    if(result)
+      goto out;
+    socks_cf->conn = cf->conn;
+    socks_cf->sockindex = cf->sockindex;
+    result = Curl_cf_tcp_create(&tcp_cf, data, conn, ai, TRNSPRT_TCP);
+    if(result)
+      goto out;
+    tcp_cf->conn = cf->conn;
+    tcp_cf->sockindex = cf->sockindex;
+    socks_cf->next = tcp_cf;
+    cf->next = socks_cf;
+  }
+  else {
+    result = Curl_cf_udp_create(&udp_cf, data, conn, ai, TRNSPRT_QUIC);
+    if(result)
+      goto out;
+
+    udp_cf->conn = cf->conn;
+    udp_cf->sockindex = cf->sockindex;
+    cf->next = udp_cf;
+  }
 
 out:
   *pcf = (!result) ? cf : NULL;
   if(result) {
     if(udp_cf)
       Curl_conn_cf_discard_sub(cf, udp_cf, data, TRUE);
+    if(socks_cf)
+      Curl_conn_cf_discard_sub(cf, socks_cf, data, TRUE);
+    if(tcp_cf)
+      Curl_conn_cf_discard_sub(cf, tcp_cf, data, TRUE);
     Curl_safefree(cf);
     cf_ngtcp2_ctx_free(ctx);
   }
diff --git a/lib/vquic/vquic.c b/lib/vquic/vquic.c
index 691c0d3fa7..cf29e5952c 100644
--- a/lib/vquic/vquic.c
+++ b/lib/vquic/vquic.c
@@ -41,6 +41,8 @@
 #include "curl_quiche.h"
 #include "../multiif.h"
 #include "../rand.h"
+#include "../cf-socket.h"
+#include "../socks.h"
 #include "vquic.h"
 #include "vquic_int.h"
 #include "../strerror.h"
@@ -57,6 +59,38 @@
 #define NW_CHUNK_SIZE     (64 * 1024)
 #define NW_SEND_CHUNKS    2
 
+static CURLcode vquic_peek_socket(struct Curl_cfilter *cf,
+                                  struct Curl_easy *data,
+                                  struct ip_quadruple *pip)
+{
+  for(; cf; cf = cf->next) {
+    if(!Curl_cf_socket_peek(cf, data, NULL, NULL, pip))
+      return CURLE_OK;
+  }
+  return CURLE_FAILED_INIT;
+}
+
+/* Resolve the relay address from the active socket for recv callbacks. */
+static bool vquic_get_remote_addr(struct Curl_cfilter *cf,
+                                  struct Curl_easy *data,
+                                  struct sockaddr_storage *remote_addr,
+                                  socklen_t *remote_addrlen)
+{
+  const struct Curl_sockaddr_ex *peer_addr = NULL;
+  int dummy = 0;
+
+  for(; cf; cf = cf->next) {
+    if(!cf->cft->query(cf, data, CF_QUERY_REMOTE_ADDR, &dummy,
+                       &peer_addr) && peer_addr) {
+      memset(remote_addr, 0, sizeof(*remote_addr));
+      memcpy(remote_addr, &peer_addr->curl_sa_addr, peer_addr->addrlen);
+      *remote_addrlen = (socklen_t)peer_addr->addrlen;
+      return TRUE;
+    }
+  }
+  return FALSE;
+}
+
 
 int Curl_vquic_init(void)
 {
@@ -249,6 +283,38 @@ static CURLcode vquic_send_packets(struct Curl_cfilter *cf,
                                    const uint8_t *pkt, size_t pktlen,
                                    size_t gsolen, size_t *psent)
 {
+  if(Curl_cf_socks_proxy_is_udp_associate(cf->next)) {
+    CURLcode result;
+    size_t sent_total = 0;
+    const uint8_t *p = pkt;
+    size_t pktstep = gsolen ? gsolen : pktlen;
+
+    /* SOCKS UDP ASSOCIATE needs per-packet encapsulation in the filter. */
+    infof(data, "QUIC over SOCKS UDP send: bytes=%zu gso=%zu",
+          pktlen, gsolen);
+    qctx->no_gso = TRUE;
+    while(sent_total < pktlen) {
+      size_t len = CURLMIN(pktstep, pktlen - sent_total);
+      size_t nwritten = 0;
+
+      result = Curl_conn_cf_send(cf->next, data, p, len, FALSE, &nwritten);
+      if(result) {
+        if(result == CURLE_AGAIN) {
+          *psent = sent_total;
+          return result;
+        }
+        return result;
+      }
+      if(nwritten != len)
+        return CURLE_SEND_ERROR;
+      sent_total += nwritten;
+      p += nwritten;
+    }
+    *psent = sent_total;
+    qctx->last_io = qctx->last_op;
+    return CURLE_OK;
+  }
+
   CURLcode result;
 #ifdef DEBUGBUILD
   /* simulate network blocking/partial writes */
@@ -378,14 +444,14 @@ static CURLcode recvmmsg_packets(struct Curl_cfilter *cf,
   size_t pktlen;
   size_t offset, to;
   char *sockbuf = NULL;
-  uint8_t (*bufs)[64*1024] = NULL;
+  uint8_t (*bufs)[NW_CHUNK_SIZE] = NULL;
 
   DEBUGASSERT(max_pkts > 0);
   result = Curl_multi_xfer_sockbuf_borrow(data, MMSG_NUM * sizeof(bufs[0]),
                                           &sockbuf);
   if(result)
     goto out;
-  bufs = (uint8_t (*)[64*1024])sockbuf;
+  bufs = (uint8_t (*)[NW_CHUNK_SIZE])sockbuf;
 
   total_nread = 0;
   while(pkts < max_pkts) {
@@ -412,7 +478,7 @@ static CURLcode recvmmsg_packets(struct Curl_cfilter *cf,
       }
       if(!cf->connected && SOCKERRNO == SOCKECONNREFUSED) {
         struct ip_quadruple ip;
-        Curl_cf_socket_peek(cf->next, data, NULL, NULL, &ip);
+        vquic_peek_socket(cf->next, data, &ip);
         failf(data, "QUIC: connection to %s port %u refused",
               ip.remote_ip, ip.remote_port);
         result = CURLE_COULDNT_CONNECT;
@@ -470,7 +536,7 @@ static CURLcode recvmsg_packets(struct Curl_cfilter *cf,
 {
   struct iovec msg_iov;
   struct msghdr msg;
-  uint8_t buf[64*1024];
+  uint8_t buf[NW_CHUNK_SIZE];
   struct sockaddr_storage remote_addr;
   size_t total_nread, pkts;
   ssize_t nread;
@@ -504,7 +570,7 @@ static CURLcode recvmsg_packets(struct Curl_cfilter *cf,
       }
       if(!cf->connected && SOCKERRNO == SOCKECONNREFUSED) {
         struct ip_quadruple ip;
-        Curl_cf_socket_peek(cf->next, data, NULL, NULL, &ip);
+        vquic_peek_socket(cf->next, data, &ip);
         failf(data, "QUIC: connection to %s port %u refused",
               ip.remote_ip, ip.remote_port);
         result = CURLE_COULDNT_CONNECT;
@@ -556,7 +622,7 @@ static CURLcode recvfrom_packets(struct Curl_cfilter *cf,
                                  size_t max_pkts,
                                  vquic_recv_pkt_cb *recv_cb, void *userp)
 {
-  uint8_t buf[64*1024];
+  uint8_t buf[NW_CHUNK_SIZE];
   int bufsize = (int)sizeof(buf);
   struct sockaddr_storage remote_addr;
   socklen_t remote_addrlen = sizeof(remote_addr);
@@ -579,7 +645,7 @@ static CURLcode recvfrom_packets(struct Curl_cfilter *cf,
       }
       if(!cf->connected && SOCKERRNO == SOCKECONNREFUSED) {
         struct ip_quadruple ip;
-        Curl_cf_socket_peek(cf->next, data, NULL, NULL, &ip);
+        vquic_peek_socket(cf->next, data, &ip);
         failf(data, "QUIC: connection to %s port %u refused",
               ip.remote_ip, ip.remote_port);
         result = CURLE_COULDNT_CONNECT;
@@ -615,6 +681,51 @@ CURLcode vquic_recv_packets(struct Curl_cfilter *cf,
                             vquic_recv_pkt_cb *recv_cb, void *userp)
 {
   CURLcode result;
+
+  if(Curl_cf_socks_proxy_is_udp_associate(cf->next)) {
+    uint8_t buf[NW_CHUNK_SIZE];
+    struct sockaddr_storage remote_addr;
+    socklen_t remote_addrlen = 0;
+    size_t total_nread = 0;
+    size_t pkts = 0;
+
+    result = CURLE_OK;
+    /* SOCKS UDP ASSOCIATE recv path goes through the filter chain. */
+    infof(data, "QUIC over SOCKS UDP recv: max_pkts=%zu", max_pkts);
+    for(pkts = 0, total_nread = 0; pkts < max_pkts;) {
+      size_t nread = 0;
+      result = Curl_conn_cf_recv(cf->next, data, (char *)buf, sizeof(buf),
+                                 &nread);
+      if(result) {
+        if(result == CURLE_AGAIN) {
+          result = CURLE_OK;
+          break;
+        }
+        if(!cf->connected && data->state.os_errno == SOCKECONNREFUSED) {
+          struct ip_quadruple ip;
+          vquic_peek_socket(cf->next, data, &ip);
+          failf(data, "QUIC: connection to %s port %u refused",
+                ip.remote_ip, ip.remote_port);
+          return CURLE_COULDNT_CONNECT;
+        }
+        return result;
+      }
+
+      if(!vquic_get_remote_addr(cf->next, data, &remote_addr,
+                                &remote_addrlen))
+        return CURLE_FAILED_INIT;
+      ++pkts;
+      total_nread += nread;
+      result = recv_cb(buf, nread, &remote_addr, remote_addrlen, 0, userp);
+      if(result)
+        return result;
+    }
+
+    if(total_nread || result)
+      CURL_TRC_CF(data, cf, "recvd %zu packets with %zu bytes -> %d",
+                  pkts, total_nread, result);
+  }
+  else
 #if defined(HAVE_SENDMMSG)
   result = recvmmsg_packets(cf, data, qctx, max_pkts, recv_cb, userp);
 #elif defined(HAVE_SENDMSG)
@@ -715,10 +826,6 @@ CURLcode Curl_conn_may_http3(struct Curl_easy *data,
     return CURLE_URL_MALFORMAT;
   }
 #ifndef CURL_DISABLE_PROXY
-  if(conn->bits.socksproxy) {
-    failf(data, "HTTP/3 is not supported over a SOCKS proxy");
-    return CURLE_URL_MALFORMAT;
-  }
   if(conn->bits.httpproxy && conn->bits.tunnel_proxy) {
     failf(data, "HTTP/3 is not supported over an HTTP proxy");
     return CURLE_URL_MALFORMAT;
diff --git a/lib/vtls/openssl.c b/lib/vtls/openssl.c
index b0f91cf400..eb705ed067 100644
--- a/lib/vtls/openssl.c
+++ b/lib/vtls/openssl.c
@@ -82,9 +82,20 @@
 #include <openssl/bio.h>
 #include <openssl/buffer.h>
 #include <openssl/pkcs12.h>
+#include <openssl/pool.h>
 #include <openssl/tls1.h>
 #include <openssl/evp.h>
 
+#ifdef HAVE_LIBZ
+#include <zlib.h>
+#endif
+#ifdef HAVE_BROTLI
+#include <brotli/decode.h>
+#endif
+#ifdef HAVE_ZSTD
+#include <zstd.h>
+#endif
+
 #ifdef HAVE_SSL_SET1_ECH_CONFIG_LIST
 #define USE_ECH_OPENSSL
 #endif
@@ -262,6 +273,113 @@ typedef int numcert_t;
 #define HAVE_OPENSSL_VERSION
 #endif
 
+#if defined(OPENSSL_IS_BORINGSSL)
+#define HAVE_SSL_CTX_SET_VERIFY_ALGORITHM_PREFS
+
+/*
+ * kMaxSignatureAlgorithmNameLen and kSignatureAlgorithmNames
+ * Taken from BoringSSL, see ssl/ssl_privkey.cc
+ * */
+static const size_t kMaxSignatureAlgorithmNameLen = 23;
+
+static const struct {
+  uint16_t signature_algorithm;
+  const char *name;
+} kSignatureAlgorithmNames[] = {
+    {SSL_SIGN_RSA_PKCS1_MD5_SHA1, "rsa_pkcs1_md5_sha1"},
+    {SSL_SIGN_RSA_PKCS1_SHA1, "rsa_pkcs1_sha1"},
+    {SSL_SIGN_RSA_PKCS1_SHA256, "rsa_pkcs1_sha256"},
+    {SSL_SIGN_RSA_PKCS1_SHA384, "rsa_pkcs1_sha384"},
+    {SSL_SIGN_RSA_PKCS1_SHA512, "rsa_pkcs1_sha512"},
+    {SSL_SIGN_ECDSA_SHA1, "ecdsa_sha1"},
+    {SSL_SIGN_ECDSA_SECP256R1_SHA256, "ecdsa_secp256r1_sha256"},
+    {SSL_SIGN_ECDSA_SECP384R1_SHA384, "ecdsa_secp384r1_sha384"},
+    {SSL_SIGN_ECDSA_SECP521R1_SHA512, "ecdsa_secp521r1_sha512"},
+    {SSL_SIGN_RSA_PSS_RSAE_SHA256, "rsa_pss_rsae_sha256"},
+    {SSL_SIGN_RSA_PSS_RSAE_SHA384, "rsa_pss_rsae_sha384"},
+    {SSL_SIGN_RSA_PSS_RSAE_SHA512, "rsa_pss_rsae_sha512"},
+    {SSL_SIGN_ED25519, "ed25519"},
+};
+
+#define MAX_SIG_ALGS \
+  sizeof(kSignatureAlgorithmNames) / sizeof(kSignatureAlgorithmNames[0])
+
+/* Default signature hash algorithms taken from Chrome/Chromium.
+ * See kVerifyPeers @ net/socket/ssl_client_socket_impl.cc */
+static const uint16_t default_sig_algs[] = {
+  SSL_SIGN_ECDSA_SECP256R1_SHA256, SSL_SIGN_RSA_PSS_RSAE_SHA256,
+  SSL_SIGN_RSA_PKCS1_SHA256,       SSL_SIGN_ECDSA_SECP384R1_SHA384,
+  SSL_SIGN_RSA_PSS_RSAE_SHA384,    SSL_SIGN_RSA_PKCS1_SHA384,
+  SSL_SIGN_RSA_PSS_RSAE_SHA512,    SSL_SIGN_RSA_PKCS1_SHA512,
+};
+
+#define DEFAULT_SIG_ALGS_LENGTH  \
+  sizeof(default_sig_algs) / sizeof(default_sig_algs[0])
+
+static CURLcode parse_sig_algs(struct Curl_easy *data,
+                               const char *sigalgs,
+                               uint16_t *algs,
+                               size_t *nalgs)
+{
+  *nalgs = 0;
+  while (sigalgs && sigalgs[0]) {
+    int i;
+    bool found = FALSE;
+    const char *end;
+    size_t len;
+    char algname[kMaxSignatureAlgorithmNameLen + 1];
+
+    end = strpbrk(sigalgs, ":,");
+    if (end)
+      len = end - sigalgs;
+    else
+      len = strlen(sigalgs);
+
+    if (len > kMaxSignatureAlgorithmNameLen) {
+      failf(data, "Bad signature hash algorithm list");
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    }
+
+    if (!len) {
+      ++sigalgs;
+      continue;
+    }
+
+    if (*nalgs == MAX_SIG_ALGS) {
+      /* Reached the maximum number of possible algorithms, but more data
+       * available in the list. */
+      failf(data, "Bad signature hash algorithm list");
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    }
+
+    memcpy(algname, sigalgs, len);
+    algname[len] = 0;
+
+    for (i = 0; i < MAX_SIG_ALGS; i++) {
+      if (curl_strequal(algname, kSignatureAlgorithmNames[i].name)) {
+        algs[*nalgs] = kSignatureAlgorithmNames[i].signature_algorithm;
+        (*nalgs)++;
+        found = TRUE;
+        break;
+      }
+    }
+
+    if (!found) {
+      failf(data, "Unknown signature hash algorithm: '%s'", algname);
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    }
+
+    if (end)
+      sigalgs = ++end;
+    else
+      break;
+  }
+
+  return CURLE_OK;
+}
+
+#endif
+
 #if defined(OPENSSL_IS_BORINGSSL) || defined(OPENSSL_IS_AWSLC)
 typedef uint32_t sslerr_t;
 #else
@@ -2740,6 +2858,182 @@ static const char *tls_rt_type(int type)
   }
 }
 
+#ifdef HAVE_LIBZ
+int DecompressZlibCert(SSL *ssl,
+                       CRYPTO_BUFFER** out,
+                       size_t uncompressed_len,
+                       const uint8_t* in,
+                       size_t in_len)
+{
+  z_stream strm;
+  uint8_t* data;
+  CRYPTO_BUFFER* decompressed = CRYPTO_BUFFER_alloc(&data, uncompressed_len);
+  if(!decompressed) {
+    return 0;
+  }
+
+  strm.zalloc = NULL;
+  strm.zfree = NULL;
+  strm.opaque = NULL;
+  strm.next_in = (Bytef *)in;
+  strm.avail_in = in_len;
+  strm.next_out = (Bytef *)data;
+  strm.avail_out = uncompressed_len;
+
+  if(inflateInit(&strm) != Z_OK) {
+    CRYPTO_BUFFER_free(decompressed);
+    return 0;
+  }
+
+  if(inflate(&strm, Z_FINISH) != Z_STREAM_END ||
+    strm.avail_in != 0 ||
+    strm.avail_out != 0) {
+    inflateEnd(&strm);
+    CRYPTO_BUFFER_free(decompressed);
+    return 0;
+  }
+
+  inflateEnd(&strm);
+  *out = decompressed;
+  return 1;
+}
+#endif
+
+#ifdef HAVE_BROTLI
+
+/* Taken from Chromium and adapted to C,
+ * see net/ssl/cert_compression.cc
+ */
+int DecompressBrotliCert(SSL* ssl,
+                         CRYPTO_BUFFER** out,
+                         size_t uncompressed_len,
+                         const uint8_t* in,
+                         size_t in_len) {
+  uint8_t* data;
+  CRYPTO_BUFFER* decompressed = CRYPTO_BUFFER_alloc(&data, uncompressed_len);
+  if (!decompressed) {
+    return 0;
+  }
+
+  size_t output_size = uncompressed_len;
+  if (BrotliDecoderDecompress(in_len, in, &output_size, data) !=
+          BROTLI_DECODER_RESULT_SUCCESS ||
+      output_size != uncompressed_len) {
+    CRYPTO_BUFFER_free(decompressed);
+    return 0;
+  }
+
+  *out = decompressed;
+  return 1;
+}
+#endif
+
+// curl-impersonate: decompress the zstd cert
+#ifdef HAVE_ZSTD
+int DecompressZstdCert(SSL* ssl,
+                       CRYPTO_BUFFER** out,
+                       size_t uncompressed_len,
+                       const uint8_t* in,
+                       size_t in_len) {
+  size_t result;
+  uint8_t* data;
+  CRYPTO_BUFFER* decompressed = CRYPTO_BUFFER_alloc(&data, uncompressed_len);
+  if (!decompressed) {
+    return 0;
+  }
+
+  // zstd returns the size of decompressed content
+  result = ZSTD_decompress(data, uncompressed_len, in, in_len);
+  if (ZSTD_isError(result)) {
+    CRYPTO_BUFFER_free(decompressed);
+    return 0;
+  }
+
+  *out = decompressed;
+  return 1;
+}
+
+#endif
+
+
+#if defined(HAVE_LIBZ) || defined(HAVE_BROTLI) || defined(HAVE_ZSTD)
+static struct {
+  char *alg_name;
+  uint16_t alg_id;
+  ssl_cert_compression_func_t compress;
+  ssl_cert_decompression_func_t decompress;
+} cert_compress_algs[] = {
+#ifdef HAVE_LIBZ
+  {"zlib", TLSEXT_cert_compression_zlib, NULL, DecompressZlibCert},
+#endif
+#ifdef HAVE_BROTLI
+  {"brotli", TLSEXT_cert_compression_brotli, NULL, DecompressBrotliCert},
+#endif
+#ifdef HAVE_ZSTD
+  {"zstd", TLSEXT_cert_compression_zstd, NULL, DecompressZstdCert},
+#endif
+};
+
+#define NUM_CERT_COMPRESSION_ALGS \
+  sizeof(cert_compress_algs) / sizeof(cert_compress_algs[0])
+
+/*
+ * curl-impersonate:
+ * Add support for TLS extension 27 - compress_certificate.
+ * This calls the BoringSSL-specific API SSL_CTX_add_cert_compression_alg
+ * for each algorithm specified in cert_compression, which is a comma separated list.
+ */
+static CURLcode add_cert_compression(struct Curl_easy *data,
+                                     SSL_CTX *ctx,
+                                     const char *algorithms)
+{
+  int i;
+  const char *s = algorithms;
+  char *alg_name;
+  size_t alg_name_len;
+  bool found;
+
+  while (s && s[0]) {
+    found = FALSE;
+
+    for(i = 0; i < NUM_CERT_COMPRESSION_ALGS; i++) {
+      alg_name = cert_compress_algs[i].alg_name;
+      alg_name_len = strlen(alg_name);
+      if(strlen(s) >= alg_name_len &&
+         curl_strnequal(s, alg_name, alg_name_len) &&
+         (s[alg_name_len] == ',' || s[alg_name_len] == 0)) {
+        if(!SSL_CTX_add_cert_compression_alg(ctx,
+                    cert_compress_algs[i].alg_id,
+                    cert_compress_algs[i].compress,
+                    cert_compress_algs[i].decompress)) {
+          failf(data, "Error adding certificate compression algorithm '%s'",
+                alg_name);
+          return CURLE_SSL_CIPHER;
+        }
+        s += alg_name_len;
+        if(*s == ',')
+          s += 1;
+        found = TRUE;
+        break;
+      }
+    }
+
+    if(!found) {
+      failf(data, "Invalid compression algorithm list");
+      return CURLE_BAD_FUNCTION_ARGUMENT;
+    }
+  }
+
+  return CURLE_OK;
+}
+#else
+static CURLcode add_cert_compression(SSL_CTX *ctx, const char *algorithms)
+{
+  /* No compression algorithms are available. */
+  return CURLE_BAD_FUNCTION_ARGUMENT;
+}
+#endif
+
 /*
  * Our callback from the SSL/TLS layers.
  */
@@ -3739,6 +4033,9 @@ static CURLcode ossl_init_ech(struct ossl_ctx *octx,
   size_t ech_config_len = 0;
   char *outername = data->set.str[STRING_ECH_PUBLIC];
   int trying_ech_now = 0;
+  int fallback_grease = ((data->set.tls_ech & CURLECH_ENABLE) &&
+                         !(data->set.tls_ech & CURLECH_HARD) &&
+                         !(data->set.tls_ech & CURLECH_CLA_CFG));
   CURLcode result;
 
   if(!ECH_ENABLED(data))
@@ -3804,7 +4101,15 @@ static CURLcode ossl_init_ech(struct ossl_ctx *octx,
                               cf->conn->ip_version);
     if(!dns) {
       infof(data, "ECH: requested but no DNS info available");
-      if(data->set.tls_ech & CURLECH_HARD)
+      if(fallback_grease) {
+        infof(data, "ECH: falling back to GREASE");
+# if defined(OPENSSL_IS_BORINGSSL) || defined(OPENSSL_IS_AWSLC)
+        SSL_set_enable_ech_grease(octx->ssl, 1);
+# else
+        SSL_set_options(octx->ssl, SSL_OP_ECH_GREASE);
+# endif
+      }
+      else if(data->set.tls_ech & CURLECH_HARD)
         return CURLE_SSL_CONNECT_ERROR;
     }
     else {
@@ -3820,6 +4125,14 @@ static CURLcode ossl_init_ech(struct ossl_ctx *octx,
           infof(data, "ECH: SSL_set1_ech_config_list failed");
           if(data->set.tls_ech & CURLECH_HARD)
             return CURLE_SSL_CONNECT_ERROR;
+          if(fallback_grease) {
+            infof(data, "ECH: falling back to GREASE");
+# if defined(OPENSSL_IS_BORINGSSL) || defined(OPENSSL_IS_AWSLC)
+            SSL_set_enable_ech_grease(octx->ssl, 1);
+# else
+            SSL_set_options(octx->ssl, SSL_OP_ECH_GREASE);
+# endif
+          }
         }
         else {
           trying_ech_now = 1;
@@ -3828,7 +4141,15 @@ static CURLcode ossl_init_ech(struct ossl_ctx *octx,
       }
       else {
         infof(data, "ECH: requested but no ECHConfig available");
-        if(data->set.tls_ech & CURLECH_HARD)
+        if(fallback_grease) {
+          infof(data, "ECH: falling back to GREASE");
+# if defined(OPENSSL_IS_BORINGSSL) || defined(OPENSSL_IS_AWSLC)
+          SSL_set_enable_ech_grease(octx->ssl, 1);
+# else
+          SSL_set_options(octx->ssl, SSL_OP_ECH_GREASE);
+# endif
+        }
+        else if(data->set.tls_ech & CURLECH_HARD)
           return CURLE_SSL_CONNECT_ERROR;
       }
       Curl_resolv_unlink(data, &dns);
@@ -3852,11 +4173,18 @@ static CURLcode ossl_init_ech(struct ossl_ctx *octx,
     }
   }
 # endif  /* OPENSSL_IS_BORINGSSL || OPENSSL_IS_AWSLC */
+  /*
+   * BoringSSL/AWS-LC handle ECH's TLS version rules internally between
+   * ClientHelloInner/Outer. Do not force a global TLS minimum here so the
+   * outer behavior can match browsers.
+   */
+#if !defined(OPENSSL_IS_BORINGSSL) && !defined(OPENSSL_IS_AWSLC)
   if(trying_ech_now
      && SSL_set_min_proto_version(octx->ssl, TLS1_3_VERSION) != 1) {
     infof(data, "ECH: cannot force TLSv1.3 [ERROR]");
     return CURLE_SSL_CONNECT_ERROR;
   }
+#endif
 
   return CURLE_OK;
 }
@@ -3871,6 +4199,9 @@ static CURLcode ossl_init_ssl(struct ossl_ctx *octx,
                               void *ssl_user_data,
                               Curl_ossl_init_session_reuse_cb *sess_reuse_cb)
 {
+  struct ssl_connect_data *connssl = cf->ctx;
+  const struct alpn_spec *alps = NULL;
+
   /* Let's make an SSL structure */
   if(octx->ssl)
     SSL_free(octx->ssl);
@@ -3882,6 +4213,35 @@ static CURLcode ossl_init_ssl(struct ossl_ctx *octx,
 
   SSL_set_app_data(octx->ssl, ssl_user_data);
 
+#ifdef HAS_ALPN_OPENSSL
+  if(data->set.ssl_enable_alps) {
+    if(peer->transport == TRNSPRT_QUIC)
+      alps = alpns_requested;
+    else
+      alps = connssl->alps;
+  }
+  if(alps) {
+    size_t i;
+    struct alpn_proto_buf proto;
+
+    /* curl-impersonate: Set new ALPS codepoint before adding any ALPS settings */
+    if(data->set.tls_use_new_alps_codepoint) {
+      SSL_set_alps_use_new_codepoint(octx->ssl, 1);
+    }
+
+    for(i = 0; i < alps->count; ++i) {
+      /* curl-impersonate: Add the ALPS extension (17513) like Chrome does. */
+      // XXX: Firefox does not enable this.
+      SSL_add_application_settings(octx->ssl, alps->entries[i],
+                                   strlen(alps->entries[i]), NULL,
+                                   0);
+    }
+
+    Curl_alpn_to_proto_str(&proto, alps);
+    infof(data, VTLS_INFOF_ALPS_OFFER_1STR, proto.data);
+  }
+#endif
+
 #if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_OCSP)
   if(Curl_ssl_cf_get_primary_config(cf)->verifystatus)
     SSL_set_tlsext_status_type(octx->ssl, TLSEXT_STATUSTYPE_ocsp);
@@ -4002,6 +4362,7 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   const struct curl_blob *ssl_cert_blob = ssl_config->primary.cert_blob;
   const char * const ssl_cert_type = ssl_config->cert_type;
   const bool verifypeer = conn_config->verifypeer;
+  struct ssl_connect_data *connssl = cf->ctx;
   unsigned int ssl_version_min;
   char error_buffer[256];
 
@@ -4084,7 +4445,14 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   ctx_options = SSL_OP_ALL;
 
 #ifdef SSL_OP_NO_TICKET
-  ctx_options |= SSL_OP_NO_TICKET;
+  if(data->set.ssl_enable_ticket) {
+  /* curl-impersonate:
+   * Turn off SSL_OP_NO_TICKET, we want TLS extension 35 (session_ticket)
+   * to be present in the client hello. */
+    ctx_options &= ~SSL_OP_NO_TICKET;
+  } else {
+    ctx_options |= SSL_OP_NO_TICKET;
+  }
 #endif
 
 #ifdef SSL_OP_NO_COMPRESSION
@@ -4156,6 +4524,20 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   SSL_CTX_set_mode(octx->ssl_ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
 #endif
 
+  SSL_CTX_set_options(octx->ssl_ctx, SSL_OP_LEGACY_SERVER_CONNECT);
+  SSL_CTX_set_mode(octx->ssl_ctx,
+      SSL_MODE_CBC_RECORD_SPLITTING | SSL_MODE_ENABLE_FALSE_START);
+
+  /* curl-impersonate: Enable TLS extensions 18 - signed_certificate_timestamp. */
+  if(data->set.tls_signed_cert_timestamps) {
+    SSL_CTX_enable_signed_cert_timestamps(octx->ssl_ctx);
+  }
+
+  /* curl-impersonate: Enable TLS extensions 5 - status_request */
+  if(data->set.tls_status_request) {
+    SSL_CTX_enable_ocsp_stapling(octx->ssl_ctx);
+  }
+
   ciphers = conn_config->cipher_list;
   if(!ciphers && (peer->transport != TRNSPRT_QUIC))
     ciphers = DEFAULT_CIPHER_SELECTION;
@@ -4229,6 +4611,35 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   }
 #endif
 
+#ifdef HAVE_SSL_CTX_SET_VERIFY_ALGORITHM_PREFS
+  {
+    uint16_t algs[MAX_SIG_ALGS];
+    size_t nalgs;
+    /* curl-impersonate: Set the signature algorithms (TLS extension 13).
+     * See net/socket/ssl_client_socket_impl.cc in Chromium's source. */
+    char *sig_hash_algs = conn_config->sig_hash_algs;
+    if (sig_hash_algs) {
+      CURLcode result = parse_sig_algs(data, sig_hash_algs, algs, &nalgs);
+      if (result)
+        return result;
+      if (!SSL_CTX_set_verify_algorithm_prefs(octx->ssl_ctx, algs, nalgs)) {
+        failf(data, "failed setting signature hash algorithms list: '%s'",
+              sig_hash_algs);
+        return CURLE_SSL_CIPHER;
+      }
+    } else {
+      /* Use defaults from Chrome. */
+      if (!SSL_CTX_set_verify_algorithm_prefs(octx->ssl_ctx,
+                                              default_sig_algs,
+                                              DEFAULT_SIG_ALGS_LENGTH)) {
+        failf(data, "failed setting signature hash algorithms list: '%s'",
+              sig_hash_algs);
+        return CURLE_SSL_CIPHER;
+      }
+    }
+  }
+#endif
+
 #ifdef USE_OPENSSL_SRP
   if(ssl_config->primary.username && Curl_auth_allowed_to_host(data)) {
     char * const ssl_username = ssl_config->primary.username;
@@ -4254,6 +4665,56 @@ CURLcode Curl_ossl_ctx_init(struct ossl_ctx *octx,
   }
 #endif
 
+  /* curl-impersonate:
+   * Configure BoringSSL to behave like Chrome.
+   * See Constructor of SSLContext at net/socket/ssl_client_socket_impl.cc
+   * and SSLClientSocketImpl::Init()
+   * in the Chromium's source code. */
+
+  /* curl-impersonate: Disable TLS GREASE for HTTP/3 (QUIC). */
+  if(peer->transport == TRNSPRT_QUIC)
+    SSL_CTX_set_grease_enabled(octx->ssl_ctx, 0);
+  else if(data->set.tls_grease)
+    SSL_CTX_set_grease_enabled(octx->ssl_ctx, 1);
+
+  /*
+   * curl-impersonate: Enable TLS extension permutation, enabled by default
+   * since Chrome 110.
+   */
+  if(data->set.ssl_permute_extensions) {
+    SSL_CTX_set_permute_extensions(octx->ssl_ctx, 1);
+  }
+
+  /* curl-impersonate: Set TLS extensions order. */
+  if(data->set.str[STRING_TLS_EXTENSION_ORDER]) {
+    SSL_CTX_set_extension_order(octx->ssl_ctx, data->set.str[STRING_TLS_EXTENSION_ORDER]);
+  }
+
+  if(data->set.str[STRING_TLS_DELEGATED_CREDENTIALS]) {
+    SSL_CTX_set_delegated_credentials(octx->ssl_ctx, data->set.str[STRING_TLS_DELEGATED_CREDENTIALS]);
+  }
+
+  if(data->set.tls_record_size_limit) {
+    SSL_CTX_set_record_size_limit(octx->ssl_ctx, data->set.tls_record_size_limit);
+  }
+
+  if(data->set.tls_key_shares_limit) {
+    SSL_CTX_set_key_shares_limit(octx->ssl_ctx, data->set.tls_key_shares_limit);
+  }
+
+  // curl-impersonate: Set key usage check
+  if(data->set.tls_key_usage_no_check) {
+    SSL_CTX_set_key_usage_check_enabled(octx->ssl_ctx, 0);
+  }else{
+    SSL_CTX_set_key_usage_check_enabled(octx->ssl_ctx, 1);
+  }
+
+  if(conn_config->cert_compression &&
+     add_cert_compression(data,
+                          octx->ssl_ctx,
+                          conn_config->cert_compression))
+    return CURLE_SSL_CIPHER;
+
   /* OpenSSL always tries to verify the peer, this only says whether it should
    * fail to connect if the verification fails, or if it should continue
    * anyway. In the latter case the result of the verification is checked with
diff --git a/lib/vtls/vtls.c b/lib/vtls/vtls.c
index db4e57342e..560def5128 100644
--- a/lib/vtls/vtls.c
+++ b/lib/vtls/vtls.c
@@ -167,6 +167,17 @@ alpn_get_spec(http_majors allowed, bool use_alpn)
      Avoid "http/1.0" because some servers do not support it. */
   return &ALPN_SPEC_H11;
 }
+
+static const struct alpn_spec *alps_get_spec(int httpwant, bool use_alps)
+{
+  if(!use_alps)
+    return NULL;
+#ifdef USE_HTTP2
+  if(httpwant >= CURL_HTTP_VERSION_2)
+    return &ALPN_SPEC_H2;
+#endif
+  return NULL;
+}
 #endif /* USE_SSL */
 
 
@@ -210,6 +221,8 @@ match_ssl_primary_config(struct Curl_easy *data,
      curl_strequal(c1->cipher_list, c2->cipher_list) &&
      curl_strequal(c1->cipher_list13, c2->cipher_list13) &&
      curl_strequal(c1->curves, c2->curves) &&
+     curl_strequal(c1->sig_hash_algs, c2->sig_hash_algs) &&
+     curl_strequal(c1->cert_compression, c2->cert_compression) &&
      curl_strequal(c1->signature_algorithms, c2->signature_algorithms) &&
      curl_strequal(c1->CRLfile, c2->CRLfile) &&
      curl_strequal(c1->pinned_key, c2->pinned_key))
@@ -255,6 +268,8 @@ static bool clone_ssl_primary_config(struct ssl_primary_config *source,
   CLONE_STRING(cipher_list13);
   CLONE_STRING(pinned_key);
   CLONE_STRING(curves);
+  CLONE_STRING(sig_hash_algs);
+  CLONE_STRING(cert_compression);
   CLONE_STRING(signature_algorithms);
   CLONE_STRING(CRLfile);
 #ifdef USE_TLS_SRP
@@ -278,6 +293,8 @@ static void free_primary_ssl_config(struct ssl_primary_config *sslc)
   Curl_safefree(sslc->ca_info_blob);
   Curl_safefree(sslc->issuercert_blob);
   Curl_safefree(sslc->curves);
+  Curl_safefree(sslc->sig_hash_algs);
+  Curl_safefree(sslc->cert_compression);
   Curl_safefree(sslc->signature_algorithms);
   Curl_safefree(sslc->CRLfile);
 #ifdef USE_TLS_SRP
@@ -304,6 +321,8 @@ CURLcode Curl_ssl_easy_config_complete(struct Curl_easy *data)
   data->set.ssl.primary.cert_blob = data->set.blobs[BLOB_CERT];
   data->set.ssl.primary.ca_info_blob = data->set.blobs[BLOB_CAINFO];
   data->set.ssl.primary.curves = data->set.str[STRING_SSL_EC_CURVES];
+  data->set.ssl.primary.sig_hash_algs = data->set.str[STRING_SSL_SIG_HASH_ALGS];
+  data->set.ssl.primary.cert_compression = data->set.str[STRING_SSL_CERT_COMPRESSION];
 #ifdef USE_TLS_SRP
   data->set.ssl.primary.username = data->set.str[STRING_TLSAUTH_USERNAME];
   data->set.ssl.primary.password = data->set.str[STRING_TLSAUTH_PASSWORD];
@@ -455,7 +474,8 @@ static bool ssl_prefs_check(struct Curl_easy *data)
 }
 
 static struct ssl_connect_data *cf_ctx_new(struct Curl_easy *data,
-                                           const struct alpn_spec *alpn)
+                                           const struct alpn_spec *alpn,
+                                           const struct alpn_spec *alps)
 {
   struct ssl_connect_data *ctx;
 
@@ -466,6 +486,7 @@ static struct ssl_connect_data *cf_ctx_new(struct Curl_easy *data,
 
   ctx->ssl_impl = Curl_ssl;
   ctx->alpn = alpn;
+  ctx->alps = alps;
   Curl_bufq_init2(&ctx->earlydata, CURL_SSL_EARLY_MAX, 1, BUFQ_OPT_NO_SPARES);
   ctx->backend = calloc(1, ctx->ssl_impl->sizeof_ssl_backend_data);
   if(!ctx->backend) {
@@ -1644,9 +1665,10 @@ static CURLcode cf_ssl_create(struct Curl_cfilter **pcf,
   DEBUGASSERT(!conn->bits.tls_enable_alpn);
   ctx = cf_ctx_new(data, NULL);
 #else
-  ctx = cf_ctx_new(data, alpn_get_spec(data->state.http_neg.wanted,
-                                       conn->bits.tls_enable_alpn));
+  ctx = cf_ctx_new(data, alpn_get_spec(data->state.http_neg.wanted, conn->bits.tls_enable_alpn),
+                   alps_get_spec(data->state.http_neg.wanted, conn->bits.tls_enable_alps));
 #endif
+
   if(!ctx) {
     result = CURLE_OUT_OF_MEMORY;
     goto out;
@@ -1696,6 +1718,7 @@ static CURLcode cf_ssl_proxy_create(struct Curl_cfilter **pcf,
   struct ssl_connect_data *ctx;
   CURLcode result;
   bool use_alpn = conn->bits.tls_enable_alpn;
+  bool use_alps = conn->bits.tls_enable_alps;
   http_majors allowed = CURL_HTTP_V1x;
 
 #ifdef USE_HTTP2
@@ -1705,7 +1728,8 @@ static CURLcode cf_ssl_proxy_create(struct Curl_cfilter **pcf,
   }
 #endif
 
-  ctx = cf_ctx_new(data, alpn_get_spec(allowed, use_alpn));
+  ctx = cf_ctx_new(data, alpn_get_spec(allowed, use_alpn),
+                   alps_get_spec(allowed, use_alps));
   if(!ctx) {
     result = CURLE_OUT_OF_MEMORY;
     goto out;
diff --git a/lib/vtls/vtls.h b/lib/vtls/vtls.h
index c62b8ae258..1ae8d6b275 100644
--- a/lib/vtls/vtls.h
+++ b/lib/vtls/vtls.h
@@ -58,6 +58,8 @@ struct dynbuf;
   "ALPN: server did not agree on a protocol. Uses default."
 #define VTLS_INFOF_ALPN_OFFER_1STR    \
   "ALPN: curl offers %s"
+#define VTLS_INFOF_ALPS_OFFER_1STR    \
+  "ALPS: offers %s"
 #define VTLS_INFOF_ALPN_ACCEPTED      \
   ALPN_ACCEPTED "%.*s"
 
diff --git a/lib/vtls/vtls_int.h b/lib/vtls/vtls_int.h
index 11987c382a..9be95ab36c 100644
--- a/lib/vtls/vtls_int.h
+++ b/lib/vtls/vtls_int.h
@@ -110,6 +110,7 @@ struct ssl_connect_data {
   const struct Curl_ssl *ssl_impl;  /* TLS backend for this filter */
   struct ssl_peer peer;             /* peer the filter talks to */
   const struct alpn_spec *alpn;     /* ALPN to use or NULL for none */
+  const struct alpn_spec *alps;     /* ALPS to use or NULL for none */
   void *backend;                    /* vtls backend specific props */
   struct cf_call_data call_data;    /* data handle used in current call */
   struct curltime handshake_done;   /* time when handshake finished */
diff --git a/lib/vtls/vtls_scache.c b/lib/vtls/vtls_scache.c
index 662539cd89..29f545c69e 100644
--- a/lib/vtls/vtls_scache.c
+++ b/lib/vtls/vtls_scache.c
@@ -533,6 +533,48 @@ CURLcode Curl_ssl_peer_key_make(struct Curl_cfilter *cf,
     if(r)
       goto out;
   }
+#ifndef CURL_DISABLE_PROXY
+  // make sure SSL sessions started by one proxy are not resumed from a different one
+  if(cf->conn->bits.proxy && cf->conn->bits.proxy_credential_no_reuse) {
+    const char *proxy_type = NULL;
+    const struct proxy_info *p_info = NULL;
+
+    if(cf->conn->bits.httpproxy) {
+      proxy_type = "HTTP";
+      p_info = &cf->conn->http_proxy;
+    }
+    else if(cf->conn->bits.socksproxy) {
+      proxy_type = "SOCKS";
+      p_info = &cf->conn->socks_proxy;
+    }
+
+    if(p_info) {
+      r = curlx_dyn_addf(&buf, ":PTYPE-%s", proxy_type);
+      if(r)
+        goto out;
+      if(p_info->host.name) {
+        r = curlx_dyn_addf(&buf, ":PHOST-%s", p_info->host.name);
+        if(r)
+          goto out;
+      }
+      r = curlx_dyn_addf(&buf, ":PPORT-%d", (int)p_info->port);
+      if(r)
+        goto out;
+      if(p_info->user) {
+        r = curlx_dyn_addf(&buf, ":PUSER-%s", p_info->user);
+        if(r)
+          goto out;
+      }
+      if(p_info->passwd) {
+        // password should not be shared among users. but authless vs auth
+        // proxy should be treated separately.
+        r = curlx_dyn_add(&buf, ":PPW");
+        if(r)
+          goto out;
+      }
+    }
+  }
+#endif
   if(ssl->verifypeer) {
     r = cf_ssl_peer_key_add_path(&buf, "CA", ssl->CAfile, &is_local);
     if(r)
diff --git a/lib/ws.c b/lib/ws.c
index 7f8a688ca1..ab34231bcc 100644
--- a/lib/ws.c
+++ b/lib/ws.c
@@ -1587,7 +1587,7 @@ const struct Curl_handler Curl_handler_wss = {
   CURLPROTO_WSS,                        /* protocol */
   CURLPROTO_HTTP,                       /* family */
   PROTOPT_SSL | PROTOPT_CREDSPERREQUEST | /* flags */
-  PROTOPT_USERPWDCTRL
+  PROTOPT_USERPWDCTRL | PROTOPT_ALPN
 };
 #endif
 
diff --git a/libcurl.pc.in b/libcurl.pc.in
index c0ba5244a8..b5e9cb4eed 100644
--- a/libcurl.pc.in
+++ b/libcurl.pc.in
@@ -35,7 +35,7 @@ Description: Library to transfer files with HTTP, FTP, etc.
 Version: @CURLVERSION@
 Requires: @LIBCURL_PC_REQUIRES@
 Requires.private: @LIBCURL_PC_REQUIRES_PRIVATE@
-Libs: -L${libdir} -lcurl @LIBCURL_PC_LIBS@
+Libs: -L${libdir} -lcurl-impersonate @LIBCURL_PC_LIBS@
 Libs.private: @LIBCURL_PC_LDFLAGS_PRIVATE@ @LIBCURL_PC_LIBS_PRIVATE@
 Cflags: -I${includedir} @LIBCURL_PC_CFLAGS@
 Cflags.private: @LIBCURL_PC_CFLAGS_PRIVATE@
diff --git a/m4/curl-compilers.m4 b/m4/curl-compilers.m4
index dc6d3aa4cf..94778e4218 100644
--- a/m4/curl-compilers.m4
+++ b/m4/curl-compilers.m4
@@ -393,42 +393,55 @@ AC_DEFUN([CURL_CONVERT_INCLUDE_TO_ISYSTEM], [
   AC_REQUIRE([CURL_SHFUNC_SQUEEZE])dnl
   AC_REQUIRE([CURL_CHECK_COMPILER])dnl
   AC_MSG_CHECKING([convert -I options to -isystem])
-  if test "$compiler_id" = "GNU_C" ||
-    test "$compiler_id" = "CLANG" -o "$compiler_id" = "APPLECLANG"; then
-    AC_MSG_RESULT([yes])
-    tmp_has_include="no"
-    tmp_chg_FLAGS="$CFLAGS"
-    for word1 in $tmp_chg_FLAGS; do
-      case "$word1" in
-        -I*)
-          tmp_has_include="yes"
-          ;;
-      esac
-    done
-    if test "$tmp_has_include" = "yes"; then
-      tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/^-I/ -isystem /g'`
-      tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/ -I/ -isystem /g'`
-      CFLAGS="$tmp_chg_FLAGS"
-      squeeze CFLAGS
-    fi
-    tmp_has_include="no"
-    tmp_chg_FLAGS="$CPPFLAGS"
-    for word1 in $tmp_chg_FLAGS; do
-      case "$word1" in
-        -I*)
-          tmp_has_include="yes"
-          ;;
-      esac
-    done
-    if test "$tmp_has_include" = "yes"; then
-      tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/^-I/ -isystem /g'`
-      tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/ -I/ -isystem /g'`
-      CPPFLAGS="$tmp_chg_FLAGS"
-      squeeze CPPFLAGS
-    fi
-  else
+  case $host_os in
+  darwin*)
+    dnl curl-impersonate: On macos, clang gives priority to /usr/local/include
+    dnl over locations specified with -isystem for some unknown reason. In turn
+    dnl this causes clang to use the system's openssl, which conflicts with
+    dnl curl-impersonate's boringssl headers.
+    dnl To prevent that, disable curl's automatic conversion of -I flags to
+    dnl -isystem.
     AC_MSG_RESULT([no])
-  fi
+    ;;
+  *)
+    if test "$compiler_id" = "GNU_C" ||
+      test "$compiler_id" = "CLANG"; then
+      AC_MSG_RESULT([yes])
+      tmp_has_include="no"
+      tmp_chg_FLAGS="$CFLAGS"
+      for word1 in $tmp_chg_FLAGS; do
+        case "$word1" in
+          -I*)
+            tmp_has_include="yes"
+            ;;
+        esac
+      done
+      if test "$tmp_has_include" = "yes"; then
+        tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/^-I/ -isystem /g'`
+        tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/ -I/ -isystem /g'`
+        CFLAGS="$tmp_chg_FLAGS"
+        squeeze CFLAGS
+      fi
+      tmp_has_include="no"
+      tmp_chg_FLAGS="$CPPFLAGS"
+      for word1 in $tmp_chg_FLAGS; do
+        case "$word1" in
+          -I*)
+            tmp_has_include="yes"
+            ;;
+        esac
+      done
+      if test "$tmp_has_include" = "yes"; then
+        tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/^-I/ -isystem /g'`
+        tmp_chg_FLAGS=`echo "$tmp_chg_FLAGS" | "$SED" 's/ -I/ -isystem /g'`
+        CPPFLAGS="$tmp_chg_FLAGS"
+        squeeze CPPFLAGS
+      fi
+    else
+      AC_MSG_RESULT([no])
+    fi
+    ;;
+  esac
 ])
 
 
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
index 2c98aac9f7..59a14546f2 100644
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -25,9 +25,15 @@
 EXTRA_DIST = coverage.sh completion.pl firefox-db2pem.sh checksrc.pl checksrc-all.pl \
   mk-ca-bundle.pl mk-unity.pl schemetable.c cd2nroff nroff2cd cdall cd2cd managen    \
   dmaketgz maketgz release-tools.sh verify-release cmakelint.sh mdlinkcheck          \
-  CMakeLists.txt pythonlint.sh randdisable wcurl top-complexity extract-unit-protos
+  CMakeLists.txt pythonlint.sh randdisable wcurl-impersonate top-complexity          \
+  extract-unit-protos
 
-dist_bin_SCRIPTS = wcurl
+dist_bin_SCRIPTS = wcurl-impersonate
+
+wcurl-impersonate: $(srcdir)/wcurl-impersonate
+	if test "x$(srcdir)" != "x."; then \
+	  cp -f "$(srcdir)/wcurl-impersonate" "$@"; \
+	fi
 
 ZSH_FUNCTIONS_DIR = @ZSH_FUNCTIONS_DIR@
 FISH_FUNCTIONS_DIR = @FISH_FUNCTIONS_DIR@
diff --git a/scripts/singleuse.pl b/scripts/singleuse.pl
index b6ec18b47f..0606f50eb3 100755
--- a/scripts/singleuse.pl
+++ b/scripts/singleuse.pl
@@ -57,6 +57,7 @@ my %api = (
     'curl_easy_escape' => 'API',
     'curl_easy_getinfo' => 'API',
     'curl_easy_init' => 'API',
+    'curl_easy_impersonate' => 'API',
     'curl_easy_pause' => 'API',
     'curl_easy_perform' => 'API',
     'curl_easy_recv' => 'API',
diff --git a/scripts/wcurl b/scripts/wcurl-impersonate
old mode 100755
new mode 100644
similarity index 87%
rename from scripts/wcurl
rename to scripts/wcurl-impersonate
index af66ae7fca..b69d2cbb7a
--- a/scripts/wcurl
+++ b/scripts/wcurl-impersonate
@@ -1,8 +1,9 @@
 #!/bin/sh
 
-# wcurl - a simple wrapper around curl to easily download files.
+# wcurl-impersonate - a simple wrapper around curl-impersonate to easily
+# download files.
 #
-# Requires curl >= 7.46.0 (2015)
+# Requires curl-impersonate >= 7.46.0 (2015)
 #
 # Copyright (C) Samuel Henrique <samueloph@debian.org>, Sergio Durigan
 # Junior <sergiodj@debian.org> and many contributors, see the AUTHORS
@@ -46,7 +47,7 @@ _EOF_
 usage()
 {
     cat << _EOF_
-${PROGRAM_NAME} -- a simple wrapper around curl to easily download files.
+${PROGRAM_NAME} -- a simple wrapper around curl-impersonate to easily download files.
 
 Usage: ${PROGRAM_NAME} <URL>...
        ${PROGRAM_NAME} [--curl-options <CURL_OPTIONS>]... [--no-decode-filename] [-o|-O|--output <PATH>] [--dry-run] [--] <URL>...
@@ -56,29 +57,33 @@ Usage: ${PROGRAM_NAME} <URL>...
 
 Options:
 
-  --curl-options <CURL_OPTIONS>: Specify extra options to be passed when invoking curl. May be
-                                 specified more than once.
+  --curl-options <CURL_OPTIONS>: Specify extra options to be passed when invoking
+                                 curl-impersonate. May be specified more than once.
 
   -o, -O, --output <PATH>: Use the provided output path instead of getting it from the URL. If
                            multiple URLs are provided, resulting files share the same name with a
-                           number appended to the end (curl >= 7.83.0). If this option is provided
-                           multiple times, only the last value is considered.
+                           number appended to the end (curl-impersonate >= 7.83.0).
+                           If this option is provided multiple times, only the last
+                           value is considered.
 
-  --no-decode-filename: Don't percent-decode the output filename, even if the percent-encoding in
-                        the URL was done by wcurl, e.g.: The URL contained whitespaces.
+  --no-decode-filename: Don't percent-decode the output filename, even if the
+                        percent-encoding in the URL was done by
+                        ${PROGRAM_NAME}, e.g.: The URL contained whitespaces.
 
-  --dry-run: Don't actually execute curl, just print what would be invoked.
+  --dry-run: Don't actually execute curl-impersonate, just print what would be invoked.
 
   -V, --version: Print version information.
 
   -h, --help: Print this usage message.
 
-  <CURL_OPTIONS>: Any option supported by curl can be set here. This is not used by wcurl; it is
-                 instead forwarded to the curl invocation.
+  <CURL_OPTIONS>: Any option supported by curl-impersonate can be set here. This
+                 is not used by ${PROGRAM_NAME}; it is instead forwarded to the
+                 curl-impersonate invocation.
 
   <URL>: URL to be downloaded. Anything that is not a parameter is considered
-         an URL. Whitespaces are percent-encoded and the URL is passed to curl, which
-         then performs the parsing. May be specified more than once.
+         an URL. Whitespaces are percent-encoded and the URL is passed to
+         curl-impersonate, which then performs the parsing. May be specified
+         more than once.
 _EOF_
 }
 
@@ -89,7 +94,7 @@ error()
     exit 1
 }
 
-# Extra curl options provided by the user.
+# Extra curl-impersonate options provided by the user.
 # This is set per-URL for every URL provided.
 # Some options are global, but we are erroring on the side of needlesly setting
 # them multiple times instead of causing issues with parameters that needs to
@@ -104,7 +109,7 @@ URLS=""
 OUTPUT_PATH=""
 HAS_USER_SET_OUTPUT="false"
 
-# The parameters that are passed per-URL to curl.
+# The parameters that are passed per-URL to curl-impersonate.
 readonly PER_URL_PARAMETERS="\
     --fail \
     --globoff \
@@ -113,7 +118,7 @@ readonly PER_URL_PARAMETERS="\
     --remote-time \
     --retry 5 "
 
-# Whether to invoke curl or not.
+# Whether to invoke curl-impersonate or not.
 DRY_RUN="false"
 
 # Sanitize parameters.
@@ -176,10 +181,10 @@ get_url_filename()
     # No slash means there was just a hostname and no path; return empty string.
 }
 
-# Execute curl with the list of URLs provided by the user.
+# Execute curl-impersonate with the list of URLs provided by the user.
 exec_curl()
 {
-    CMD="curl "
+    CMD="curl-impersonate "
 
     # Store version to check if it supports --no-clobber and --parallel.
     curl_version=$($CMD --version | cut -f2 -d' ' | head -n1)
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 798fab483b..28c41b2e22 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -21,7 +21,7 @@
 # SPDX-License-Identifier: curl
 #
 ###########################################################################
-set(EXE_NAME curl)
+set(EXE_NAME curl-impersonate)
 set_property(DIRECTORY APPEND PROPERTY COMPILE_DEFINITIONS "${CURL_DEBUG_MACROS}")
 
 set(_curl_cfiles_gen "")
diff --git a/src/Makefile.am b/src/Makefile.am
index 78e2f81243..6cff00a82f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -46,7 +46,7 @@ AM_CPPFLAGS = -I$(top_srcdir)/include        \
               -I$(top_srcdir)/lib            \
               -I$(srcdir)
 
-bin_PROGRAMS = curl
+bin_PROGRAMS = curl-impersonate
 
 curlinfo_SOURCES = curlinfo.c
 noinst_PROGRAMS = curlinfo
@@ -83,18 +83,18 @@ if USE_UNITY
 curltool_unity.c: $(top_srcdir)/scripts/mk-unity.pl $(CURL_CFILES) $(curl_cfiles_gen) $(curlx_csrc)
 	@PERL@ $(top_srcdir)/scripts/mk-unity.pl --include $(CURL_CFILES) $(curl_cfiles_gen) $(curlx_csrc) > curltool_unity.c
 
-nodist_curl_SOURCES = curltool_unity.c
-curl_SOURCES =
+nodist_curl_impersonate_SOURCES = curltool_unity.c
+curl_impersonate_SOURCES =
 CLEANFILES += curltool_unity.c
 else
-curl_SOURCES = $(CURL_CFILES) $(CURL_HFILES) $(curl_cfiles_gen) $(curl_hfiles_gen) $(curlx_csrc) $(curlx_hsrc)
+curl_impersonate_SOURCES = $(CURL_CFILES) $(CURL_HFILES) $(curl_cfiles_gen) $(curl_hfiles_gen) $(curlx_csrc) $(curlx_hsrc)
 endif
 if HAVE_WINDRES
-curl_SOURCES += $(CURL_RCFILES)
+curl_impersonate_SOURCES += $(CURL_RCFILES)
 $(CURL_RCFILES): tool_version.h
 endif
 
-curl_LDFLAGS = $(AM_LDFLAGS) $(CURL_LDFLAGS_BIN) $(UNICODEFLAG)
+curl_impersonate_LDFLAGS = $(AM_LDFLAGS) $(CURL_LDFLAGS_BIN) $(UNICODEFLAG)
 
 # This might hold -Werror
 CFLAGS += @CURL_CFLAG_EXTRAS@
@@ -102,7 +102,7 @@ CFLAGS += @CURL_CFLAG_EXTRAS@
 # Prevent LIBS from being used for all link targets
 LIBS = $(BLANK_AT_MAKETIME)
 
-curl_LDADD = $(top_builddir)/lib/libcurl.la @LIBCURL_PC_LIBS_PRIVATE@
+curl_impersonate_LDADD = $(top_builddir)/lib/libcurl-impersonate.la @LIBCURL_PC_LIBS_PRIVATE@
 
 # if unit tests are enabled, build a static library to link them with
 if BUILD_UNITTESTS
diff --git a/src/config2setopts.c b/src/config2setopts.c
index 8e4af65bae..02a05bf56c 100644
--- a/src/config2setopts.c
+++ b/src/config2setopts.c
@@ -418,6 +418,51 @@ static CURLcode ssl_setopts(struct OperationConfig *config, CURL *curl)
             "--proxy-tls13-ciphers", ssl_backend());
   }
 
+  /* curl-impersonate */
+  if(config->ssl_sig_hash_algs)
+    my_setopt_str(curl, CURLOPT_SSL_SIG_HASH_ALGS,
+                  config->ssl_sig_hash_algs);
+
+  if(config->ssl_cert_compression)
+    my_setopt_str(curl, CURLOPT_SSL_CERT_COMPRESSION,
+                  config->ssl_cert_compression);
+
+  if(config->ssl_permute_extensions)
+    my_setopt(curl, CURLOPT_SSL_PERMUTE_EXTENSIONS, 1L);
+
+  if(config->tls_grease)
+    my_setopt(curl, CURLOPT_TLS_GREASE, 1L);
+
+  if(config->tls_extension_order)
+    my_setopt_str(curl, CURLOPT_TLS_EXTENSION_ORDER, config->tls_extension_order);
+
+  if (config->tls_use_new_alps_codepoint)
+    my_setopt(curl, CURLOPT_TLS_USE_NEW_ALPS_CODEPOINT, 1L);
+
+  if(config->tls_delegated_credentials)
+    my_setopt_str(curl, CURLOPT_TLS_DELEGATED_CREDENTIALS, config->tls_delegated_credentials);
+ 
+  if(config->tls_record_size_limit)
+    my_setopt(curl, CURLOPT_TLS_RECORD_SIZE_LIMIT, config->tls_record_size_limit);
+ 
+  if(config->tls_key_shares_limit)
+    my_setopt(curl, CURLOPT_TLS_KEY_SHARES_LIMIT, config->tls_key_shares_limit);
+
+  if(config->alps) {
+    my_setopt(curl, CURLOPT_SSL_ENABLE_ALPS, 1L);
+  }
+
+  if (config->noticket) {
+    my_setopt(curl, CURLOPT_SSL_ENABLE_TICKET, 0L);
+  }
+
+  if(config->tls_signed_cert_timestamps) {
+    my_setopt(curl, CURLOPT_TLS_SIGNED_CERT_TIMESTAMPS, 1L);
+  }
+
+  my_setopt(curl, CURLOPT_TLS_STATUS_REQUEST, 1L);
+  /* end of curl-impersonate */
+
   /* curl 7.16.0 */
   if(config->disable_sessionid)
     /* disable it */
@@ -509,6 +554,58 @@ static CURLcode http_setopts(struct OperationConfig *config,
   if(config->hsts)
     my_setopt_str(curl, CURLOPT_HSTS, config->hsts);
 
+  /* curl-impersonate */
+  if(config->http2_no_priority)
+    my_setopt(curl,
+              CURLOPT_HTTP2_NO_PRIORITY,
+              config->http2_no_priority);
+
+  if(config->http2_pseudo_headers_order)
+    my_setopt_str(curl,
+                  CURLOPT_HTTP2_PSEUDO_HEADERS_ORDER,
+                  config->http2_pseudo_headers_order);
+
+  if(config->http2_settings)
+    my_setopt_str(curl,
+                  CURLOPT_HTTP2_SETTINGS,
+                  config->http2_settings);
+
+  if(config->http2_window_update)
+    my_setopt(curl,
+              CURLOPT_HTTP2_WINDOW_UPDATE,
+              config->http2_window_update);
+
+  if(config->http2_stream_exclusive)
+    my_setopt(curl,
+              CURLOPT_STREAM_EXCLUSIVE,
+              config->http2_stream_exclusive);
+
+  if(config->http2_stream_weight)
+    my_setopt(curl,
+              CURLOPT_STREAM_WEIGHT,
+              config->http2_stream_weight);
+
+  if(config->http2_streams)
+    my_setopt_str(curl,
+                  CURLOPT_HTTP2_STREAMS,
+                  config->http2_streams);
+
+  if(config->http3_pseudo_headers_order)
+    my_setopt_str(curl,
+                  CURLOPT_HTTP3_PSEUDO_HEADERS_ORDER,
+                  config->http3_pseudo_headers_order);
+
+  if(config->http3_settings)
+    my_setopt_str(curl,
+                  CURLOPT_HTTP3_SETTINGS,
+                  config->http3_settings);
+
+  if(config->quic_transport_parameters)
+    my_setopt_str(curl,
+                  CURLOPT_QUIC_TRANSPORT_PARAMETERS,
+                  config->quic_transport_parameters);
+  /* end of curl-impersonate */
+
   /* new in 7.47.0 */
   if(config->expect100timeout_ms > 0)
     my_setopt_long(curl, CURLOPT_EXPECT_100_TIMEOUT_MS,
@@ -558,6 +655,7 @@ static CURLcode cookie_setopts(struct OperationConfig *config, CURL *curl)
 
   /* new in libcurl 7.9.7 */
   my_setopt_long(curl, CURLOPT_COOKIESESSION, config->cookiesession);
+  my_setopt_long(curl, CURLOPT_SPLIT_COOKIES, config->split_cookies);
 
   return result;
 }
@@ -732,6 +830,12 @@ static CURLcode proxy_setopts(struct OperationConfig *config, CURL *curl)
   if(config->haproxy_clientip)
     my_setopt_str(curl, CURLOPT_HAPROXY_CLIENT_IP, config->haproxy_clientip);
 
+
+  /* curl-impersonate */
+  if (config->proxy_credential_no_reuse) {
+    my_setopt(curl, CURLOPT_PROXY_CREDENTIAL_NO_REUSE, 1L);
+  }
+
   return CURLE_OK;
 }
 
@@ -1117,5 +1221,30 @@ CURLcode config2setopts(struct OperationConfig *config,
   /* new in 8.13.0 */
   if(config->upload_flags)
     my_setopt_long(curl, CURLOPT_UPLOAD_FLAGS, config->upload_flags);
+
+  /* curl-impersonate */
+  if(config->impersonate) {
+    result = my_setopt_str(curl, CURLOPT_IMPERSONATE, config->impersonate);
+    if(result)
+      return result;
+
+    if(use_proto == proto_http || use_proto == proto_https) {
+      /* Let explicit --http* selections override impersonation defaults. */
+      if(config->httpversion)
+        my_setopt_enum(curl, CURLOPT_HTTP_VERSION, config->httpversion);
+
+      /* Let explicit TLS version selections override impersonation defaults.
+         For explicit HTTP/3 requests, require TLS >= 1.3 unless the user
+         supplied an explicit TLS version constraint. */
+      if(config->ssl_version || config->ssl_version_max)
+        my_setopt_SSLVERSION(curl, CURLOPT_SSLVERSION,
+                             config->ssl_version | config->ssl_version_max);
+      else if(config->httpversion == CURL_HTTP_VERSION_3 ||
+              config->httpversion == CURL_HTTP_VERSION_3ONLY)
+        my_setopt_SSLVERSION(curl, CURLOPT_SSLVERSION,
+                             CURL_SSLVERSION_TLSv1_3);
+    }
+  }
+
   return result;
 }
diff --git a/src/tool_cfgable.c b/src/tool_cfgable.c
index 975ef2a458..109751d020 100644
--- a/src/tool_cfgable.c
+++ b/src/tool_cfgable.c
@@ -101,6 +101,18 @@ static void free_config_fields(struct OperationConfig *config)
   tool_safefree(config->proto_str);
   tool_safefree(config->proto_redir_str);
 
+  // curl-impersonate
+  tool_safefree(config->ssl_sig_hash_algs);
+  tool_safefree(config->ssl_cert_compression);
+  tool_safefree(config->http2_pseudo_headers_order);
+  tool_safefree(config->http2_settings);
+  tool_safefree(config->http2_streams);
+  tool_safefree(config->http3_pseudo_headers_order);
+  tool_safefree(config->http3_settings);
+  tool_safefree(config->quic_transport_parameters);
+  tool_safefree(config->tls_extension_order);
+  tool_safefree(config->impersonate);
+
   urlnode = config->url_list;
   while(urlnode) {
     struct getout *next = urlnode->next;
diff --git a/src/tool_cfgable.h b/src/tool_cfgable.h
index 62ca06ad1e..069328d7fa 100644
--- a/src/tool_cfgable.h
+++ b/src/tool_cfgable.h
@@ -151,6 +151,7 @@ struct OperationConfig {
   char *proxy_key_type;
   char *key_passwd;
   char *proxy_key_passwd;
+  bool proxy_credential_no_reuse;
   char *pubkey;
   char *hostpubmd5;
   char *hostpubsha256;
@@ -159,13 +160,33 @@ struct OperationConfig {
   char *etag_compare_file;
   char *customrequest;
   char *ssl_ec_curves;
+  char *ssl_cert_compression;
+  char *ssl_sig_hash_algs;
   char *ssl_signature_algorithms;
   char *krblevel;
   char *request_target;
+  char *http2_pseudo_headers_order;
+  char *http2_settings;
+  long http2_window_update;
+  long http2_stream_weight;
+  long http2_stream_exclusive;
+  char *http2_streams;
+  char *http3_pseudo_headers_order;
+  char *http3_settings;
+  char *quic_transport_parameters;
+  char *impersonate;
+  bool http2_no_priority;
+  bool tls_grease;
+  char *tls_extension_order;
+  char *tls_delegated_credentials;
+  long tls_record_size_limit;
+  long tls_key_shares_limit;
+  bool tls_use_new_alps_codepoint;
   char *writeout;           /* %-styled format string to output */
   struct curl_slist *quote;
   struct curl_slist *postquote;
   struct curl_slist *prequote;
+  bool ssl_permute_extensions;
   struct curl_slist *headers;
   struct curl_slist *proxyheaders;
   struct tool_mime *mimeroot;
@@ -222,6 +243,9 @@ struct OperationConfig {
   long alivetime;           /* keepalive-time */
   long alivecnt;            /* keepalive-cnt */
   long gssapi_delegation;
+  bool alps;                      /* enable/disable TLS ALPS extension */
+  bool noticket;                  /* enable/disable TLS session ticket */
+  bool tls_signed_cert_timestamps;    /* curl-impersonate: enable extension 18 */
   long expect100timeout_ms;
   long happy_eyeballs_timeout_ms; /* happy eyeballs timeout in milliseconds.
                                      0 is valid. default: CURL_HET_DEFAULT. */
@@ -244,6 +268,7 @@ struct OperationConfig {
   BIT(remote_name_all);   /* --remote-name-all */
   BIT(remote_time);
   BIT(cookiesession);       /* new session? */
+  BIT(split_cookies);       /* split cookies into separate Cookie headers */
   BIT(encoding);            /* Accept-Encoding please */
   BIT(tr_encoding);         /* Transfer-Encoding please */
   BIT(use_resume);
diff --git a/src/tool_getparam.c b/src/tool_getparam.c
index 4766dade2f..d17d591045 100644
--- a/src/tool_getparam.c
+++ b/src/tool_getparam.c
@@ -85,6 +85,7 @@ static ParameterError getstrn(char **str, const char *val,
 static const struct LongShort aliases[]= {
   {"abstract-unix-socket",       ARG_FILE, ' ', C_ABSTRACT_UNIX_SOCKET},
   {"alpn",                       ARG_BOOL|ARG_NO|ARG_TLS, ' ', C_ALPN},
+  {"alps",                       ARG_BOOL, ' ', C_ALPS},  // curl-impersonate
   {"alt-svc",                    ARG_STRG, ' ', C_ALT_SVC},
   {"anyauth",                    ARG_NONE, ' ', C_ANYAUTH},
   {"append",                     ARG_BOOL, 'a', C_APPEND},
@@ -95,6 +96,7 @@ static const struct LongShort aliases[]= {
   {"cacert",                     ARG_FILE|ARG_TLS, ' ', C_CACERT},
   {"capath",                     ARG_FILE|ARG_TLS, ' ', C_CAPATH},
   {"cert",                       ARG_FILE|ARG_TLS|ARG_CLEAR, 'E', C_CERT},
+  {"cert-compression",           ARG_STRG|ARG_TLS, ' ', C_CERT_COMPRESSION},  // curl-impersonate
   {"cert-status",                ARG_BOOL|ARG_TLS, ' ', C_CERT_STATUS},
   {"cert-type",                  ARG_STRG|ARG_TLS, ' ', C_CERT_TYPE},
   {"ciphers",                    ARG_STRG|ARG_TLS, ' ', C_CIPHERS},
@@ -175,10 +177,20 @@ static const struct LongShort aliases[]= {
   {"http1.0",                    ARG_NONE, '0', C_HTTP1_0},
   {"http1.1",                    ARG_NONE, ' ', C_HTTP1_1},
   {"http2",                      ARG_NONE, ' ', C_HTTP2},
+  {"http2-no-priority",          ARG_BOOL, ' ', C_HTTP2_NO_PRIORITY},  // curl-impersonate
   {"http2-prior-knowledge",      ARG_NONE, ' ', C_HTTP2_PRIOR_KNOWLEDGE},
+  {"http2-pseudo-headers-order", ARG_STRG, ' ', C_HTTP2_PSEUDO_HEADERS_ORDER},  // curl-impersonate
+  {"http2-settings",             ARG_STRG, ' ', C_HTTP2_SETTINGS},  // curl-impersonate
+  {"http2-stream-exclusive",     ARG_STRG, ' ', C_HTTP2_STREAM_EXCLUSIVE},  // curl-impersonate
+  {"http2-stream-weight",        ARG_STRG, ' ', C_HTTP2_STREAM_WEIGHT},  // curl-impersonate
+  {"http2-streams",              ARG_STRG, ' ', C_HTTP2_STREAMS},  // curl-impersonate
+  {"http2-window-update",        ARG_STRG, ' ', C_HTTP2_WINDOW_UPDATE},  // curl-impersonate
   {"http3",                      ARG_NONE|ARG_TLS, ' ', C_HTTP3},
   {"http3-only",                 ARG_NONE|ARG_TLS, ' ', C_HTTP3_ONLY},
+  {"http3-pseudo-headers-order", ARG_STRG, ' ', C_HTTP3_PSEUDO_HEADERS_ORDER},  // curl-impersonate
+  {"http3-settings",             ARG_STRG, ' ', C_HTTP3_SETTINGS},  // curl-impersonate
   {"ignore-content-length",      ARG_BOOL, ' ', C_IGNORE_CONTENT_LENGTH},
+  {"impersonate",                ARG_STRG, ' ', C_IMPERSONATE},
   {"include",                    ARG_BOOL, ' ', C_INCLUDE},
   {"insecure",                   ARG_BOOL, 'k', C_INSECURE},
   {"interface",                  ARG_STRG, ' ', C_INTERFACE},
@@ -250,6 +262,7 @@ static const struct LongShort aliases[]= {
   {"proxy-cert",                ARG_FILE|ARG_TLS|ARG_CLEAR, ' ', C_PROXY_CERT},
   {"proxy-cert-type",            ARG_STRG|ARG_TLS, ' ', C_PROXY_CERT_TYPE},
   {"proxy-ciphers",              ARG_STRG|ARG_TLS, ' ', C_PROXY_CIPHERS},
+  {"proxy-credential-no-reuse",  ARG_BOOL|ARG_TLS, ' ', C_PROXY_CREDENTIAL_NO_REUSE},
   {"proxy-crlfile",              ARG_FILE|ARG_TLS, ' ', C_PROXY_CRLFILE},
   {"proxy-digest",               ARG_BOOL, ' ', C_PROXY_DIGEST},
   {"proxy-header",               ARG_STRG, ' ', C_PROXY_HEADER},
@@ -275,6 +288,7 @@ static const struct LongShort aliases[]= {
   {"proxy1.0",                   ARG_STRG, ' ', C_PROXY1_0},
   {"proxytunnel",                ARG_BOOL, 'p', C_PROXYTUNNEL},
   {"pubkey",                     ARG_STRG, ' ', C_PUBKEY},
+  {"quic-transport-params",      ARG_STRG|ARG_TLS, ' ', C_QUIC_TRANSPORT_PARAMETERS},  // curl-impersonate
   {"quote",                      ARG_STRG, 'Q', C_QUOTE},
   {"random-file",                ARG_FILE|ARG_DEPR, ' ', C_RANDOM_FILE},
   {"range",                      ARG_STRG, 'r', C_RANGE},
@@ -300,8 +314,8 @@ static const struct LongShort aliases[]= {
   {"sessionid",                  ARG_BOOL|ARG_NO, ' ', C_SESSIONID},
   {"show-error",                 ARG_BOOL, 'S', C_SHOW_ERROR},
   {"show-headers",               ARG_BOOL, 'i', C_SHOW_HEADERS},
-  {"sigalgs",                    ARG_STRG|ARG_TLS, ' ',
-   C_SIGNATURE_ALGORITHMS},
+  {"sigalgs",                    ARG_STRG|ARG_TLS, ' ', C_SIGNATURE_ALGORITHMS},
+  {"signature-hashes",           ARG_STRG, ' ', C_SIGNATURE_HASHES}, // curl-impersonate
   {"silent",                     ARG_BOOL, 's', C_SILENT},
   {"skip-existing",              ARG_BOOL, ' ', C_SKIP_EXISTING},
   {"socks4",                     ARG_STRG, ' ', C_SOCKS4},
@@ -314,6 +328,7 @@ static const struct LongShort aliases[]= {
   {"socks5-hostname",            ARG_STRG, ' ', C_SOCKS5_HOSTNAME},
   {"speed-limit",                ARG_STRG, 'Y', C_SPEED_LIMIT},
   {"speed-time",                 ARG_STRG, 'y', C_SPEED_TIME},
+  {"split-cookies",              ARG_BOOL, ' ', C_SPLIT_COOKIES},
   {"ssl",                        ARG_BOOL|ARG_TLS, ' ', C_SSL},
   {"ssl-allow-beast",            ARG_BOOL|ARG_TLS, ' ', C_SSL_ALLOW_BEAST},
   {"ssl-auto-client-cert",       ARG_BOOL|ARG_TLS, ' ',
@@ -338,8 +353,17 @@ static const struct LongShort aliases[]= {
   {"tftp-blksize",               ARG_STRG, ' ', C_TFTP_BLKSIZE},
   {"tftp-no-options",            ARG_BOOL, ' ', C_TFTP_NO_OPTIONS},
   {"time-cond",                  ARG_STRG, 'z', C_TIME_COND},
+  {"tls-delegated-credentials",  ARG_STRG, ' ', C_TLS_DELEGATED_CREDENTIALS},  // curl-impersonate
   {"tls-earlydata",              ARG_BOOL|ARG_TLS, ' ', C_TLS_EARLYDATA},
+  {"tls-extension-order",        ARG_STRG, ' ', C_TLS_EXTENSION_ORDER},  // curl-impersonate
+  {"tls-grease",                 ARG_BOOL, ' ', C_TLS_GREASE},  // curl-impersonate
+  {"tls-key-shares-limit",       ARG_STRG, ' ', C_TLS_KEY_SHARES_LIMIT},  // curl-impersonate
   {"tls-max",                    ARG_STRG|ARG_TLS, ' ', C_TLS_MAX},
+  {"tls-permute-extensions",     ARG_BOOL, ' ', C_TLS_PERMUTE_EXTENSIONS},  // curl-impersonate
+  {"tls-record-size-limit",      ARG_STRG, ' ', C_TLS_RECORD_SIZE_LIMIT},  // curl-impersonate
+  {"tls-session-ticket",         ARG_BOOL, ' ', C_TLS_SESSION_TICKET},  // curl-impersonate
+  {"tls-signed-cert-timestamps", ARG_BOOL, ' ', C_TLS_SIGNED_CERT_TIMESTAMPS}, // curl-impersonate
+  {"tls-use-new-alps-codepoint", ARG_BOOL, ' ', C_TLS_USE_NEW_ALPS_CODEPOINT},  // curl-impersonate
   {"tls13-ciphers",              ARG_STRG|ARG_TLS, ' ', C_TLS13_CIPHERS},
   {"tlsauthtype",                ARG_STRG|ARG_TLS, ' ', C_TLSAUTHTYPE},
   {"tlspassword",              ARG_STRG|ARG_TLS|ARG_CLEAR, ' ', C_TLSPASSWORD},
@@ -1771,6 +1795,9 @@ static ParameterError opt_bool(struct OperationConfig *config,
   case C_ALPN: /* --alpn */
     config->noalpn = !toggle;
     break;
+  case C_ALPS:  /* --alps curl-impersonate */
+    config->alps = toggle;
+    break;
   case C_DISABLE_EPSV: /* --disable-epsv */
     config->disable_epsv = toggle;
     break;
@@ -1936,6 +1963,26 @@ static ParameterError opt_bool(struct OperationConfig *config,
   case C_TLS_EARLYDATA: /* --tls-earlydata */
     config->ssl_allow_earlydata = toggle;
     break;
+  case C_TLS_SIGNED_CERT_TIMESTAMPS:
+    config->tls_signed_cert_timestamps = toggle;
+    break;
+  case C_TLS_SESSION_TICKET:  /* --tls-session-ticket curl-impersonate */
+    config->noticket = (!toggle)?TRUE:FALSE;
+    break;
+  case C_TLS_PERMUTE_EXTENSIONS:  /* --tls-permute-extensions curl-impersonate */
+    config->ssl_permute_extensions = toggle;
+    break;
+  case C_TLS_GREASE:  /* --tls-grease curl-impersonate */
+    config->tls_grease = toggle;
+    break;
+  case C_TLS_USE_NEW_ALPS_CODEPOINT: /* --tls-use-new-alps-codepoint curl-impersonate */
+    config->tls_use_new_alps_codepoint = toggle;
+    break;
+  case C_HTTP2_NO_PRIORITY:
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    config->http2_no_priority = toggle;
+    break;
   case C_SUPPRESS_CONNECT_HEADERS: /* --suppress-connect-headers */
     config->suppress_connect_headers = toggle;
     break;
@@ -2057,6 +2104,9 @@ static ParameterError opt_bool(struct OperationConfig *config,
   case C_JUNK_SESSION_COOKIES: /* --junk-session-cookies */
     config->cookiesession = toggle;
     break;
+  case C_SPLIT_COOKIES: /* --split-cookies */
+    config->split_cookies = toggle;
+    break;
   case C_HEAD: /* --head */
     config->no_body = toggle;
     config->show_headers = toggle;
@@ -2144,6 +2194,9 @@ static ParameterError opt_bool(struct OperationConfig *config,
   case C_MPTCP: /* --mptcp */
     config->mptcp = toggle;
     break;
+  case C_PROXY_CREDENTIAL_NO_REUSE: /*  --proxy-credential-no-reuse */
+    config->proxy_credential_no_reuse = toggle;
+    break;
   default:
     return PARAM_OPTION_UNKNOWN;
   }
@@ -2424,6 +2477,72 @@ static ParameterError opt_filestring(struct OperationConfig *config,
   case C_TLS_MAX: /* --tls-max */
     err = str2tls_max(&config->ssl_version_max, nextarg);
     break;
+  case C_TLS_RECORD_SIZE_LIMIT:
+    err = str2unum(&config->tls_record_size_limit, nextarg);
+    break;
+  case C_TLS_KEY_SHARES_LIMIT:
+    err = str2unum(&config->tls_key_shares_limit, nextarg);
+    break;
+  case C_TLS_EXTENSION_ORDER:  /* --tls-extension-order curl-impersonate */
+    err = getstr(&config->tls_extension_order, nextarg, ALLOW_BLANK);
+    break;
+  case C_TLS_DELEGATED_CREDENTIALS:
+    err = getstr(&config->tls_delegated_credentials, nextarg, ALLOW_BLANK);
+    break;
+  case C_HTTP2_PSEUDO_HEADERS_ORDER: /* --http2-pseudo-headers-order curl-impersonate */
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = getstr(&config->http2_pseudo_headers_order, nextarg, ALLOW_BLANK);
+    break;
+  case C_HTTP2_SETTINGS:  /* --http2-settings curl-impersonate */
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = getstr(&config->http2_settings, nextarg, ALLOW_BLANK);
+    break;
+  case C_HTTP2_STREAM_EXCLUSIVE:
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = str2num(&config->http2_stream_exclusive, nextarg);
+    if(config->http2_stream_exclusive < 0) return PARAM_BAD_NUMERIC;
+    break;
+  case C_HTTP2_STREAM_WEIGHT:
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = str2num(&config->http2_stream_weight, nextarg);
+    if(config->http2_stream_weight < 0) return PARAM_BAD_NUMERIC;
+    break;
+  case C_HTTP2_WINDOW_UPDATE:  /* --http2-window-update curl-impersonate */
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = str2num(&config->http2_window_update, nextarg);
+    if(config->http2_window_update < -1) return PARAM_BAD_NUMERIC;
+    break;
+  case C_HTTP2_STREAMS:  /* --http2-streams curl-impersonate */
+    if(!feature_http2)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = getstr(&config->http2_streams, nextarg, ALLOW_BLANK);
+    break;
+  case C_HTTP3_PSEUDO_HEADERS_ORDER: /* --http3-pseudo-headers-order curl-impersonate */
+    if(!feature_http3)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = getstr(&config->http3_pseudo_headers_order, nextarg, ALLOW_BLANK);
+    break;
+  case C_HTTP3_SETTINGS:  /* --http3-settings curl-impersonate */
+    if(!feature_http3)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = getstr(&config->http3_settings, nextarg, ALLOW_BLANK);
+    break;
+  case C_QUIC_TRANSPORT_PARAMETERS:  /* --quic-transport-params curl-impersonate */
+    if(!feature_http3)
+      return PARAM_LIBCURL_DOESNT_SUPPORT;
+    err = getstr(&config->quic_transport_parameters, nextarg, ALLOW_BLANK);
+    break;
+  case C_CERT_COMPRESSION:  /* --cert-compression curl-impersonate */
+    err = getstr(&config->ssl_cert_compression, nextarg, ALLOW_BLANK);
+    break;
+  case C_SIGNATURE_HASHES: /* --signature-hashes */
+    err = getstr(&config->ssl_sig_hash_algs, nextarg, ALLOW_BLANK);
+    break;
   case C_HAPPY_EYEBALLS_TIMEOUT_MS: /* --happy-eyeballs-timeout-ms */
     err = str2unum(&config->happy_eyeballs_timeout_ms, nextarg);
     /* 0 is a valid value for this timeout */
@@ -2456,6 +2575,9 @@ static ParameterError opt_filestring(struct OperationConfig *config,
     else
       err = getstr(&config->hsts, nextarg, ALLOW_BLANK);
     break;
+  case C_IMPERSONATE: /* --impersonate */
+    err = getstr(&config->impersonate, nextarg, DENY_BLANK);
+    break;
   case C_COOKIE: /* --cookie */
     if(strchr(nextarg, '=')) {
       /* A cookie string must have a =-letter */
diff --git a/src/tool_getparam.h b/src/tool_getparam.h
index 50625d1441..1e0aa26015 100644
--- a/src/tool_getparam.h
+++ b/src/tool_getparam.h
@@ -31,6 +31,7 @@
 typedef enum {
   C_ABSTRACT_UNIX_SOCKET,
   C_ALPN,
+  C_ALPS,
   C_ALT_SVC,
   C_ANYAUTH,
   C_APPEND,
@@ -41,6 +42,7 @@ typedef enum {
   C_CACERT,
   C_CAPATH,
   C_CERT,
+  C_CERT_COMPRESSION,
   C_CERT_STATUS,
   C_CERT_TYPE,
   C_CIPHERS,
@@ -121,10 +123,20 @@ typedef enum {
   C_HTTP1_0,
   C_HTTP1_1,
   C_HTTP2,
+  C_HTTP2_NO_PRIORITY,
   C_HTTP2_PRIOR_KNOWLEDGE,
+  C_HTTP2_PSEUDO_HEADERS_ORDER,
+  C_HTTP2_SETTINGS,
+  C_HTTP2_STREAM_EXCLUSIVE,
+  C_HTTP2_STREAM_WEIGHT,
+  C_HTTP2_STREAMS,
+  C_HTTP2_WINDOW_UPDATE,
   C_HTTP3,
   C_HTTP3_ONLY,
+  C_HTTP3_PSEUDO_HEADERS_ORDER,
+  C_HTTP3_SETTINGS,
   C_IGNORE_CONTENT_LENGTH,
+  C_IMPERSONATE,
   C_INCLUDE,
   C_INSECURE,
   C_INTERFACE,
@@ -193,6 +205,7 @@ typedef enum {
   C_PROXY_CERT,
   C_PROXY_CERT_TYPE,
   C_PROXY_CIPHERS,
+  C_PROXY_CREDENTIAL_NO_REUSE,
   C_PROXY_CRLFILE,
   C_PROXY_DIGEST,
   C_PROXY_HEADER,
@@ -216,6 +229,7 @@ typedef enum {
   C_PROXY1_0,
   C_PROXYTUNNEL,
   C_PUBKEY,
+  C_QUIC_TRANSPORT_PARAMETERS,
   C_QUOTE,
   C_RANDOM_FILE,
   C_RANGE,
@@ -241,6 +255,7 @@ typedef enum {
   C_SESSIONID,
   C_SHOW_ERROR,
   C_SHOW_HEADERS,
+  C_SIGNATURE_HASHES,
   C_SILENT,
   C_SIGNATURE_ALGORITHMS,
   C_SKIP_EXISTING,
@@ -254,6 +269,7 @@ typedef enum {
   C_SOCKS5_HOSTNAME,
   C_SPEED_LIMIT,
   C_SPEED_TIME,
+  C_SPLIT_COOKIES,
   C_SSL,
   C_SSL_ALLOW_BEAST,
   C_SSL_AUTO_CLIENT_CERT,
@@ -275,7 +291,16 @@ typedef enum {
   C_TFTP_NO_OPTIONS,
   C_TIME_COND,
   C_TLS_EARLYDATA,
+  C_TLS_DELEGATED_CREDENTIALS,
+  C_TLS_EXTENSION_ORDER,
+  C_TLS_GREASE,
+  C_TLS_KEY_SHARES_LIMIT,
   C_TLS_MAX,
+  C_TLS_PERMUTE_EXTENSIONS,
+  C_TLS_RECORD_SIZE_LIMIT,
+  C_TLS_SESSION_TICKET,
+  C_TLS_SIGNED_CERT_TIMESTAMPS,
+  C_TLS_USE_NEW_ALPS_CODEPOINT,
   C_TLS13_CIPHERS,
   C_TLSAUTHTYPE,
   C_TLSPASSWORD,
diff --git a/src/tool_listhelp.c b/src/tool_listhelp.c
index beb034eeaf..531a43d7e7 100644
--- a/src/tool_listhelp.c
+++ b/src/tool_listhelp.c
@@ -111,6 +111,36 @@ const struct helptxt helptext[] = {
   {"    --curves <list>",
    "(EC) TLS key exchange algorithms to request",
    CURLHELP_TLS},
+  {"    --signature-hashes <algorithm list>",
+   "TLS signature hash algorithm(s) to use",
+   CURLHELP_TLS},
+  {"    --cert-compression <algorithm list>",
+   "TLS cert compressions algorithm(s) to use",
+   CURLHELP_TLS},
+  {"    --no-tls-session-ticket",
+   "Disable the TLS session ticket extension",
+   CURLHELP_TLS},
+  {"    --http2-pseudo-headers-order",
+   "Change the order of the HTTP2 pseudo headers",
+   CURLHELP_HTTP},
+  {"    --http2-settings",
+   "Change the order and values of the HTTP2 settings frame, e.g. 1:65536;2:0;4:6291456;6:262144",
+   CURLHELP_HTTP},
+  {"    --http2-window-update",
+   "Change the initial value for window update",
+   CURLHELP_HTTP},
+  {"    --http3-pseudo-headers-order",
+   "Change the order of the HTTP3 pseudo headers",
+   CURLHELP_HTTP},
+  {"    --http3-settings",
+   "Change the order/values of the HTTP3 settings frame, e.g. 1:0;6:4611686018427387903;7:0;GREASE",
+   CURLHELP_HTTP},
+  {"    --quic-transport-params",
+   "Set QUIC transport parameters, e.g. 1:30000;3:1350;17:1@1,GREASE;12;GREASE",
+   CURLHELP_HTTP},
+  {"    --tls-permute-extensions",
+   "Enable BoringSSL TLS extensions permutations on client hello",
+   CURLHELP_TLS},
   {"-d, --data <data>",
    "HTTP POST data",
    CURLHELP_IMPORTANT | CURLHELP_HTTP | CURLHELP_POST | CURLHELP_UPLOAD},
@@ -302,6 +332,9 @@ const struct helptxt helptext[] = {
   {"    --ignore-content-length",
    "Ignore the size of the remote resource",
    CURLHELP_HTTP | CURLHELP_FTP},
+  {"    --impersonate <target>",
+   "Impersonate a browser or client",
+   CURLHELP_CURL},
   {"-k, --insecure",
    "Allow insecure server connections",
    CURLHELP_TLS | CURLHELP_SFTP | CURLHELP_SCP | CURLHELP_SSH},
@@ -326,6 +359,9 @@ const struct helptxt helptext[] = {
   {"-j, --junk-session-cookies",
    "Ignore session cookies read from file",
    CURLHELP_HTTP},
+  {"    --split-cookies",
+   "Send cookies as separate Cookie: header lines",
+   CURLHELP_HTTP},
   {"    --keepalive-cnt <integer>",
    "Maximum number of keepalive probes",
    CURLHELP_CONNECTION},
@@ -411,6 +447,9 @@ const struct helptxt helptext[] = {
   {"    --no-alpn",
    "Disable the ALPN TLS extension",
    CURLHELP_TLS | CURLHELP_HTTP},
+  {"    --alps",
+   "Enable the ALPS TLS extension",
+   CURLHELP_TLS | CURLHELP_HTTP},
   {"-N, --no-buffer",
    "Disable buffering of the output stream",
    CURLHELP_OUTPUT},
@@ -429,6 +468,9 @@ const struct helptxt helptext[] = {
   {"    --no-sessionid",
    "Disable SSL session-ID reusing",
    CURLHELP_TLS},
+  {"    --no-split-cookies",
+   "Merge cookies into a single Cookie: header line",
+   CURLHELP_HTTP},
   {"    --noproxy <no-proxy-list>",
    "List of hosts which do not use proxy",
    CURLHELP_PROXY},
@@ -517,6 +559,9 @@ const struct helptxt helptext[] = {
   {"    --proxy-ciphers <list>",
    "TLS 1.2 (1.1, 1.0) ciphers to use for proxy",
    CURLHELP_PROXY | CURLHELP_TLS},
+   {"    --proxy-credential-no-reuse",
+   "Disallows reusing connections or ssl sessions over different proxy credentials for the same host",
+   CURLHELP_PROXY | CURLHELP_TLS},
   {"    --proxy-crlfile <file>",
    "Set a CRL list for proxy",
    CURLHELP_PROXY | CURLHELP_TLS},
diff --git a/src/tool_paramhlp.c b/src/tool_paramhlp.c
index 97a6b6e2ee..bd6ef802bf 100644
--- a/src/tool_paramhlp.c
+++ b/src/tool_paramhlp.c
@@ -697,6 +697,7 @@ CURLcode get_args(struct OperationConfig *config, const size_t i)
 {
   CURLcode result = CURLE_OK;
   bool last = (config->next ? FALSE : TRUE);
+  char *env_target = NULL;
 
   if(config->jsoned) {
     ParameterError err = PARAM_OK;
@@ -718,14 +719,18 @@ CURLcode get_args(struct OperationConfig *config, const size_t i)
   if(!result && config->proxyuserpwd)
     result = checkpasswd("proxy", i, last, &config->proxyuserpwd);
 
-  /* Check if we have a user agent */
-  if(!result && !config->useragent) {
+  env_target = curl_getenv("CURL_IMPERSONATE");
+
+  /* Check if we have a user agent, do not override impersonate value */
+  if(!result && !config->useragent &&
+     !config->impersonate && !env_target) {
     config->useragent = my_useragent();
     if(!config->useragent) {
       errorf(config->global, "out of memory");
       result = CURLE_OUT_OF_MEMORY;
     }
   }
+  curl_free(env_target);
 
   return result;
 }
diff --git a/src/tool_setopt.c b/src/tool_setopt.c
index 89505979c9..89305b0f7d 100644
--- a/src/tool_setopt.c
+++ b/src/tool_setopt.c
@@ -156,6 +156,9 @@ static const struct NameValue setopt_nv_CURLNONZERODEFAULTS[] = {
   NV1(CURLOPT_SSL_VERIFYHOST, 1),
   NV1(CURLOPT_SSL_ENABLE_NPN, 1),
   NV1(CURLOPT_SSL_ENABLE_ALPN, 1),
+  NV1(CURLOPT_SSL_ENABLE_TICKET, 1),
+  NV1(CURLOPT_SSL_PERMUTE_EXTENSIONS, 1),
+  NV1(CURLOPT_TLS_STATUS_REQUEST, 1),
   NV1(CURLOPT_TCP_NODELAY, 1),
   NV1(CURLOPT_PROXY_SSL_VERIFYPEER, 1),
   NV1(CURLOPT_PROXY_SSL_VERIFYHOST, 1),
